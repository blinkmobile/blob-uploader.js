/*
* blob-uploader.js: v0.0.1 | https://github.com/blinkmobile/blob-uploader.js#readme
* (c) 2017 BlinkMobile | Released under the MIT license
*/

var BlobUploader =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 84);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * The main AWS namespace
 */
var AWS = { util: __webpack_require__(1) };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.100.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: __webpack_require__(26),
    Query: __webpack_require__(45),
    Rest: __webpack_require__(15),
    RestJson: __webpack_require__(47),
    RestXml: __webpack_require__(48)
  },

  /**
   * @api private
   */
  XML: {
    Builder: __webpack_require__(89),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: __webpack_require__(27),
    Parser: __webpack_require__(28)
  },

  /**
   * @api private
   */
  Model: {
    Api: __webpack_require__(71),
    Operation: __webpack_require__(72),
    Shape: __webpack_require__(10),
    Paginator: __webpack_require__(73),
    ResourceWaiter: __webpack_require__(74)
  },

  /**
   * @api private
   */
  apiLoader: __webpack_require__(196)
});

__webpack_require__(197);
__webpack_require__(200);

__webpack_require__(77);
__webpack_require__(78);
__webpack_require__(201);
__webpack_require__(205);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(215);

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + __webpack_require__(0).VERSION;
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  isBrowser: function isBrowser() { return process && process.browser; },
  isNode: function isNode() { return !util.isBrowser(); },
  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return __webpack_require__(42).readFileSync(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ? util.Buffer.from(string) : new util.Buffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ? util.Buffer.from(string, 'base64') : new util.Buffer(string, 'base64');
    }

  },

  buffer: {
    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = new util.Buffer(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = new util.Buffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return __webpack_require__(42).lstatSync(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = __webpack_require__(0);
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = new util.Buffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = new util.Buffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = new util.Buffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = options && options.name || err.name || err.code || 'Error';
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operation = req.operation;
    var output = req.service.api.operations[operation].output;
    if (output.payload) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = __webpack_require__(42);
      if (body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') var deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      return new PromiseDependency(function(resolve, reject) {
        self[methodName](function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = __webpack_require__(216);
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;
      if (err && err.retryable && retryCount < maxRetries) {
        retryCount++;
        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);
        setTimeout(sendRequest, delay + (err.retryAfter || 0));
      } else {
        cb(err);
      }
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              { retryable: statusCode >= 500 || statusCode === 429 }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return __webpack_require__(217).v4();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE'
};

module.exports = util;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(86).setImmediate))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssign = __webpack_require__(117),
    baseCreate = __webpack_require__(118);

/**
 * Creates an object that inherits from the `prototype` object. If a
 * `properties` object is given, its own enumerable string keyed properties
 * are assigned to the created object.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties) {
  var result = baseCreate(prototype);
  return properties == null ? result : baseAssign(result, properties);
}

module.exports = create;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(52);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(92),
    getValue = __webpack_require__(97);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isEmpty, isFunction, isObject,
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(3);

  isFunction = __webpack_require__(16);

  isEmpty = __webpack_require__(119);

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      this.options = this.parent.options;
      this.stringify = this.parent.stringify;
      if (XMLElement === null) {
        XMLElement = __webpack_require__(59);
        XMLCData = __webpack_require__(68);
        XMLComment = __webpack_require__(69);
        XMLDeclaration = __webpack_require__(57);
        XMLDocType = __webpack_require__(70);
        XMLRaw = __webpack_require__(194);
        XMLText = __webpack_require__(195);
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref;
      if (name != null) {
        name = name.valueOf();
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      doc.xmldec = xmldec;
      return doc.root();
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var doc, doctype;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      doc.doctype = doctype;
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var child;
      if (this.isRoot) {
        return this;
      }
      child = this.parent;
      while (!child.isRoot) {
        child = child.parent;
      }
      return child;
    };

    XMLNode.prototype.document = function() {
      return this.root().documentObject;
    };

    XMLNode.prototype.end = function(options) {
      return this.document().toString(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
      var clonedRoot;
      clonedRoot = xmlbuilder.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),
/* 9 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var Collection = __webpack_require__(46);

var util = __webpack_require__(1);

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (!this.timestampFormat && this.api) {
    if (this.api.timestampFormat) {
      property(this, 'timestampFormat', this.api.timestampFormat);
    } else {
      switch (this.api.protocol) {
        case 'json':
        case 'rest-json':
          property(this, 'timestampFormat', 'unixTimestamp');
          break;
        case 'rest-xml':
        case 'query':
        case 'ec2':
          property(this, 'timestampFormat', 'iso8601');
          break;
      }
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = util.base64.decode;
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

module.exports = Shape;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(17),
    getRawTag = __webpack_require__(93),
    objectToString = __webpack_require__(94);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(16),
    isLength = __webpack_require__(30);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(106),
    baseKeys = __webpack_require__(56),
    isArrayLike = __webpack_require__(12);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(String(val));
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(String(paramValue));
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(11),
    isObject = __webpack_require__(3);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(135),
    listCacheDelete = __webpack_require__(136),
    listCacheGet = __webpack_require__(137),
    listCacheHas = __webpack_require__(138),
    listCacheSet = __webpack_require__(139);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(18);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(153);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(40);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25);
var AWS = __webpack_require__(0);
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
__webpack_require__(234);
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = __webpack_require__(235);
    model.paginators = __webpack_require__(236).pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var util = __webpack_require__(1);

// browser specific modules
util.crypto.lib = __webpack_require__(220);
util.Buffer = __webpack_require__(43).Buffer;
util.url = __webpack_require__(228);
util.querystring = __webpack_require__(83);
util.environment = 'js';

var AWS = __webpack_require__(0);
module.exports = AWS;

__webpack_require__(75);
__webpack_require__(76);
__webpack_require__(233);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(243);

// Load the DOMParser XML parser
AWS.XML.Parser = __webpack_require__(244);

// Load the XHR HttpClient
__webpack_require__(245);

if (typeof process === 'undefined') {
  process = {
    browser: true
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var JsonBuilder = __webpack_require__(27);
var JsonParser = __webpack_require__(28);

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      if (e.__type || e.code) {
        error.code = (e.__type || e.code).split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

module.exports = JsonBuilder;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

module.exports = JsonParser;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(108),
    isObjectLike = __webpack_require__(14);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5),
    stubFalse = __webpack_require__(109);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(110),
    baseUnary = __webpack_require__(111),
    nodeUtil = __webpack_require__(112);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(145),
    mapCacheDelete = __webpack_require__(152),
    mapCacheGet = __webpack_require__(154),
    mapCacheHas = __webpack_require__(155),
    mapCacheSet = __webpack_require__(156);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4),
    isSymbol = __webpack_require__(40);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(11),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})( false ? this.jmespath = {} : exports);


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(221)
var ieee754 = __webpack_require__(222)
var isArray = __webpack_require__(223)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(43).Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var util = __webpack_require__(1);
var QueryParamSerializer = __webpack_require__(88);
var Shape = __webpack_require__(10);

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var memoizedProperty = __webpack_require__(1).memoizedProperty;

function memoize(name, value, fn, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return fn(name, value);
  });
}

function Collection(iterable, options, fn, nameTr) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], fn, nameTr);
    }
  }
}

module.exports = Collection;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var Rest = __webpack_require__(15);
var Json = __webpack_require__(26);
var JsonBuilder = __webpack_require__(27);
var JsonParser = __webpack_require__(28);

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];
    if (params === undefined) return;

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params, payloadShape);
      applyContentTypeHeader(req);
    } else { // non-JSON payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.build(req.params, input);
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req) {
  if (!req.httpRequest.headers['Content-Type']) {
    req.httpRequest.headers['Content-Type'] = 'application/json';
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD/DELETE
  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var rules = req.service.api.operations[req.operation].output || {};
  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var util = __webpack_require__(1);
var Rest = __webpack_require__(15);

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(50),
    eq = __webpack_require__(18);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(51);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(49),
    baseAssignValue = __webpack_require__(50);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(18),
    isArrayLike = __webpack_require__(12),
    isIndex = __webpack_require__(31),
    isObject = __webpack_require__(3);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(32),
    nativeKeys = __webpack_require__(113);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDeclaration, XMLNode, create, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  isObject = __webpack_require__(3);

  XMLNode = __webpack_require__(8);

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?xml';
      r += ' version="' + this.version + '"';
      if (this.encoding != null) {
        r += ' encoding="' + this.encoding + '"';
      }
      if (this.standalone != null) {
        r += ' standalone="' + this.standalone + '"';
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(120),
    Map = __webpack_require__(37),
    Promise = __webpack_require__(121),
    Set = __webpack_require__(122),
    WeakMap = __webpack_require__(123),
    baseGetTag = __webpack_require__(11),
    toSource = __webpack_require__(53);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isFunction, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  isObject = __webpack_require__(3);

  isFunction = __webpack_require__(16);

  every = __webpack_require__(124);

  XMLNode = __webpack_require__(8);

  XMLAttribute = __webpack_require__(189);

  XMLProcessingInstruction = __webpack_require__(67);

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.children = [];
      this.instructions = [];
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, i, len, pi, ref, ref1;
      clonedSelf = create(XMLElement.prototype, this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref = this.attributes;
      for (attName in ref) {
        if (!hasProp.call(ref, attName)) continue;
        att = ref[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.instructions = [];
      ref1 = this.instructions;
      for (i = 0, len = ref1.length; i < len; i++) {
        pi = ref1[i];
        clonedSelf.instructions.push(pi.clone());
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, instruction, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.instructions.push(instruction);
      }
      return this;
    };

    XMLElement.prototype.toString = function(options, level) {
      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      ref3 = this.instructions;
      for (i = 0, len = ref3.length; i < len; i++) {
        instruction = ref3[i];
        r += instruction.toString(options, level);
      }
      if (pretty) {
        r += space;
      }
      r += '<' + this.name;
      ref4 = this.attributes;
      for (name in ref4) {
        if (!hasProp.call(ref4, name)) continue;
        att = ref4[name];
        r += att.toString(options);
      }
      if (this.children.length === 0 || every(this.children, function(e) {
        return e.value === '';
      })) {
        r += '/>';
        if (pretty) {
          r += newline;
        }
      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
        r += '>';
        r += this.children[0].value;
        r += '</' + this.name + '>';
        r += newline;
      } else {
        r += '>';
        if (pretty) {
          r += newline;
        }
        ref5 = this.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          child = ref5[j];
          r += child.toString(options, level + 1);
        }
        if (pretty) {
          r += space;
        }
        r += '</' + this.name + '>';
        if (pretty) {
          r += newline;
        }
      }
      return r;
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(19),
    stackClear = __webpack_require__(140),
    stackDelete = __webpack_require__(141),
    stackGet = __webpack_require__(142),
    stackHas = __webpack_require__(143),
    stackSet = __webpack_require__(144);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(157),
    isObjectLike = __webpack_require__(14);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(158),
    arraySome = __webpack_require__(161),
    cacheHas = __webpack_require__(162);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 64 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(66),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(4),
    isKey = __webpack_require__(39),
    stringToPath = __webpack_require__(177),
    toString = __webpack_require__(180);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLProcessingInstruction, create;

  create = __webpack_require__(2);

  module.exports = XMLProcessingInstruction = (function() {
    function XMLProcessingInstruction(parent, target, value) {
      this.stringify = parent.stringify;
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return create(XMLProcessingInstruction.prototype, this);
    };

    XMLProcessingInstruction.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?';
      r += this.target;
      if (this.value) {
        r += ' ' + this.value;
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLProcessingInstruction;

  })();

}).call(this);


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  XMLNode = __webpack_require__(8);

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return create(XMLCData.prototype, this);
    };

    XMLCData.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<![CDATA[' + this.text + ']]>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLCData;

  })(XMLNode);

}).call(this);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLComment, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  XMLNode = __webpack_require__(8);

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return create(XMLComment.prototype, this);
    };

    XMLComment.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!-- ' + this.text + ' -->';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLComment;

  })(XMLNode);

}).call(this);


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

  create = __webpack_require__(2);

  isObject = __webpack_require__(3);

  XMLCData = __webpack_require__(68);

  XMLComment = __webpack_require__(69);

  XMLDTDAttList = __webpack_require__(190);

  XMLDTDEntity = __webpack_require__(191);

  XMLDTDElement = __webpack_require__(192);

  XMLDTDNotation = __webpack_require__(193);

  XMLProcessingInstruction = __webpack_require__(67);

  module.exports = XMLDocType = (function() {
    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      this.documentObject = parent;
      this.stringify = this.documentObject.stringify;
      this.children = [];
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.instruction = function(target, value) {
      var child;
      child = new XMLProcessingInstruction(this, target, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.root = function() {
      return this.documentObject.root();
    };

    XMLDocType.prototype.document = function() {
      return this.documentObject;
    };

    XMLDocType.prototype.toString = function(options, level) {
      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!DOCTYPE ' + this.root().name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      if (this.children.length > 0) {
        r += ' [';
        if (pretty) {
          r += newline;
        }
        ref3 = this.children;
        for (i = 0, len = ref3.length; i < len; i++) {
          child = ref3[i];
          r += child.toString(options, level + 1);
        }
        r += ']';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocType.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocType.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root();
    };

    XMLDocType.prototype.doc = function() {
      return this.document();
    };

    return XMLDocType;

  })();

}).call(this);


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var Collection = __webpack_require__(46);
var Operation = __webpack_require__(72);
var Shape = __webpack_require__(10);
var Paginator = __webpack_require__(73);
var ResourceWaiter = __webpack_require__(74);

var util = __webpack_require__(1);
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

module.exports = Api;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var Shape = __webpack_require__(10);

var util = __webpack_require__(1);
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

}

module.exports = Operation;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var property = __webpack_require__(1).property;

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

module.exports = Paginator;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

module.exports = ResourceWaiter;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    if (this.providers.length === 0) {
      callback(new Error('No providers'));
      return this;
    }

    var index = 0;
    var providers = this.providers.slice(0);

    function resolveNext(err, creds) {
      if ((!err && creds) || index === providers.length) {
        callback(err, creds);
        return;
      }

      var provider = providers[index++];
      if (typeof provider === 'function') {
        creds = provider.call();
      } else {
        creds = provider;
      }

      if (creds.get) {
        creds.get(function(getErr) {
          resolveNext(getErr, getErr ? null : creds);
        });
      } else {
        resolveNext(null, creds);
      }
    }

    resolveNext();
    return this;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () {
 *     // if AWS_CONTAINER_CREDENTIALS_RELATIVE_URI is set
 *       return new AWS.ECSCredentials();
 *     // else
 *       return new AWS.EC2MetadataCredentials();
 *   }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  }

});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener) {
    if (this._events[eventName]) {
      this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  /**
   * @api private
   */
  onAsync: function onAsync(eventName, listener) {
    listener._isAsync = true;
    return this.on(eventName, listener);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback) {
    this[name] = callback;
    this.addListener(eventName, callback);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

module.exports = AWS.SequentialExecutor;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

module.exports = AWS.Signers.V3;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 82 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(231);
exports.encode = exports.stringify = __webpack_require__(232);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(85)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(module, require('aws-sdk/clients/s3'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, global.s3);
    global.blobUploader = mod.exports;
  }
})(this, function (module, S3) {
  // @flow
  'use strict';

  var privateVars = new WeakMap();

  function BlobUploader(apiUrl /* :string */) {
    if (!apiUrl) {
      throw new TypeError('BlobUploader expects a api URL during instantiation');
    }
    privateVars.set(this, {
      uri: apiUrl
    });
  }

  BlobUploader.prototype.retrieveBlobUrl = function (uuid /* :string */
  ) /* :Promise<string> */{
    if (!uuid) {
      return Promise.reject(new Error('uuid argument not provided'));
    }

    if (!privateVars || !privateVars.get(this)) {
      return Promise.reject(new Error('BlobUploader uri not configured'));
    }
    var vars = privateVars.get(this);
    if (!vars || !vars.hasOwnProperty('uri')) {
      return Promise.reject(new Error('BlobUploader uri not configured'));
    }

    var request = new Request(vars.uri + 'v1/signedURL/' + uuid, {
      method: 'PUT',
      mode: 'cors'
    });

    return fetch(request).then(function (response) {
      if (!response.ok) {
        return Promise.reject(new Error(response.status + ' ' + response.statusText));
      }
      return response.json();
    }).then(function (apiResponse) {
      return apiResponse.getUrl;
    }).catch(function (err) {
      return Promise.reject(new Error('Error retrieving blob url: ' + err));
    });
  };

  BlobUploader.prototype.uploadBlob = function (blob /*: Blob */
  , progressFn /* ?:Function */
  ) /* :Promise<Object> */{
    if (!blob) {
      return Promise.reject(new Error('blob argument not provided'));
    }

    var vars = privateVars.get(this);
    if (!vars || !vars.hasOwnProperty('uri')) {
      return Promise.reject(new Error('BlobUploader uri not configured'));
    }

    var request = new Request(vars.uri + 'v1/temporaryCredentials', {
      method: 'GET',
      mode: 'cors'
    });

    return fetch(request).then(function (response) {
      if (!response.ok) {
        return Promise.reject(new Error(response.status + ' ' + response.statusText));
      }
      return response.json();
    }).then(function (apiResponse) {
      var s3 = new S3({
        accessKeyId: apiResponse.credentials.AccessKeyId,
        secretAccessKey: apiResponse.credentials.SecretAccessKey,
        sessionToken: apiResponse.credentials.SessionToken,
        region: apiResponse.region
      });
      var params = {
        Bucket: apiResponse.bucket,
        Key: apiResponse.id,
        Body: blob
      };
      var managedUpload = s3.upload(params);
      if (progressFn) {
        managedUpload.on('httpUploadProgress', function (evt) {
          progressFn(evt.loaded, evt.total);
        });
      }
      return {
        upload: function upload() {
          return managedUpload.promise();
        },
        cancel: function cancel() {
          return managedUpload.abort();
        },
        id: apiResponse.id
      };
    }).catch(function (err) {
      return Promise.reject(new Error('Error uploading to S3: ' + err));
    });
  };

  BlobUploader.prototype.uploadImage = function (image /*: Image */
  , progressFn /* ?:Function */
  ) /* :Promise<Object> */{
    if (!image) {
      return Promise.reject(new Error('image argument not provided'));
    }

    var vars = privateVars.get(this);
    if (!vars || !vars.hasOwnProperty('uri')) {
      return Promise.reject(new Error('blobUploader uri not configured'));
    }

    // Create an empty canvas element
    var canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;

    // Copy the image contents to the canvas
    var ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    var _this = this;

    return new Promise(function (resolve, reject) {
      canvas.toBlob(function (blob) {
        resolve(_this.uploadBlob(blob, progressFn));
      });
    });
  };

  module.exports = BlobUploader;
});

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25);
var AWS = __webpack_require__(0);
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['s3'] = {};
AWS.S3 = Service.defineService('s3', ['2006-03-01']);
__webpack_require__(247);
Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
  get: function get() {
    var model = __webpack_require__(249);
    model.paginators = __webpack_require__(250).pagination;
    model.waiters = __webpack_require__(251).waiters;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.S3;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(87);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9)))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

module.exports = QueryParamSerializer;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var builder = __webpack_require__(90);

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = builder.create(rootElement);
  applyNamespaces(xml, shape);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.root().toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.att(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = xml.ele(name);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = xml.ele(shape.flattened ? shape.name : 'entry');
    serialize(entry.ele(xmlKey), key, shape.key);
    serialize(entry.ele(xmlValue), value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = xml.ele(name);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = xml.ele(name);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.txt(shape.toWireFormat(value));
}

function applyNamespaces(xml, shape) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (xml.isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.att(prefix, uri);
}

module.exports = XmlBuilder;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, assign;

  assign = __webpack_require__(91);

  XMLBuilder = __webpack_require__(115);

  module.exports.create = function(name, xmldec, doctype, options) {
    options = assign({}, xmldec, doctype, options);
    return new XMLBuilder(name, options).root();
  };

}).call(this);


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(49),
    copyObject = __webpack_require__(54),
    createAssigner = __webpack_require__(98),
    isArrayLike = __webpack_require__(12),
    isPrototype = __webpack_require__(32),
    keys = __webpack_require__(13);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(16),
    isMasked = __webpack_require__(95),
    isObject = __webpack_require__(3),
    toSource = __webpack_require__(53);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(17);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 94 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(96);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(99),
    isIterateeCall = __webpack_require__(55);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(29),
    overRest = __webpack_require__(100),
    setToString = __webpack_require__(102);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(101);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(103),
    shortOut = __webpack_require__(105);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(104),
    defineProperty = __webpack_require__(51),
    identity = __webpack_require__(29);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 105 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(107),
    isArguments = __webpack_require__(33),
    isArray = __webpack_require__(4),
    isBuffer = __webpack_require__(34),
    isIndex = __webpack_require__(31),
    isTypedArray = __webpack_require__(36);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(11),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 109 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(11),
    isLength = __webpack_require__(30),
    isObjectLike = __webpack_require__(14);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(52);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(114);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

  XMLStringifier = __webpack_require__(116);

  XMLDeclaration = __webpack_require__(57);

  XMLDocType = __webpack_require__(70);

  XMLElement = __webpack_require__(59);

  module.exports = XMLBuilder = (function() {
    function XMLBuilder(name, options) {
      var root, temp;
      if (name == null) {
        throw new Error("Root element needs a name");
      }
      if (options == null) {
        options = {};
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      temp = new XMLElement(this, 'doc');
      root = temp.element(name);
      root.isRoot = true;
      root.documentObject = this;
      this.rootObject = root;
      if (!options.headless) {
        root.declaration(options);
        if ((options.pubID != null) || (options.sysID != null)) {
          root.doctype(options);
        }
      }
    }

    XMLBuilder.prototype.root = function() {
      return this.rootObject;
    };

    XMLBuilder.prototype.end = function(options) {
      return this.toString(options);
    };

    XMLBuilder.prototype.toString = function(options) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      r = '';
      if (this.xmldec != null) {
        r += this.xmldec.toString(options);
      }
      if (this.doctype != null) {
        r += this.doctype.toString(options);
      }
      r += this.rootObject.toString(options);
      if (pretty && r.slice(-newline.length) === newline) {
        r = r.slice(0, -newline.length);
      }
      return r;
    };

    return XMLBuilder;

  })();

}).call(this);


/***/ }),
/* 116 */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
      this.noDoubleEncoding = options != null ? options.noDoubleEncoding : void 0;
      ref = (options != null ? options.stringify : void 0) || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      if (val.match(/]]>/)) {
        throw new Error("Invalid CDATA text: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-]|-)*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var chars, chr;
      if (this.allowSurrogateChars) {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
      } else {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
      }
      chr = str.match(chars);
      if (chr) {
        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(54),
    keys = __webpack_require__(13);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(56),
    getTag = __webpack_require__(58),
    isArguments = __webpack_require__(33),
    isArray = __webpack_require__(4),
    isArrayLike = __webpack_require__(12),
    isBuffer = __webpack_require__(34),
    isPrototype = __webpack_require__(32),
    isTypedArray = __webpack_require__(36);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(6),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEvery = __webpack_require__(125),
    baseEvery = __webpack_require__(126),
    baseIteratee = __webpack_require__(132),
    isArray = __webpack_require__(4),
    isIterateeCall = __webpack_require__(55);

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = every;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(127);

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(128),
    createBaseEach = __webpack_require__(131);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(129),
    keys = __webpack_require__(13);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(130);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 130 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(12);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(133),
    baseMatchesProperty = __webpack_require__(175),
    identity = __webpack_require__(29),
    isArray = __webpack_require__(4),
    property = __webpack_require__(186);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(134),
    getMatchData = __webpack_require__(174),
    matchesStrictComparable = __webpack_require__(64);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(60),
    baseIsEqual = __webpack_require__(61);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 135 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(20);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(20);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(20);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(20);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(19);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 142 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 143 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(19),
    Map = __webpack_require__(37),
    MapCache = __webpack_require__(38);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(146),
    ListCache = __webpack_require__(19),
    Map = __webpack_require__(37);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(147),
    hashDelete = __webpack_require__(148),
    hashGet = __webpack_require__(149),
    hashHas = __webpack_require__(150),
    hashSet = __webpack_require__(151);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(21);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(22);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(60),
    equalArrays = __webpack_require__(62),
    equalByTag = __webpack_require__(163),
    equalObjects = __webpack_require__(167),
    getTag = __webpack_require__(58),
    isArray = __webpack_require__(4),
    isBuffer = __webpack_require__(34),
    isTypedArray = __webpack_require__(36);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(38),
    setCacheAdd = __webpack_require__(159),
    setCacheHas = __webpack_require__(160);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 162 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(17),
    Uint8Array = __webpack_require__(164),
    eq = __webpack_require__(18),
    equalArrays = __webpack_require__(62),
    mapToArray = __webpack_require__(165),
    setToArray = __webpack_require__(166);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(168);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(169),
    getSymbols = __webpack_require__(171),
    keys = __webpack_require__(13);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(170),
    isArray = __webpack_require__(4);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(172),
    stubArray = __webpack_require__(173);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 172 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(63),
    keys = __webpack_require__(13);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(61),
    get = __webpack_require__(176),
    hasIn = __webpack_require__(183),
    isKey = __webpack_require__(39),
    isStrictComparable = __webpack_require__(63),
    matchesStrictComparable = __webpack_require__(64),
    toKey = __webpack_require__(23);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(65);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(178);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(179);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(38);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(181);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(17),
    arrayMap = __webpack_require__(182),
    isArray = __webpack_require__(4),
    isSymbol = __webpack_require__(40);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(184),
    hasPath = __webpack_require__(185);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 184 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(66),
    isArguments = __webpack_require__(33),
    isArray = __webpack_require__(4),
    isIndex = __webpack_require__(31),
    isLength = __webpack_require__(30),
    toKey = __webpack_require__(23);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(187),
    basePropertyDeep = __webpack_require__(188),
    isKey = __webpack_require__(39),
    toKey = __webpack_require__(23);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(65);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, create;

  create = __webpack_require__(2);

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return create(XMLAttribute.prototype, this);
    };

    XMLAttribute.prototype.toString = function(options, level) {
      return ' ' + this.name + '="' + this.value + '"';
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDAttList, create;

  create = __webpack_require__(2);

  module.exports = XMLDTDAttList = (function() {
    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      this.stringify = parent.stringify;
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
      if (this.defaultValueType !== '#DEFAULT') {
        r += ' ' + this.defaultValueType;
      }
      if (this.defaultValue) {
        r += ' "' + this.defaultValue + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDAttList;

  })();

}).call(this);


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDEntity, create, isObject;

  create = __webpack_require__(2);

  isObject = __webpack_require__(3);

  module.exports = XMLDTDEntity = (function() {
    function XMLDTDEntity(parent, pe, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ENTITY';
      if (this.pe) {
        r += ' %';
      }
      r += ' ' + this.name;
      if (this.value) {
        r += ' "' + this.value + '"';
      } else {
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        if (this.nData) {
          r += ' NDATA ' + this.nData;
        }
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDEntity;

  })();

}).call(this);


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDElement, create;

  create = __webpack_require__(2);

  module.exports = XMLDTDElement = (function() {
    function XMLDTDElement(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDElement;

  })();

}).call(this);


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDNotation, create;

  create = __webpack_require__(2);

  module.exports = XMLDTDNotation = (function() {
    function XMLDTDNotation(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!NOTATION ' + this.name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.pubID) {
        r += ' PUBLIC "' + this.pubID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDNotation;

  })();

}).call(this);


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLRaw, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  XMLNode = __webpack_require__(8);

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return create(XMLRaw.prototype, this);
    };

    XMLRaw.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLText, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = __webpack_require__(2);

  XMLNode = __webpack_require__(8);

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return create(XMLText.prototype, this);
    };

    XMLText.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLText;

  })(XMLNode);

}).call(this);


/***/ }),
/* 196 */
/***/ (function(module, exports) {

function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};
module.exports = apiLoader;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var Api = __webpack_require__(71);
var regionConfig = __webpack_require__(198);
var inherit = AWS.util.inherit;
var clientCount = 0;

/**
 * The service class representing an AWS service.
 *
 * @abstract
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }
    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];

    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);

    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @abstract
   */
  setupRequestListeners: function setupRequestListeners() {
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }

    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api);
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

module.exports = AWS.Service;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var regionConfig = __webpack_require__(199);

function generateRegionPrefix(region) {
  if (!region) return null;

  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
      var config = regionConfig.rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set dualstack endpoint
      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
        config = util.copy(config);
        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

module.exports = configureEndpoint;


/***/ }),
/* 199 */
/***/ (function(module, exports) {

module.exports = {"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/iam":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":{"endpoint":"https://{service}.amazonaws.com","signatureVersion":"v3https","globalEndpoint":true},"*/waf":"globalSSL","us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3dash","us-west-1/s3":"s3dash","us-west-2/s3":"s3dash","eu-west-1/s3":"s3dash","ap-southeast-1/s3":"s3dash","ap-southeast-2/s3":"s3dash","ap-northeast-1/s3":"s3dash","sa-east-1/s3":"s3dash","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"}},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com"},"s3dash":{"endpoint":"{service}-{region}.amazonaws.com","signatureVersion":"s3"}}}

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
__webpack_require__(75);
__webpack_require__(76);
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
 *       and returns the amount of time to delay in milliseconds. The `base` option will be
 *       ignored if this option is supplied.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Defaults to the global
 *       agent (`http.globalAgent`) for non-SSL connections. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **timeout** [Integer] &mdash; The number of milliseconds to wait before
 *       giving up on a connection attempt. Defaults to two minutes (120000).
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a retry count
   *     and returns the amount of time to delay in milliseconds. The `base` option will be
   *     ignored if this option is supplied.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3 && AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var SequentialExecutor = __webpack_require__(78);
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
        req.response.error = AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      if (req.httpRequest.headers['Content-Length'] === undefined
          && authtype.indexOf('unsigned-body') === -1) {
        var length = AWS.util.string.byteLength(req.httpRequest.body);
        req.httpRequest.headers['Content-Length'] = length;
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = AWS.util.date.getDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.api.signingName || service.api.endpointPrefix,
            {
              signatureCache: service.config.signatureCache,
              operation: operation
            });
          signer.setServiceClientId(service._clientId);

          // clear old authorization headers
          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          // add new authorization
          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }

      var timeDiff = (AWS.util.date.getDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = new AWS.util.Buffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (resp.request.service.config.correctClockSkew
            && AWS.util.isClockSkewed(serverTime)) {
          AWS.util.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew
          && AWS.config.isClockSkewed) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      if (willRetry) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
        var message = 'Inaccessible host: `' + err.hostname +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;

      function buildMessage() {
        var time = AWS.util.date.getDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var params = __webpack_require__(202).inspect(req.params, true, null);

        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(26);
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(15);
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(47);
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(48);
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = __webpack_require__(45);
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(203);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(204);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(9)))

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),
/* 204 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var AWS = __webpack_require__(0);
var AcceptorStateMachine = __webpack_require__(206);
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = __webpack_require__(41);

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    // global endpoints sign as us-east-1
    if (service.isGlobalEndpoint) region = 'us-east-1';

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = AWS.util.date.getDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: new Buffer(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumberable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

module.exports = AcceptorStateMachine;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(41);

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;
var jmespath = __webpack_require__(41);

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

__webpack_require__(210);
__webpack_require__(79);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

module.exports = AWS.Signers.V2;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

__webpack_require__(79);

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

module.exports = AWS.Signers.V3Https;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var v4Credentials = __webpack_require__(80);
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && this.serviceName === 's3' && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

module.exports = AWS.Signers.V4;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

module.exports = AWS.Signers.S3;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp() + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  AWS.util.each(request.httpRequest.headers, function (key, value) {
    if (key === expiresHeader) key = 'Expires';
    if (key.indexOf('x-amz-meta-') === 0) {
      // Delete existing, potentially not normalized key
      delete queryParams[key];
      key = key.toLowerCase();
    }
    queryParams[key] = value;
  });
  delete request.httpRequest.headers[expiresHeader];

  var auth = queryParams['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['AWSAccessKeyId'] = auth[0];
    queryParams['Signature'] = auth[1];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }
  delete queryParams['Authorization'];
  delete queryParams['Host'];

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

module.exports = AWS.Signers.Presign;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    this.validateType(params, context, ['object'], 'structure');

    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']')
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});


/***/ }),
/* 216 */
/***/ (function(module, exports) {

module.exports = {"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory"},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild"},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM"},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay"},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService"},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena"},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2"},"glue":{"name":"Glue"}}

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(218);
var v4 = __webpack_require__(219);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var rng = __webpack_require__(81);
var bytesToUuid = __webpack_require__(82);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(81);
var bytesToUuid = __webpack_require__(82);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(43).Buffer
var sha = __webpack_require__(224)
var sha256 = __webpack_require__(225)
var rng = __webpack_require__(226)
var md5 = __webpack_require__(227)

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 222 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 223 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = __webpack_require__(44);

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = __webpack_require__(44);

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};


/***/ }),
/* 226 */
/***/ (function(module, exports) {

// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = __webpack_require__(44);

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(229);
var util = __webpack_require__(230);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(83);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module), __webpack_require__(7)))

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var STS = __webpack_require__(24);

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.masterCredentials.get(function() {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  }
});


/***/ }),
/* 235 */
/***/ (function(module, exports) {

module.exports = {"version":"2.0","metadata":{"apiVersion":"2011-06-15","endpointPrefix":"sts","globalEndpoint":"sts.amazonaws.com","protocol":"query","serviceAbbreviation":"AWS STS","serviceFullName":"AWS Security Token Service","signatureVersion":"v4","uid":"sts-2011-06-15","xmlNamespace":"https://sts.amazonaws.com/doc/2011-06-15/"},"operations":{"AssumeRole":{"input":{"type":"structure","required":["RoleArn","RoleSessionName"],"members":{"RoleArn":{},"RoleSessionName":{},"Policy":{},"DurationSeconds":{"type":"integer"},"ExternalId":{},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"AssumeRoleResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"}}}},"AssumeRoleWithSAML":{"input":{"type":"structure","required":["RoleArn","PrincipalArn","SAMLAssertion"],"members":{"RoleArn":{},"PrincipalArn":{},"SAMLAssertion":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithSAMLResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"},"Subject":{},"SubjectType":{},"Issuer":{},"Audience":{},"NameQualifier":{}}}},"AssumeRoleWithWebIdentity":{"input":{"type":"structure","required":["RoleArn","RoleSessionName","WebIdentityToken"],"members":{"RoleArn":{},"RoleSessionName":{},"WebIdentityToken":{},"ProviderId":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithWebIdentityResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"SubjectFromWebIdentityToken":{},"AssumedRoleUser":{"shape":"Sf"},"PackedPolicySize":{"type":"integer"},"Provider":{},"Audience":{}}}},"DecodeAuthorizationMessage":{"input":{"type":"structure","required":["EncodedMessage"],"members":{"EncodedMessage":{}}},"output":{"resultWrapper":"DecodeAuthorizationMessageResult","type":"structure","members":{"DecodedMessage":{}}}},"GetCallerIdentity":{"input":{"type":"structure","members":{}},"output":{"resultWrapper":"GetCallerIdentityResult","type":"structure","members":{"UserId":{},"Account":{},"Arn":{}}}},"GetFederationToken":{"input":{"type":"structure","required":["Name"],"members":{"Name":{},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"GetFederationTokenResult","type":"structure","members":{"Credentials":{"shape":"Sa"},"FederatedUser":{"type":"structure","required":["FederatedUserId","Arn"],"members":{"FederatedUserId":{},"Arn":{}}},"PackedPolicySize":{"type":"integer"}}}},"GetSessionToken":{"input":{"type":"structure","members":{"DurationSeconds":{"type":"integer"},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"GetSessionTokenResult","type":"structure","members":{"Credentials":{"shape":"Sa"}}}}},"shapes":{"Sa":{"type":"structure","required":["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],"members":{"AccessKeyId":{},"SecretAccessKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}},"Sf":{"type":"structure","required":["AssumedRoleId","Arn"],"members":{"AssumedRoleId":{},"Arn":{}}}}}

/***/ }),
/* 236 */
/***/ (function(module, exports) {

module.exports = {"pagination":{}}

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var STS = __webpack_require__(24);

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var CognitoIdentity = __webpack_require__(239);
var STS = __webpack_require__(24);

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(25);
var AWS = __webpack_require__(0);
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
__webpack_require__(240);
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = __webpack_require__(241);
    model.paginators = __webpack_require__(242).pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);

AWS.util.update(AWS.CognitoIdentity.prototype, {
  getOpenIdToken: function getOpenIdToken(params, callback) {
    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
  },

  getId: function getId(params, callback) {
    return this.makeUnauthenticatedRequest('getId', params, callback);
  },

  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
  }
});


/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports = {"version":"2.0","metadata":{"apiVersion":"2014-06-30","endpointPrefix":"cognito-identity","jsonVersion":"1.1","protocol":"json","serviceFullName":"Amazon Cognito Identity","signatureVersion":"v4","targetPrefix":"AWSCognitoIdentityService","uid":"cognito-identity-2014-06-30"},"operations":{"CreateIdentityPool":{"input":{"type":"structure","required":["IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S4"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S8"},"CognitoIdentityProviders":{"shape":"Sa"},"SamlProviderARNs":{"shape":"Sf"}}},"output":{"shape":"Sg"}},"DeleteIdentities":{"input":{"type":"structure","required":["IdentityIdsToDelete"],"members":{"IdentityIdsToDelete":{"type":"list","member":{}}}},"output":{"type":"structure","members":{"UnprocessedIdentityIds":{"type":"list","member":{"type":"structure","members":{"IdentityId":{},"ErrorCode":{}}}}}}},"DeleteIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}}},"DescribeIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{}}},"output":{"shape":"Sr"}},"DescribeIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"shape":"Sg"}},"GetCredentialsForIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"},"CustomRoleArn":{}}},"output":{"type":"structure","members":{"IdentityId":{},"Credentials":{"type":"structure","members":{"AccessKeyId":{},"SecretKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}}}}},"GetId":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"AccountId":{},"IdentityPoolId":{},"Logins":{"shape":"Sw"}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"GetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Roles":{"shape":"S18"},"RoleMappings":{"shape":"S1a"}}}},"GetOpenIdToken":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"GetOpenIdTokenForDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId","Logins"],"members":{"IdentityPoolId":{},"IdentityId":{},"Logins":{"shape":"Sw"},"TokenDuration":{"type":"long"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"ListIdentities":{"input":{"type":"structure","required":["IdentityPoolId","MaxResults"],"members":{"IdentityPoolId":{},"MaxResults":{"type":"integer"},"NextToken":{},"HideDisabled":{"type":"boolean"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Identities":{"type":"list","member":{"shape":"Sr"}},"NextToken":{}}}},"ListIdentityPools":{"input":{"type":"structure","required":["MaxResults"],"members":{"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityPools":{"type":"list","member":{"type":"structure","members":{"IdentityPoolId":{},"IdentityPoolName":{}}}},"NextToken":{}}}},"LookupDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{},"IdentityId":{},"DeveloperUserIdentifier":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityId":{},"DeveloperUserIdentifierList":{"type":"list","member":{}},"NextToken":{}}}},"MergeDeveloperIdentities":{"input":{"type":"structure","required":["SourceUserIdentifier","DestinationUserIdentifier","DeveloperProviderName","IdentityPoolId"],"members":{"SourceUserIdentifier":{},"DestinationUserIdentifier":{},"DeveloperProviderName":{},"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"SetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId","Roles"],"members":{"IdentityPoolId":{},"Roles":{"shape":"S18"},"RoleMappings":{"shape":"S1a"}}}},"UnlinkDeveloperIdentity":{"input":{"type":"structure","required":["IdentityId","IdentityPoolId","DeveloperProviderName","DeveloperUserIdentifier"],"members":{"IdentityId":{},"IdentityPoolId":{},"DeveloperProviderName":{},"DeveloperUserIdentifier":{}}}},"UnlinkIdentity":{"input":{"type":"structure","required":["IdentityId","Logins","LoginsToRemove"],"members":{"IdentityId":{},"Logins":{"shape":"Sw"},"LoginsToRemove":{"shape":"Ss"}}}},"UpdateIdentityPool":{"input":{"shape":"Sg"},"output":{"shape":"Sg"}}},"shapes":{"S4":{"type":"map","key":{},"value":{}},"S8":{"type":"list","member":{}},"Sa":{"type":"list","member":{"type":"structure","members":{"ProviderName":{},"ClientId":{},"ServerSideTokenCheck":{"type":"boolean"}}}},"Sf":{"type":"list","member":{}},"Sg":{"type":"structure","required":["IdentityPoolId","IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolId":{},"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S4"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S8"},"CognitoIdentityProviders":{"shape":"Sa"},"SamlProviderARNs":{"shape":"Sf"}}},"Sr":{"type":"structure","members":{"IdentityId":{},"Logins":{"shape":"Ss"},"CreationDate":{"type":"timestamp"},"LastModifiedDate":{"type":"timestamp"}}},"Ss":{"type":"list","member":{}},"Sw":{"type":"map","key":{},"value":{}},"S18":{"type":"map","key":{},"value":{}},"S1a":{"type":"map","key":{},"value":{"type":"structure","required":["Type"],"members":{"Type":{},"AmbiguousRoleResolution":{},"RulesConfiguration":{"type":"structure","required":["Rules"],"members":{"Rules":{"type":"list","member":{"type":"structure","required":["Claim","MatchType","Value","RoleARN"],"members":{"Claim":{},"MatchType":{},"Value":{},"RoleARN":{}}}}}}}}}}}

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = {"pagination":{}}

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var STS = __webpack_require__(24);

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    var self = this;
    self.createClients();
    if (!callback) callback = function(err) { if (err) throw err; };

    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(1);
var Shape = __webpack_require__(10);

function DomXmlParser() { }

DomXmlParser.prototype.parse = function(xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {};

  var result, error;
  try {
    if (window.DOMParser) {
      try {
        var parser = new DOMParser();
        result = parser.parseFromString(xml, 'text/xml');
      } catch (syntaxError) {
        throw util.error(new Error('Parse error in document'),
          {
            originalError: syntaxError,
            code: 'XMLParserError',
            retryable: true
          });
      }

      if (result.documentElement === null) {
        throw util.error(new Error('Cannot parse empty document.'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }

      var isError = result.getElementsByTagName('parsererror')[0];
      if (isError && (isError.parentNode === result ||
          isError.parentNode.nodeName === 'body' ||
          isError.parentNode.parentNode === result ||
          isError.parentNode.parentNode.nodeName === 'body')) {
        var errorElement = isError.getElementsByTagName('div')[0] || isError;
        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else if (window.ActiveXObject) {
      result = new window.ActiveXObject('Microsoft.XMLDOM');
      result.async = false;

      if (!result.loadXML(xml)) {
        throw util.error(new Error('Parse error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else {
      throw new Error('Cannot load XML parser');
    }
  } catch (e) {
    error = e;
  }

  if (result && result.documentElement && !error) {
    var data = parseXml(result.documentElement, shape);
    var metadata = result.getElementsByTagName('ResponseMetadata')[0];
    if (metadata) {
      data.ResponseMetadata = parseXml(metadata, {});
    }
    return data;
  } else if (error) {
    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return {};
  }
};

function parseXml(xml, shape) {
  if (!shape) shape = {};
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value;
        data[memberName] = parseXml({textContent: value}, memberShape);
      }
    } else {
      var xmlChild = memberShape.flattened ? xml :
        xml.getElementsByTagName(memberShape.name)[0];
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape);
      } else if (!memberShape.flattened && memberShape.type === 'list') {
        data[memberName] = memberShape.defaultValue;
      }
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var tagName = shape.flattened ? shape.name : 'entry';

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      var key = child.getElementsByTagName(xmlKey)[0].textContent;
      var value = child.getElementsByTagName(xmlValue)[0];
      data[key] = parseXml(value, shape.value);
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseList(xml, shape) {
  var data = [];
  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member));
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding');
    if (encoding === 'base64') {
      shape = new Shape.create({type: encoding});
    }
  }

  var text = xml.textContent;
  if (text === '') text = null;
  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';

  // empty object
  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {};
    if (xml.childNodes.length === 0) return '';
    else return xml.textContent;
  }

  // object, parse as structure
  var shape = {type: 'structure', members: {}};
  var child = xml.firstElementChild;
  while (child) {
    var tag = child.nodeName;
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      // multiple tags of the same name makes it a list
      shape.members[tag].type = 'list';
    } else {
      shape.members[tag] = {name: tag};
    }
    child = child.nextElementSibling;
  }
  return parseStructure(xml, shape);
}

module.exports = DomXmlParser;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var EventEmitter = __webpack_require__(246).EventEmitter;
__webpack_require__(77);

/**
 * @api private
 */
AWS.XHRClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var emitter = new EventEmitter();
    var href = endpoint.protocol + '//' + endpoint.hostname;
    if (endpoint.port !== 80 && endpoint.port !== 443) {
      href += ':' + endpoint.port;
    }
    href += httpRequest.path;

    var xhr = new XMLHttpRequest(), headersEmitted = false;
    httpRequest.stream = xhr;

    xhr.addEventListener('readystatechange', function() {
      try {
        if (xhr.status === 0) return; // 0 code is invalid
      } catch (e) { return; }

      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
        emitter.statusCode = xhr.status;
        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
        emitter.emit(
          'headers',
          emitter.statusCode,
          emitter.headers,
          xhr.statusText
        );
        headersEmitted = true;
      }
      if (this.readyState === this.DONE) {
        self.finishRequest(xhr, emitter);
      }
    }, false);
    xhr.upload.addEventListener('progress', function (evt) {
      emitter.emit('sendProgress', evt);
    });
    xhr.addEventListener('progress', function (evt) {
      emitter.emit('receiveProgress', evt);
    }, false);
    xhr.addEventListener('timeout', function () {
      errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));
    }, false);
    xhr.addEventListener('error', function () {
      errCallback(AWS.util.error(new Error('Network Failure'), {
        code: 'NetworkingError'
      }));
    }, false);
    xhr.addEventListener('abort', function () {
      errCallback(AWS.util.error(new Error('Request aborted'), {
        code: 'RequestAbortedError'
      }));
    }, false);

    callback(emitter);
    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
    AWS.util.each(httpRequest.headers, function (key, value) {
      if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
        xhr.setRequestHeader(key, value);
      }
    });

    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
      xhr.timeout = httpOptions.timeout;
    }

    if (httpOptions.xhrWithCredentials) {
      xhr.withCredentials = true;
    }
    try { xhr.responseType = 'arraybuffer'; } catch (e) {}

    try {
      if (httpRequest.body) {
        xhr.send(httpRequest.body);
      } else {
        xhr.send();
      }
    } catch (err) {
      if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
      } else {
        throw err;
      }
    }

    return emitter;
  },

  parseHeaders: function parseHeaders(rawHeaders) {
    var headers = {};
    AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
      var key = line.split(':', 1)[0];
      var value = line.substring(key.length + 2);
      if (key.length > 0) headers[key.toLowerCase()] = value;
    });
    return headers;
  },

  finishRequest: function finishRequest(xhr, emitter) {
    var buffer;
    if (xhr.responseType === 'arraybuffer' && xhr.response) {
      var ab = xhr.response;
      buffer = new AWS.util.Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
    }

    try {
      if (!buffer && typeof xhr.responseText === 'string') {
        buffer = new AWS.util.Buffer(xhr.responseText);
      }
    } catch (e) {}

    if (buffer) emitter.emit('data', buffer);
    emitter.emit('end');
  }
});

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.XHRClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = 1;


/***/ }),
/* 246 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var v4Credentials = __webpack_require__(80);

// Pull in managed upload extension
__webpack_require__(248);

/**
 * @api private
 */
var operationsWith200StatusCodeError = {
  'completeMultipartUpload': true,
  'copyObject': true,
  'uploadPartCopy': true
};

/**
 * @api private
 */
 var regionRedirectErrorCodes = [
  'AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
  'BadRequest', // head operations on virtual-hosted global bucket endpoints
  'PermanentRedirect', // non-head operations on path-style or regional endpoints
  301 // head operations on path-style or regional endpoints
 ];

AWS.util.update(AWS.S3.prototype, {
  /**
   * @api private
   */
  getSignatureVersion: function getSignatureVersion(request) {
    var defaultApiVersion = this.api.signatureVersion;
    var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
    var regionDefinedVersion = this.config.signatureVersion;
    var isPresigned = request ? request.isPresigned() : false;
    /*
      1) User defined version specified:
        a) always return user defined version
      2) No user defined version specified:
        a) default to lowest version the region supports
        b) If using presigned urls, default to lowest version the region supports
    */
    if (userDefinedVersion) {
      userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
      return userDefinedVersion;
    }
    if (isPresigned !== true) {
      defaultApiVersion = 'v4';
    } else if (regionDefinedVersion) {
      defaultApiVersion = regionDefinedVersion;
    }
    return defaultApiVersion;
  },

  /**
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var signatureVersion = this.getSignatureVersion(request);
    return AWS.Signers.RequestSigner.getVersion(signatureVersion);
  },

  /**
   * @api private
   */
  validateService: function validateService() {
    var msg;
    var messages = [];

    // default to us-east-1 when no region is provided
    if (!this.config.region) this.config.region = 'us-east-1';

    if (!this.config.endpoint && this.config.s3BucketEndpoint) {
      messages.push('An endpoint must be provided when configuring ' +
                    '`s3BucketEndpoint` to true.');
    }
    if (messages.length === 1) {
      msg = messages[0];
    } else if (messages.length > 1) {
      msg = 'Multiple configuration errors:\n' + messages.join('\n');
    }
    if (msg) {
      throw AWS.util.error(new Error(),
        {name: 'InvalidEndpoint', message: msg});
    }
  },

  /**
   * @api private
   */
  shouldDisableBodySigning: function shouldDisableBodySigning(request) {
    var signerClass = this.getSignerClass();
    if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4
        && request.httpRequest.endpoint.protocol === 'https:') {
      return true;
    }
    return false;
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.validateScheme);
    request.addListener('validate', this.validateBucketEndpoint);
    request.addListener('validate', this.correctBucketRegionFromCache);
    request.addListener('validate', this.validateBucketName);
    request.addListener('build', this.addContentType);
    request.addListener('build', this.populateURI);
    request.addListener('build', this.computeContentMd5);
    request.addListener('build', this.computeSseCustomerKeyMd5);
    request.addListener('afterBuild', this.addExpect100Continue);
    request.removeListener('validate',
      AWS.EventListeners.Core.VALIDATE_REGION);
    request.addListener('extractError', this.extractError);
    request.onAsync('extractError', this.requestBucketRegion);
    request.addListener('extractData', this.extractData);
    request.addListener('extractData', AWS.util.hoistPayloadMember);
    request.addListener('beforePresign', this.prepareSignedUrl);
    if (AWS.util.isBrowser()) {
      request.onAsync('retry', this.reqRegionForNetworkingError);
    }
    if (this.shouldDisableBodySigning(request))  {
      request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
      request.addListener('afterBuild', this.disableBodySigning);
    }
  },

  /**
   * @api private
   */
  validateScheme: function(req) {
    var params = req.params,
        scheme = req.httpRequest.endpoint.protocol,
        sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
    if (sensitive && scheme !== 'https:') {
      var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' +
        'to \'true\' in your configuration';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  validateBucketEndpoint: function(req) {
    if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
      var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  validateBucketName: function validateBucketName(req) {
    var service = req.service;
    var signatureVersion = service.getSignatureVersion(req);
    // Only validate buckets when using sigv4
    if (signatureVersion !== 'v4') {
      return;
    }
    var bucket = req.params && req.params.Bucket;
    var key = req.params && req.params.Key;
    var slashIndex = bucket && bucket.indexOf('/');
    if (bucket && slashIndex >= 0) {
      if (typeof key === 'string') {
        req.params = AWS.util.copy(req.params);
        // Need to include trailing slash to match sigv2 behavior
        var prefix = bucket.substr(slashIndex + 1) || '';
        req.params.Key = prefix + '/' + key;
        req.params.Bucket = bucket.substr(0, slashIndex);
      } else {
        var msg = 'Bucket names cannot contain forward slashes. Bucket: ' + bucket;
        throw AWS.util.error(new Error(),
          { code: 'InvalidBucket', message: msg });
      }
    }
  },

  /**
   * @api private
   */
  isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
    var invalidOperations = [
      'createBucket',
      'deleteBucket',
      'listBuckets'
    ];
    return invalidOperations.indexOf(operation) === -1;
  },


  /**
   * S3 prefers dns-compatible bucket names to be moved from the uri path
   * to the hostname as a sub-domain.  This is not possible, even for dns-compat
   * buckets when using SSL and the bucket name contains a dot ('.').  The
   * ssl wildcard certificate is only 1-level deep.
   *
   * @api private
   */
  populateURI: function populateURI(req) {
    var httpRequest = req.httpRequest;
    var b = req.params.Bucket;
    var service = req.service;
    var endpoint = httpRequest.endpoint;
    if (b) {
      if (!service.pathStyleBucketName(b)) {
        if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
          if (service.config.useDualstack) {
            endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
          } else {
            endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
          }
        } else if (!service.config.s3BucketEndpoint) {
          endpoint.hostname =
            b + '.' + endpoint.hostname;
        }

        var port = endpoint.port;
        if (port !== 80 && port !== 443) {
          endpoint.host = endpoint.hostname + ':' +
            endpoint.port;
        } else {
          endpoint.host = endpoint.hostname;
        }

        httpRequest.virtualHostedBucket = b; // needed for signing the request
        service.removeVirtualHostedBucketFromPath(req);
      }
    }
  },

  /**
   * Takes the bucket name out of the path if bucket is virtual-hosted
   *
   * @api private
   */
  removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
    var httpRequest = req.httpRequest;
    var bucket = httpRequest.virtualHostedBucket;
    if (bucket && httpRequest.path) {
      httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');
      if (httpRequest.path[0] !== '/') {
        httpRequest.path = '/' + httpRequest.path;
      }
    }
  },

  /**
   * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
   * @api private
   */
  addExpect100Continue: function addExpect100Continue(req) {
    var len = req.httpRequest.headers['Content-Length'];
    if (AWS.util.isNode() && len >= 1024 * 1024) {
      req.httpRequest.headers['Expect'] = '100-continue';
    }
  },

  /**
   * Adds a default content type if none is supplied.
   *
   * @api private
   */
  addContentType: function addContentType(req) {
    var httpRequest = req.httpRequest;
    if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
      // Content-Type is not set in GET/HEAD requests
      delete httpRequest.headers['Content-Type'];
      return;
    }

    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type
      httpRequest.headers['Content-Type'] = 'application/octet-stream';
    }

    var contentType = httpRequest.headers['Content-Type'];
    if (AWS.util.isBrowser()) {
      if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
        var charset = '; charset=UTF-8';
        httpRequest.headers['Content-Type'] += charset;
      } else {
        var replaceFn = function(_, prefix, charsetName) {
          return prefix + charsetName.toUpperCase();
        };

        httpRequest.headers['Content-Type'] =
          contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
      }
    }
  },

  /**
   * @api private
   */
  computableChecksumOperations: {
    putBucketCors: true,
    putBucketLifecycle: true,
    putBucketLifecycleConfiguration: true,
    putBucketTagging: true,
    deleteObjects: true,
    putBucketReplication: true
  },

  /**
   * Checks whether checksums should be computed for the request.
   * If the request requires checksums to be computed, this will always
   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}
   * is set.
   *
   * @param req [AWS.Request] the request to check against
   * @return [Boolean] whether to compute checksums for a request.
   * @api private
   */
  willComputeChecksums: function willComputeChecksums(req) {
    if (this.computableChecksumOperations[req.operation]) return true;
    if (!this.config.computeChecksums) return false;

    // TODO: compute checksums for Stream objects
    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) &&
        typeof req.httpRequest.body !== 'string') {
      return false;
    }

    var rules = req.service.api.operations[req.operation].input.members;

    // Sha256 signing disabled, and not a presigned url
    if (req.service.shouldDisableBodySigning(req) && !Object.prototype.hasOwnProperty.call(req.httpRequest.headers, 'presigned-expires')) {
      if (rules.ContentMD5 && !req.params.ContentMD5) {
        return true;
      }
    }

    // V4 signer uses SHA256 signatures so only compute MD5 if it is required
    if (req.service.getSignerClass(req) === AWS.Signers.V4) {
      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;
    }

    if (rules.ContentMD5 && !req.params.ContentMD5) return true;
  },

  /**
   * A listener that computes the Content-MD5 and sets it in the header.
   * @see AWS.S3.willComputeChecksums
   * @api private
   */
  computeContentMd5: function computeContentMd5(req) {
    if (req.service.willComputeChecksums(req)) {
      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
      req.httpRequest.headers['Content-MD5'] = md5;
    }
  },

  /**
   * @api private
   */
  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
    var keys = {
      SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
      CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
    };
    AWS.util.each(keys, function(key, header) {
      if (req.params[key]) {
        var value = AWS.util.crypto.md5(req.params[key], 'base64');
        req.httpRequest.headers[header] = value;
      }
    });
  },

  /**
   * Returns true if the bucket name should be left in the URI path for
   * a request to S3.  This function takes into account the current
   * endpoint protocol (e.g. http or https).
   *
   * @api private
   */
  pathStyleBucketName: function pathStyleBucketName(bucketName) {
    // user can force path style requests via the configuration
    if (this.config.s3ForcePathStyle) return true;
    if (this.config.s3BucketEndpoint) return false;

    if (this.dnsCompatibleBucketName(bucketName)) {
      return (this.config.sslEnabled && bucketName.match(/\./)) ? true : false;
    } else {
      return true; // not dns compatible names must always use path style
    }
  },

  /**
   * Returns true if the bucket name is DNS compatible.  Buckets created
   * outside of the classic region MUST be DNS compatible.
   *
   * @api private
   */
  dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
    var b = bucketName;
    var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
    var ipAddress = new RegExp(/(\d+\.){3}\d+/);
    var dots = new RegExp(/\.\./);
    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;
  },

  /**
   * @return [Boolean] whether response contains an error
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    var req = resp.request;
    var httpResponse = resp.httpResponse;
    if (operationsWith200StatusCodeError[req.operation] &&
        httpResponse.body.toString().match('<Error>')) {
      return false;
    } else {
      return httpResponse.statusCode < 300;
    }
  },

  /**
   * @return [Boolean] whether the error can be retried
   * @api private
   */
  retryableError: function retryableError(error, request) {
    if (operationsWith200StatusCodeError[request.operation] &&
        error.statusCode === 200) {
      return true;
    } else if (request._requestRegionForBucket &&
        request.service.bucketRegionCache[request._requestRegionForBucket]) {
      return false;
    } else if (error && error.code === 'RequestTimeout') {
      return true;
    } else if (error &&
        regionRedirectErrorCodes.indexOf(error.code) != -1 &&
        error.region && error.region != request.httpRequest.region) {
      request.httpRequest.region = error.region;
      if (error.statusCode === 301) {
        request.service.updateReqBucketRegion(request);
      }
      return true;
    } else {
      var _super = AWS.Service.prototype.retryableError;
      return _super.call(this, error, request);
    }
  },

  /**
   * Updates httpRequest with region. If region is not provided, then
   * the httpRequest will be updated based on httpRequest.region
   *
   * @api private
   */
  updateReqBucketRegion: function updateReqBucketRegion(request, region) {
    var httpRequest = request.httpRequest;
    if (typeof region === 'string' && region.length) {
      httpRequest.region = region;
    }
    if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
      return;
    }
    var service = request.service;
    var s3Config = service.config;
    var s3BucketEndpoint = s3Config.s3BucketEndpoint;
    if (s3BucketEndpoint) {
      delete s3Config.s3BucketEndpoint;
    }
    var newConfig = AWS.util.copy(s3Config);
    delete newConfig.endpoint;
    newConfig.region = httpRequest.region;

    httpRequest.endpoint = (new AWS.S3(newConfig)).endpoint;
    service.populateURI(request);
    s3Config.s3BucketEndpoint = s3BucketEndpoint;
    httpRequest.headers.Host = httpRequest.endpoint.host;

    if (request._asm.currentState === 'validate') {
      request.removeListener('build', service.populateURI);
      request.addListener('build', service.removeVirtualHostedBucketFromPath);
    }
  },

  /**
   * Provides a specialized parser for getBucketLocation -- all other
   * operations are parsed by the super class.
   *
   * @api private
   */
  extractData: function extractData(resp) {
    var req = resp.request;
    if (req.operation === 'getBucketLocation') {
      var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
      delete resp.data['_'];
      if (match) {
        resp.data.LocationConstraint = match[1];
      } else {
        resp.data.LocationConstraint = '';
      }
    }
    var bucket = req.params.Bucket || null;
    if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
      req.service.clearBucketRegionCache(bucket);
    } else {
      var headers = resp.httpResponse.headers || {};
      var region = headers['x-amz-bucket-region'] || null;
      if (!region && req.operation === 'createBucket' && !resp.error) {
        var createBucketConfiguration = req.params.CreateBucketConfiguration;
        if (!createBucketConfiguration) {
          region = 'us-east-1';
        } else if (createBucketConfiguration.LocationConstraint === 'EU') {
          region = 'eu-west-1';
        } else {
          region = createBucketConfiguration.LocationConstraint;
        }
      }
      if (region) {
          if (bucket && region !== req.service.bucketRegionCache[bucket]) {
            req.service.bucketRegionCache[bucket] = region;
          }
      }
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * Extracts an error object from the http response.
   *
   * @api private
   */
  extractError: function extractError(resp) {
    var codes = {
      304: 'NotModified',
      403: 'Forbidden',
      400: 'BadRequest',
      404: 'NotFound'
    };

    var req = resp.request;
    var code = resp.httpResponse.statusCode;
    var body = resp.httpResponse.body || '';

    var headers = resp.httpResponse.headers || {};
    var region = headers['x-amz-bucket-region'] || null;
    var bucket = req.params.Bucket || null;
    var bucketRegionCache = req.service.bucketRegionCache;
    if (region && bucket && region !== bucketRegionCache[bucket]) {
      bucketRegionCache[bucket] = region;
    }

    var cachedRegion;
    if (codes[code] && body.length === 0) {
      if (bucket && !region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }
      resp.error = AWS.util.error(new Error(), {
        code: codes[code],
        message: null,
        region: region
      });
    } else {
      var data = new AWS.XML.Parser().parse(body.toString());

      if (data.Region && !region) {
        region = data.Region;
        if (bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
      } else if (bucket && !region && !data.Region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }

      resp.error = AWS.util.error(new Error(), {
        code: data.Code || code,
        message: data.Message || null,
        region: region
      });
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * If region was not obtained synchronously, then send async request
   * to get bucket region for errors resulting from wrong region.
   *
   * @api private
   */
  requestBucketRegion: function requestBucketRegion(resp, done) {
    var error = resp.error;
    var req = resp.request;
    var bucket = req.params.Bucket || null;

    if (!error || !bucket || error.region || req.operation === 'listObjects' ||
        (AWS.util.isNode() && req.operation === 'headBucket') ||
        (error.statusCode === 400 && req.operation !== 'headObject') ||
        regionRedirectErrorCodes.indexOf(error.code) === -1) {
      return done();
    }
    var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
    var reqParams = {Bucket: bucket};
    if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
    var regionReq = req.service[reqOperation](reqParams);
    regionReq._requestRegionForBucket = bucket;
    regionReq.send(function() {
      var region = req.service.bucketRegionCache[bucket] || null;
      error.region = region;
      done();
    });
  },

   /**
   * For browser only. If NetworkingError received, will attempt to obtain
   * the bucket region.
   *
   * @api private
   */
   reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
    if (!AWS.util.isBrowser()) {
      return done();
    }
    var error = resp.error;
    var request = resp.request;
    var bucket = request.params.Bucket;
    if (!error || error.code !== 'NetworkingError' || !bucket ||
        request.httpRequest.region === 'us-east-1') {
      return done();
    }
    var service = request.service;
    var bucketRegionCache = service.bucketRegionCache;
    var cachedRegion = bucketRegionCache[bucket] || null;

    if (cachedRegion && cachedRegion !== request.httpRequest.region) {
      service.updateReqBucketRegion(request, cachedRegion);
      done();
    } else if (!service.dnsCompatibleBucketName(bucket)) {
      service.updateReqBucketRegion(request, 'us-east-1');
      if (bucketRegionCache[bucket] !== 'us-east-1') {
        bucketRegionCache[bucket] = 'us-east-1';
      }
      done();
    } else if (request.httpRequest.virtualHostedBucket) {
      var getRegionReq = service.listObjects({Bucket: bucket, MaxKeys: 0});
      service.updateReqBucketRegion(getRegionReq, 'us-east-1');
      getRegionReq._requestRegionForBucket = bucket;

      getRegionReq.send(function() {
        var region = service.bucketRegionCache[bucket] || null;
        if (region && region !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, region);
        }
        done();
      });
    } else {
      // DNS-compatible path-style
      // (s3ForcePathStyle or bucket name with dot over https)
      // Cannot obtain region information for this case
      done();
    }
   },

  /**
   * Cache for bucket region.
   *
   * @api private
   */
   bucketRegionCache: {},

  /**
   * Clears bucket region cache.
   *
   * @api private
   */
   clearBucketRegionCache: function(buckets) {
    var bucketRegionCache = this.bucketRegionCache;
    if (!buckets) {
      buckets = Object.keys(bucketRegionCache);
    } else if (typeof buckets === 'string') {
      buckets = [buckets];
    }
    for (var i = 0; i < buckets.length; i++) {
      delete bucketRegionCache[buckets[i]];
    }
    return bucketRegionCache;
   },

   /**
    * Corrects request region if bucket's cached region is different
    *
    * @api private
    */
  correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
    var bucket = req.params.Bucket || null;
    if (bucket) {
      var service = req.service;
      var requestRegion = req.httpRequest.region;
      var cachedRegion = service.bucketRegionCache[bucket];
      if (cachedRegion && cachedRegion !== requestRegion) {
        service.updateReqBucketRegion(req, cachedRegion);
      }
    }
  },

  /**
   * Extracts S3 specific request ids from the http response.
   *
   * @api private
   */
  extractRequestIds: function extractRequestIds(resp) {
    var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
    var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
    resp.extendedRequestId = extendedRequestId;
    resp.cfId = cfId;

    if (resp.error) {
      resp.error.requestId = resp.requestId || null;
      resp.error.extendedRequestId = extendedRequestId;
      resp.error.cfId = cfId;
    }
  },

  /**
   * Get a pre-signed URL for a given operation name.
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   * @note Not all operation parameters are supported when using pre-signed
   *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *   `ContentLength`, or `Tagging` must be provided as headers when sending a
   *   request. If you are using pre-signed URLs to upload from a browser and
   *   need to use these fields, see {createPresignedPost}.
   * @param operation [String] the name of the operation to call
   * @param params [map] parameters to pass to the operation. See the given
   *   operation for the expected operation parameters. In addition, you can
   *   also pass the "Expires" parameter to inform S3 how long the URL should
   *   work for.
   * @option params Expires [Integer] (900) the number of seconds to expire
   *   the pre-signed URL operation in. Defaults to 15 minutes.
   * @param callback [Function] if a callback is provided, this function will
   *   pass the URL as the second parameter (after the error parameter) to
   *   the callback function.
   * @return [String] if called synchronously (with no callback), returns the
   *   signed URL.
   * @return [null] nothing is returned if a callback is provided.
   * @example Pre-signing a getObject operation (synchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url);
   * @example Pre-signing a putObject (asynchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   s3.getSignedUrl('putObject', params, function (err, url) {
   *     console.log('The URL is', url);
   *   });
   * @example Pre-signing a putObject operation with a specific payload
   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *   var url = s3.getSignedUrl('putObject', params);
   *   console.log('The URL is', url);
   * @example Passing in a 1-minute expiry time for a pre-signed URL
   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url); // expires in 60 seconds
   */
  getSignedUrl: function getSignedUrl(operation, params, callback) {
    params = AWS.util.copy(params || {});
    var expires = params.Expires || 900;
    delete params.Expires; // we can't validate this
    var request = this.makeRequest(operation, params);

    if (callback) {
      AWS.util.defer(function() {
        request.presign(expires, callback);
      });
    } else {
      return request.presign(expires, callback);
    }
  },


  /**
   * Get a pre-signed POST policy to support uploading to S3 directly from an
   * HTML form.
   *
   * @param params [map]
   * @option params Bucket [String]     The bucket to which the post should be
   *                                    uploaded
   * @option params Expires [Integer]   (3600) The number of seconds for which
   *                                    the presigned policy should be valid.
   * @option params Conditions [Array]  An array of conditions that must be met
   *                                    for the presigned policy to allow the
   *                                    upload. This can include required tags,
   *                                    the accepted range for content lengths,
   *                                    etc.
   * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
   * @option params Fields [map]        Fields to include in the form. All
   *                                    values passed in as fields will be
   *                                    signed as exact match conditions.
   * @param callback [Function]
   *
   * @note All fields passed in when creating presigned post data will be signed
   *   as exact match conditions. Any fields that will be interpolated by S3
   *   must be added to the fields hash after signing, and an appropriate
   *   condition for such fields must be explicitly added to the Conditions
   *   array passed to this function before signing.
   *
   * @example Presiging post data with a known key
   *   var params = {
   *     Bucket: 'bucket',
   *     Fields: {
   *       key: 'key'
   *     }
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @example Presigning post data with an interpolated key
   *   var params = {
   *     Bucket: 'bucket',
   *     Conditions: [
   *       ['starts-with', '$key', 'path/to/uploads/']
   *     ]
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       data.Fields.key = 'path/to/uploads/${filename}';
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   *
   * @return [map]  If called synchronously (with no callback), returns a hash
   *                with the url to set as the form action and a hash of fields
   *                to include in the form.
   * @return [null] Nothing is returned if a callback is provided.
   *
   * @callback callback function (err, data)
   *  @param err [Error] the error object returned from the policy signer
   *  @param data [map] The data necessary to construct an HTML form
   *  @param data.url [String] The URL to use as the action of the form
   *  @param data.fields [map] A hash of fields that must be included in the
   *                           form for the upload to succeed. This hash will
   *                           include the signed POST policy, your access key
   *                           ID and security token (if present), etc. These
   *                           may be safely included as input elements of type
   *                           'hidden.'
   */
  createPresignedPost: function createPresignedPost(params, callback) {
    if (typeof params === 'function' && callback === undefined) {
      callback = params;
      params = null;
    }

    params = AWS.util.copy(params || {});
    var boundParams = this.config.params || {};
    var bucket = params.Bucket || boundParams.Bucket,
      self = this,
      config = this.config,
      endpoint = AWS.util.copy(this.endpoint);
    if (!config.s3BucketEndpoint) {
      endpoint.pathname = '/' + bucket;
    }

    function finalizePost() {
      return {
        url: AWS.util.urlFormat(endpoint),
        fields: self.preparePostFields(
          config.credentials,
          config.region,
          bucket,
          params.Fields,
          params.Conditions,
          params.Expires
        )
      };
    }

    if (callback) {
      config.getCredentials(function (err) {
        if (err) {
          callback(err);
        }

        callback(null, finalizePost());
      });
    } else {
      return finalizePost();
    }
  },

  /**
   * @api private
   */
  preparePostFields: function preparePostFields(
    credentials,
    region,
    bucket,
    fields,
    conditions,
    expiresInSeconds
  ) {
    var now = AWS.util.date.getDate();
    if (!credentials || !region || !bucket) {
      throw new Error('Unable to create a POST object policy without a bucket,'
        + ' region, and credentials');
    }
    fields = AWS.util.copy(fields || {});
    conditions = (conditions || []).slice(0);
    expiresInSeconds = expiresInSeconds || 3600;

    var signingDate = AWS.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, '');
    var shortDate = signingDate.substr(0, 8);
    var scope = v4Credentials.createScope(shortDate, region, 's3');
    var credential = credentials.accessKeyId + '/' + scope;

    fields['bucket'] = bucket;
    fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    fields['X-Amz-Credential'] = credential;
    fields['X-Amz-Date'] = signingDate;
    if (credentials.sessionToken) {
      fields['X-Amz-Security-Token'] = credentials.sessionToken;
    }
    for (var field in fields) {
      if (fields.hasOwnProperty(field)) {
        var condition = {};
        condition[field] = fields[field];
        conditions.push(condition);
      }
    }

    fields.Policy = this.preparePostPolicy(
      new Date(now.valueOf() + expiresInSeconds * 1000),
      conditions
    );
    fields['X-Amz-Signature'] = AWS.util.crypto.hmac(
      v4Credentials.getSigningKey(credentials, shortDate, region, 's3', true),
      fields.Policy,
      'hex'
    );

    return fields;
  },

  /**
   * @api private
   */
  preparePostPolicy: function preparePostPolicy(expiration, conditions) {
    return AWS.util.base64.encode(JSON.stringify({
      expiration: AWS.util.date.iso8601(expiration),
      conditions: conditions
    }));
  },

  /**
   * @api private
   */
  prepareSignedUrl: function prepareSignedUrl(request) {
    request.addListener('validate', request.service.noPresignedContentLength);
    request.removeListener('build', request.service.addContentType);
    if (!request.params.Body) {
      // no Content-MD5/SHA-256 if body is not provided
      request.removeListener('build', request.service.computeContentMd5);
    } else {
      request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
    }
  },

  /**
   * @api private
   * @param request
   */
  disableBodySigning: function disableBodySigning(request) {
    var headers = request.httpRequest.headers;
    // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined
    if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
      headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
    }
  },

  /**
   * @api private
   */
  noPresignedContentLength: function noPresignedContentLength(request) {
    if (request.params.ContentLength !== undefined) {
      throw AWS.util.error(new Error(), {code: 'UnexpectedParameter',
        message: 'ContentLength is not supported in pre-signed URLs.'});
    }
  },

  createBucket: function createBucket(params, callback) {
    // When creating a bucket *outside* the classic region, the location
    // constraint must be set for the bucket and it must match the endpoint.
    // This chunk of code will set the location constraint param based
    // on the region (when possible), but it will not override a passed-in
    // location constraint.
    if (typeof params === 'function' || !params) {
      callback = callback || params;
      params = {};
    }
    var hostname = this.endpoint.hostname;
    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
      params.CreateBucketConfiguration = { LocationConstraint: this.config.region };
    }
    return this.makeRequest('createBucket', params, callback);
  },

  /**
   * @see AWS.S3.ManagedUpload
   * @overload upload(params = {}, [options], [callback])
   *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
   *   concurrent handling of parts if the payload is large enough. You can
   *   configure the concurrent queue size by setting `options`. Note that this
   *   is the only operation for which the SDK can retry requests with stream
   *   bodies.
   *
   *   @param (see AWS.S3.putObject)
   *   @option (see AWS.S3.ManagedUpload.constructor)
   *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
   *     `send()` or track progress.
   *   @example Uploading a stream object
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     s3.upload(params, function(err, data) {
   *       console.log(err, data);
   *     });
   *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
   *     s3.upload(params, options, function(err, data) {
   *       console.log(err, data);
   *     });
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *   @param data.Location [String] the URL of the uploaded object
   *   @param data.ETag [String] the ETag of the uploaded object
   *   @param data.Bucket [String]  the bucket to which the object was uploaded
   *   @param data.Key [String] the key to which the object was uploaded
   */
  upload: function upload(params, options, callback) {
    if (typeof options === 'function' && callback === undefined) {
      callback = options;
      options = null;
    }

    options = options || {};
    options = AWS.util.merge(options || {}, {service: this, params: params});

    var uploader = new AWS.S3.ManagedUpload(options);
    if (typeof callback === 'function') uploader.send(callback);
    return uploader;
  }
});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var AWS = __webpack_require__(0);
var byteLength = AWS.util.string.byteLength;
var Buffer = AWS.util.Buffer;

/**
 * The managed uploader allows for easy and efficient uploading of buffers,
 * blobs, or streams, using a configurable amount of concurrency to perform
 * multipart uploads where possible. This abstraction also enables uploading
 * streams of unknown size due to the use of multipart uploads.
 *
 * To construct a managed upload object, see the {constructor} function.
 *
 * ## Tracking upload progress
 *
 * The managed upload object can also track progress by attaching an
 * 'httpUploadProgress' listener to the upload manager. This event is similar
 * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
 * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
 * information.
 *
 * ## Handling Multipart Cleanup
 *
 * By default, this class will automatically clean up any multipart uploads
 * when an individual part upload fails. This behavior can be disabled in order
 * to manually handle failures by setting the `leavePartsOnError` configuration
 * option to `true` when initializing the upload object.
 *
 * @!event httpUploadProgress(progress)
 *   Triggered when the uploader has uploaded more data.
 *   @note The `total` property may not be set if the stream being uploaded has
 *     not yet finished chunking. In this case the `total` will be undefined
 *     until the total stream size is known.
 *   @note This event will not be emitted in Node.js 0.8.x.
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
 *     size is known.
 *   @context (see AWS.Request~send)
 */
AWS.S3.ManagedUpload = AWS.util.inherit({
  /**
   * Creates a managed upload object with a set of configuration options.
   *
   * @note A "Body" parameter is required to be set prior to calling {send}.
   * @option options params [map] a map of parameters to pass to the upload
   *   requests. The "Body" parameter is required to be specified either on
   *   the service or in the params option.
   * @note ContentMD5 should not be provided when using the managed upload object.
   *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
   *   by the managed upload object.
   * @option options queueSize [Number] (4) the size of the concurrent queue
   *   manager to upload parts in parallel. Set to 1 for synchronous uploading
   *   of parts. Note that the uploader will buffer at most queueSize * partSize
   *   bytes into memory at any given time.
   * @option options partSize [Number] (5mb) the size in bytes for each
   *   individual part to be uploaded. Adjust the part size to ensure the number
   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
   *   minimum allowed part size.
   * @option options leavePartsOnError [Boolean] (false) whether to abort the
   *   multipart upload if an error occurs. Set to true if you want to handle
   *   failures manually.
   * @option options service [AWS.S3] an optional S3 service object to use for
   *   requests. This object might have bound parameters used by the uploader.
   * @option options tags [Array<map>] The tags to apply to the uploaded object.
   *   Each tag should have a `Key` and `Value` keys.
   * @example Creating a default uploader for a stream object
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with concurrency of 1 and partSize of 10mb
   *   var upload = new AWS.S3.ManagedUpload({
   *     partSize: 10 * 1024 * 1024, queueSize: 1,
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with tags
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
   *   });
   * @see send
   */
  constructor: function ManagedUpload(options) {
    var self = this;
    AWS.SequentialExecutor.call(self);
    self.body = null;
    self.sliceFn = null;
    self.callback = null;
    self.parts = {};
    self.completeInfo = [];
    self.fillQueue = function() {
      self.callback(new Error('Unsupported body payload ' + typeof self.body));
    };

    self.configure(options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    options = options || {};
    this.partSize = this.minPartSize;

    if (options.queueSize) this.queueSize = options.queueSize;
    if (options.partSize) this.partSize = options.partSize;
    if (options.leavePartsOnError) this.leavePartsOnError = true;
    if (options.tags) {
      if (!Array.isArray(options.tags)) {
        throw new Error('Tags must be specified as an array; ' +
          typeof options.tags + ' provided.');
      }
      this.tags = options.tags;
    }

    if (this.partSize < this.minPartSize) {
      throw new Error('partSize must be greater than ' +
                      this.minPartSize);
    }

    this.service = options.service;
    this.bindServiceObject(options.params);
    this.validateBody();
    this.adjustTotalBytes();
  },

  /**
   * @api private
   */
  leavePartsOnError: false,

  /**
   * @api private
   */
  queueSize: 4,

  /**
   * @api private
   */
  partSize: null,

  /**
   * @readonly
   * @return [Number] the minimum number of bytes for an individual part
   *   upload.
   */
  minPartSize: 1024 * 1024 * 5,

  /**
   * @readonly
   * @return [Number] the maximum allowed number of parts in a multipart upload.
   */
  maxTotalParts: 10000,

  /**
   * Initiates the managed upload for the payload.
   *
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *     * `Location` (String) the URL of the uploaded object
   *     * `ETag` (String) the ETag of the uploaded object
   *     * `Bucket` (String) the bucket to which the object was uploaded
   *     * `Key` (String) the key to which the object was uploaded
   * @example Sending a managed upload object
   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *   var upload = new AWS.S3.ManagedUpload({params: params});
   *   upload.send(function(err, data) {
   *     console.log(err, data);
   *   });
   */
  send: function(callback) {
    var self = this;
    self.failed = false;
    self.callback = callback || function(err) { if (err) throw err; };

    var runFill = true;
    if (self.sliceFn) {
      self.fillQueue = self.fillBuffer;
    } else if (AWS.util.isNode()) {
      var Stream = AWS.util.stream.Stream;
      if (self.body instanceof Stream) {
        runFill = false;
        self.fillQueue = self.fillStream;
        self.partBuffers = [];
        self.body.
          on('error', function(err) { self.cleanup(err); }).
          on('readable', function() { self.fillQueue(); }).
          on('end', function() {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers;
            self.fillQueue.call(self);

            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
              self.finishMultiPart();
            }
          });
      }
    }

    if (runFill) self.fillQueue.call(self);
  },

  /**
   * @!method  promise()
   *   Returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [map] The response data from the successful upload:
   *       `Location` (String) the URL of the uploaded object
   *       `ETag` (String) the ETag of the uploaded object
   *       `Bucket` (String) the bucket to which the object was uploaded
   *       `Key` (String) the key to which the object was uploaded
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] an error or null if no error occurred.
   *   @return [Promise] A promise that represents the state of the upload request.
   *   @example Sending an upload request using promises.
   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
   *     var promise = upload.promise();
   *     promise.then(function(data) { ... }, function(err) { ... });
   */

  /**
   * Aborts a managed upload, including all concurrent upload requests.
   * @note By default, calling this function will cleanup a multipart upload
   *   if one was created. To leave the multipart upload around after aborting
   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
   * @note Calling {abort} in the browser environment will not abort any requests
   *   that are already in flight. If a multipart upload was created, any parts
   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
   * @example Aborting an upload
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: new Buffer(1024 * 1024 * 25) // 25MB payload
   *   };
   *   var upload = s3.upload(params);
   *   upload.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(upload.abort.bind(upload), 1000);
   */
  abort: function() {
    this.cleanup(AWS.util.error(new Error('Request aborted by user'), {
      code: 'RequestAbortedError', retryable: false
    }));
  },

  /**
   * @api private
   */
  validateBody: function validateBody() {
    var self = this;
    self.body = self.service.config.params.Body;
    if (typeof self.body === 'string') {
      self.body = new AWS.util.Buffer(self.body);
    } else if (!self.body) {
      throw new Error('params.Body is required');
    }
    self.sliceFn = AWS.util.arraySliceFn(self.body);
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(params) {
    params = params || {};
    var self = this;
    // bind parameters to new service object
    if (!self.service) {
      self.service = new AWS.S3({params: params});
    } else {
      var service = self.service;
      var config = AWS.util.copy(service.config);
      config.signatureVersion = service.getSignatureVersion();
      self.service = new service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, params);
    }
  },

  /**
   * @api private
   */
  adjustTotalBytes: function adjustTotalBytes() {
    var self = this;
    try { // try to get totalBytes
      self.totalBytes = byteLength(self.body);
    } catch (e) { }

    // try to adjust partSize if we know payload length
    if (self.totalBytes) {
      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
      if (newPartSize > self.partSize) self.partSize = newPartSize;
    } else {
      self.totalBytes = undefined;
    }
  },

  /**
   * @api private
   */
  isDoneChunking: false,

  /**
   * @api private
   */
  partPos: 0,

  /**
   * @api private
   */
  totalChunkedBytes: 0,

  /**
   * @api private
   */
  totalUploadedBytes: 0,

  /**
   * @api private
   */
  totalBytes: undefined,

  /**
   * @api private
   */
  numParts: 0,

  /**
   * @api private
   */
  totalPartNumbers: 0,

  /**
   * @api private
   */
  activeParts: 0,

  /**
   * @api private
   */
  doneParts: 0,

  /**
   * @api private
   */
  parts: null,

  /**
   * @api private
   */
  completeInfo: null,

  /**
   * @api private
   */
  failed: false,

  /**
   * @api private
   */
  multipartReq: null,

  /**
   * @api private
   */
  partBuffers: null,

  /**
   * @api private
   */
  partBufferLength: 0,

  /**
   * @api private
   */
  fillBuffer: function fillBuffer() {
    var self = this;
    var bodyLen = byteLength(self.body);

    if (bodyLen === 0) {
      self.isDoneChunking = true;
      self.numParts = 1;
      self.nextChunk(self.body);
      return;
    }

    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
      var endPos = Math.min(self.partPos + self.partSize, bodyLen);
      var buf = self.sliceFn.call(self.body, self.partPos, endPos);
      self.partPos += self.partSize;

      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
        self.isDoneChunking = true;
        self.numParts = self.totalPartNumbers + 1;
      }
      self.nextChunk(buf);
    }
  },

  /**
   * @api private
   */
  fillStream: function fillStream() {
    var self = this;
    if (self.activeParts >= self.queueSize) return;

    var buf = self.body.read(self.partSize - self.partBufferLength) ||
              self.body.read();
    if (buf) {
      self.partBuffers.push(buf);
      self.partBufferLength += buf.length;
      self.totalChunkedBytes += buf.length;
    }

    if (self.partBufferLength >= self.partSize) {
      // if we have single buffer we avoid copyfull concat
      var pbuf = self.partBuffers.length === 1 ?
        self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;

      // if we have more than partSize, push the rest back on the queue
      if (pbuf.length > self.partSize) {
        var rest = pbuf.slice(self.partSize);
        self.partBuffers.push(rest);
        self.partBufferLength += rest.length;
        pbuf = pbuf.slice(0, self.partSize);
      }

      self.nextChunk(pbuf);
    }

    if (self.isDoneChunking && !self.isDoneSending) {
      // if we have single buffer we avoid copyfull concat
      pbuf = self.partBuffers.length === 1 ?
          self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;
      self.totalBytes = self.totalChunkedBytes;
      self.isDoneSending = true;

      if (self.numParts === 0 || pbuf.length > 0) {
        self.numParts++;
        self.nextChunk(pbuf);
      }
    }

    self.body.read(0);
  },

  /**
   * @api private
   */
  nextChunk: function nextChunk(chunk) {
    var self = this;
    if (self.failed) return null;

    var partNumber = ++self.totalPartNumbers;
    if (self.isDoneChunking && partNumber === 1) {
      var params = {Body: chunk};
      if (this.tags) {
        params.Tagging = this.getTaggingHeader();
      }
      var req = self.service.putObject(params);
      req._managedUpload = self;
      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
      return null;
    } else if (self.service.config.params.ContentMD5) {
      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
        code: 'InvalidDigest', retryable: false
      });

      self.cleanup(err);
      return null;
    }

    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
      return null; // Already uploaded this part.
    }

    self.activeParts++;
    if (!self.service.config.params.UploadId) {

      if (!self.multipartReq) { // create multipart
        self.multipartReq = self.service.createMultipartUpload();
        self.multipartReq.on('success', function(resp) {
          self.service.config.params.UploadId = resp.data.UploadId;
          self.multipartReq = null;
        });
        self.queueChunks(chunk, partNumber);
        self.multipartReq.on('error', function(err) {
          self.cleanup(err);
        });
        self.multipartReq.send();
      } else {
        self.queueChunks(chunk, partNumber);
      }
    } else { // multipart is created, just send
      self.uploadPart(chunk, partNumber);
    }
  },

  /**
   * @api private
   */
  getTaggingHeader: function getTaggingHeader() {
    var kvPairStrings = [];
    for (var i = 0; i < this.tags.length; i++) {
      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +
        AWS.util.uriEscape(this.tags[i].Value));
    }

    return kvPairStrings.join('&');
  },

  /**
   * @api private
   */
  uploadPart: function uploadPart(chunk, partNumber) {
    var self = this;

    var partParams = {
      Body: chunk,
      ContentLength: AWS.util.string.byteLength(chunk),
      PartNumber: partNumber
    };

    var partInfo = {ETag: null, PartNumber: partNumber};
    self.completeInfo[partNumber] = partInfo;

    var req = self.service.uploadPart(partParams);
    self.parts[partNumber] = req;
    req._lastUploadedBytes = 0;
    req._managedUpload = self;
    req.on('httpUploadProgress', self.progress);
    req.send(function(err, data) {
      delete self.parts[partParams.PartNumber];
      self.activeParts--;

      if (!err && (!data || !data.ETag)) {
        var message = 'No access to ETag property on response.';
        if (AWS.util.isBrowser()) {
          message += ' Check CORS configuration to expose ETag header.';
        }

        err = AWS.util.error(new Error(message), {
          code: 'ETagMissing', retryable: false
        });
      }
      if (err) return self.cleanup(err);

      partInfo.ETag = data.ETag;
      self.doneParts++;
      if (self.isDoneChunking && self.doneParts === self.numParts) {
        self.finishMultiPart();
      } else {
        self.fillQueue.call(self);
      }
    });
  },

  /**
   * @api private
   */
  queueChunks: function queueChunks(chunk, partNumber) {
    var self = this;
    self.multipartReq.on('success', function() {
      self.uploadPart(chunk, partNumber);
    });
  },

  /**
   * @api private
   */
  cleanup: function cleanup(err) {
    var self = this;
    if (self.failed) return;

    // clean up stream
    if (typeof self.body.removeAllListeners === 'function' &&
        typeof self.body.resume === 'function') {
      self.body.removeAllListeners('readable');
      self.body.removeAllListeners('end');
      self.body.resume();
    }

    // cleanup multipartReq listeners
    if (self.multipartReq) {
      self.multipartReq.removeAllListeners('success');
      self.multipartReq.removeAllListeners('error');
      self.multipartReq.removeAllListeners('complete');
      delete self.multipartReq;
    }

    if (self.service.config.params.UploadId && !self.leavePartsOnError) {
      self.service.abortMultipartUpload().send();
    } else if (self.leavePartsOnError) {
      self.isDoneChunking = false;
    }

    AWS.util.each(self.parts, function(partNumber, part) {
      part.removeAllListeners('complete');
      part.abort();
    });

    self.activeParts = 0;
    self.partPos = 0;
    self.numParts = 0;
    self.totalPartNumbers = 0;
    self.parts = {};
    self.failed = true;
    self.callback(err);
  },

  /**
   * @api private
   */
  finishMultiPart: function finishMultiPart() {
    var self = this;
    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
    self.service.completeMultipartUpload(completeParams, function(err, data) {
      if (err) {
        return self.cleanup(err);
      }

      if (data && typeof data.Location === 'string') {
        data.Location = data.Location.replace(/%2F/g, '/');
      }

      if (Array.isArray(self.tags)) {
        self.service.putObjectTagging(
          {Tagging: {TagSet: self.tags}},
          function(e, d) {
            if (e) {
              self.callback(e);
            } else {
              self.callback(e, data);
            }
          }
        );
      } else {
        self.callback(err, data);
      }
    });
  },

  /**
   * @api private
   */
  finishSinglePart: function finishSinglePart(err, data) {
    var upload = this.request._managedUpload;
    var httpReq = this.request.httpRequest;
    var endpoint = httpReq.endpoint;
    if (err) return upload.callback(err);
    data.Location =
      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
    data.key = this.request.params.Key; // will stay undocumented
    data.Key = this.request.params.Key;
    data.Bucket = this.request.params.Bucket;
    upload.callback(err, data);
  },

  /**
   * @api private
   */
  progress: function progress(info) {
    var upload = this._managedUpload;
    if (this.operation === 'putObject') {
      info.part = 1;
      info.key = this.params.Key;
    } else {
      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
      this._lastUploadedBytes = info.loaded;
      info = {
        loaded: upload.totalUploadedBytes,
        total: upload.totalBytes,
        part: this.params.PartNumber,
        key: this.params.Key
      };
    }
    upload.emit('httpUploadProgress', [info]);
  }
});

AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);

/**
 * @api private
 */
AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.S3.ManagedUpload);

module.exports = AWS.S3.ManagedUpload;


/***/ }),
/* 249 */
/***/ (function(module, exports) {

module.exports = {"version":"2.0","metadata":{"apiVersion":"2006-03-01","checksumFormat":"md5","endpointPrefix":"s3","globalEndpoint":"s3.amazonaws.com","protocol":"rest-xml","serviceAbbreviation":"Amazon S3","serviceFullName":"Amazon Simple Storage Service","signatureVersion":"s3","timestampFormat":"rfc822","uid":"s3-2006-03-01"},"operations":{"AbortMultipartUpload":{"http":{"method":"DELETE","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key","UploadId"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"UploadId":{"location":"querystring","locationName":"uploadId"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"CompleteMultipartUpload":{"http":{"requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key","UploadId"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"MultipartUpload":{"locationName":"CompleteMultipartUpload","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"Parts":{"locationName":"Part","type":"list","member":{"type":"structure","members":{"ETag":{},"PartNumber":{"type":"integer"}}},"flattened":true}}},"UploadId":{"location":"querystring","locationName":"uploadId"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}},"payload":"MultipartUpload"},"output":{"type":"structure","members":{"Location":{},"Bucket":{},"Key":{},"Expiration":{"location":"header","locationName":"x-amz-expiration"},"ETag":{},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"CopyObject":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","CopySource","Key"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"Bucket":{"location":"uri","locationName":"Bucket"},"CacheControl":{"location":"header","locationName":"Cache-Control"},"ContentDisposition":{"location":"header","locationName":"Content-Disposition"},"ContentEncoding":{"location":"header","locationName":"Content-Encoding"},"ContentLanguage":{"location":"header","locationName":"Content-Language"},"ContentType":{"location":"header","locationName":"Content-Type"},"CopySource":{"location":"header","locationName":"x-amz-copy-source"},"CopySourceIfMatch":{"location":"header","locationName":"x-amz-copy-source-if-match"},"CopySourceIfModifiedSince":{"location":"header","locationName":"x-amz-copy-source-if-modified-since","type":"timestamp"},"CopySourceIfNoneMatch":{"location":"header","locationName":"x-amz-copy-source-if-none-match"},"CopySourceIfUnmodifiedSince":{"location":"header","locationName":"x-amz-copy-source-if-unmodified-since","type":"timestamp"},"Expires":{"location":"header","locationName":"Expires","type":"timestamp"},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"},"Key":{"location":"uri","locationName":"Key"},"Metadata":{"shape":"S11","location":"headers","locationName":"x-amz-meta-"},"MetadataDirective":{"location":"header","locationName":"x-amz-metadata-directive"},"TaggingDirective":{"location":"header","locationName":"x-amz-tagging-directive"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"StorageClass":{"location":"header","locationName":"x-amz-storage-class"},"WebsiteRedirectLocation":{"location":"header","locationName":"x-amz-website-redirect-location"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"CopySourceSSECustomerAlgorithm":{"location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-algorithm"},"CopySourceSSECustomerKey":{"shape":"S1c","location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-key"},"CopySourceSSECustomerKeyMD5":{"location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-key-MD5"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"Tagging":{"location":"header","locationName":"x-amz-tagging"}}},"output":{"type":"structure","members":{"CopyObjectResult":{"type":"structure","members":{"ETag":{},"LastModified":{"type":"timestamp"}}},"Expiration":{"location":"header","locationName":"x-amz-expiration"},"CopySourceVersionId":{"location":"header","locationName":"x-amz-copy-source-version-id"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}},"payload":"CopyObjectResult"},"alias":"PutObjectCopy"},"CreateBucket":{"http":{"method":"PUT","requestUri":"/{Bucket}"},"input":{"type":"structure","required":["Bucket"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"Bucket":{"location":"uri","locationName":"Bucket"},"CreateBucketConfiguration":{"locationName":"CreateBucketConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"LocationConstraint":{}}},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWrite":{"location":"header","locationName":"x-amz-grant-write"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"}},"payload":"CreateBucketConfiguration"},"output":{"type":"structure","members":{"Location":{"location":"header","locationName":"Location"}}},"alias":"PutBucket"},"CreateMultipartUpload":{"http":{"requestUri":"/{Bucket}/{Key+}?uploads"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"Bucket":{"location":"uri","locationName":"Bucket"},"CacheControl":{"location":"header","locationName":"Cache-Control"},"ContentDisposition":{"location":"header","locationName":"Content-Disposition"},"ContentEncoding":{"location":"header","locationName":"Content-Encoding"},"ContentLanguage":{"location":"header","locationName":"Content-Language"},"ContentType":{"location":"header","locationName":"Content-Type"},"Expires":{"location":"header","locationName":"Expires","type":"timestamp"},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"},"Key":{"location":"uri","locationName":"Key"},"Metadata":{"shape":"S11","location":"headers","locationName":"x-amz-meta-"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"StorageClass":{"location":"header","locationName":"x-amz-storage-class"},"WebsiteRedirectLocation":{"location":"header","locationName":"x-amz-website-redirect-location"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"Tagging":{"location":"header","locationName":"x-amz-tagging"}}},"output":{"type":"structure","members":{"AbortDate":{"location":"header","locationName":"x-amz-abort-date","type":"timestamp"},"AbortRuleId":{"location":"header","locationName":"x-amz-abort-rule-id"},"Bucket":{"locationName":"Bucket"},"Key":{},"UploadId":{},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}},"alias":"InitiateMultipartUpload"},"DeleteBucket":{"http":{"method":"DELETE","requestUri":"/{Bucket}"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketAnalyticsConfiguration":{"http":{"method":"DELETE","requestUri":"/{Bucket}?analytics"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}}},"DeleteBucketCors":{"http":{"method":"DELETE","requestUri":"/{Bucket}?cors"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketInventoryConfiguration":{"http":{"method":"DELETE","requestUri":"/{Bucket}?inventory"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}}},"DeleteBucketLifecycle":{"http":{"method":"DELETE","requestUri":"/{Bucket}?lifecycle"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketMetricsConfiguration":{"http":{"method":"DELETE","requestUri":"/{Bucket}?metrics"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}}},"DeleteBucketPolicy":{"http":{"method":"DELETE","requestUri":"/{Bucket}?policy"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketReplication":{"http":{"method":"DELETE","requestUri":"/{Bucket}?replication"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketTagging":{"http":{"method":"DELETE","requestUri":"/{Bucket}?tagging"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteBucketWebsite":{"http":{"method":"DELETE","requestUri":"/{Bucket}?website"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"DeleteObject":{"http":{"method":"DELETE","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"MFA":{"location":"header","locationName":"x-amz-mfa"},"VersionId":{"location":"querystring","locationName":"versionId"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"DeleteMarker":{"location":"header","locationName":"x-amz-delete-marker","type":"boolean"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"DeleteObjectTagging":{"http":{"method":"DELETE","requestUri":"/{Bucket}/{Key+}?tagging"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"VersionId":{"location":"querystring","locationName":"versionId"}}},"output":{"type":"structure","members":{"VersionId":{"location":"header","locationName":"x-amz-version-id"}}}},"DeleteObjects":{"http":{"requestUri":"/{Bucket}?delete"},"input":{"type":"structure","required":["Bucket","Delete"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Delete":{"locationName":"Delete","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["Objects"],"members":{"Objects":{"locationName":"Object","type":"list","member":{"type":"structure","required":["Key"],"members":{"Key":{},"VersionId":{}}},"flattened":true},"Quiet":{"type":"boolean"}}},"MFA":{"location":"header","locationName":"x-amz-mfa"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}},"payload":"Delete"},"output":{"type":"structure","members":{"Deleted":{"type":"list","member":{"type":"structure","members":{"Key":{},"VersionId":{},"DeleteMarker":{"type":"boolean"},"DeleteMarkerVersionId":{}}},"flattened":true},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"},"Errors":{"locationName":"Error","type":"list","member":{"type":"structure","members":{"Key":{},"VersionId":{},"Code":{},"Message":{}}},"flattened":true}}},"alias":"DeleteMultipleObjects"},"GetBucketAccelerateConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?accelerate"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Status":{}}}},"GetBucketAcl":{"http":{"method":"GET","requestUri":"/{Bucket}?acl"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Owner":{"shape":"S2u"},"Grants":{"shape":"S2x","locationName":"AccessControlList"}}}},"GetBucketAnalyticsConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?analytics"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}},"output":{"type":"structure","members":{"AnalyticsConfiguration":{"shape":"S36"}},"payload":"AnalyticsConfiguration"}},"GetBucketCors":{"http":{"method":"GET","requestUri":"/{Bucket}?cors"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"CORSRules":{"shape":"S3m","locationName":"CORSRule"}}}},"GetBucketInventoryConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?inventory"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}},"output":{"type":"structure","members":{"InventoryConfiguration":{"shape":"S3z"}},"payload":"InventoryConfiguration"}},"GetBucketLifecycle":{"http":{"method":"GET","requestUri":"/{Bucket}?lifecycle"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Rules":{"shape":"S4c","locationName":"Rule"}}},"deprecated":true},"GetBucketLifecycleConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?lifecycle"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Rules":{"shape":"S4r","locationName":"Rule"}}}},"GetBucketLocation":{"http":{"method":"GET","requestUri":"/{Bucket}?location"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"LocationConstraint":{}}}},"GetBucketLogging":{"http":{"method":"GET","requestUri":"/{Bucket}?logging"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"LoggingEnabled":{"shape":"S51"}}}},"GetBucketMetricsConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?metrics"},"input":{"type":"structure","required":["Bucket","Id"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"}}},"output":{"type":"structure","members":{"MetricsConfiguration":{"shape":"S59"}},"payload":"MetricsConfiguration"}},"GetBucketNotification":{"http":{"method":"GET","requestUri":"/{Bucket}?notification"},"input":{"shape":"S5c"},"output":{"shape":"S5d"},"deprecated":true},"GetBucketNotificationConfiguration":{"http":{"method":"GET","requestUri":"/{Bucket}?notification"},"input":{"shape":"S5c"},"output":{"shape":"S5o"}},"GetBucketPolicy":{"http":{"method":"GET","requestUri":"/{Bucket}?policy"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Policy":{}},"payload":"Policy"}},"GetBucketReplication":{"http":{"method":"GET","requestUri":"/{Bucket}?replication"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"ReplicationConfiguration":{"shape":"S67"}},"payload":"ReplicationConfiguration"}},"GetBucketRequestPayment":{"http":{"method":"GET","requestUri":"/{Bucket}?requestPayment"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Payer":{}}}},"GetBucketTagging":{"http":{"method":"GET","requestUri":"/{Bucket}?tagging"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","required":["TagSet"],"members":{"TagSet":{"shape":"S3c"}}}},"GetBucketVersioning":{"http":{"method":"GET","requestUri":"/{Bucket}?versioning"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"Status":{},"MFADelete":{"locationName":"MfaDelete"}}}},"GetBucketWebsite":{"http":{"method":"GET","requestUri":"/{Bucket}?website"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"output":{"type":"structure","members":{"RedirectAllRequestsTo":{"shape":"S6o"},"IndexDocument":{"shape":"S6r"},"ErrorDocument":{"shape":"S6t"},"RoutingRules":{"shape":"S6u"}}}},"GetObject":{"http":{"method":"GET","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"IfMatch":{"location":"header","locationName":"If-Match"},"IfModifiedSince":{"location":"header","locationName":"If-Modified-Since","type":"timestamp"},"IfNoneMatch":{"location":"header","locationName":"If-None-Match"},"IfUnmodifiedSince":{"location":"header","locationName":"If-Unmodified-Since","type":"timestamp"},"Key":{"location":"uri","locationName":"Key"},"Range":{"location":"header","locationName":"Range"},"ResponseCacheControl":{"location":"querystring","locationName":"response-cache-control"},"ResponseContentDisposition":{"location":"querystring","locationName":"response-content-disposition"},"ResponseContentEncoding":{"location":"querystring","locationName":"response-content-encoding"},"ResponseContentLanguage":{"location":"querystring","locationName":"response-content-language"},"ResponseContentType":{"location":"querystring","locationName":"response-content-type"},"ResponseExpires":{"location":"querystring","locationName":"response-expires","type":"timestamp"},"VersionId":{"location":"querystring","locationName":"versionId"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"PartNumber":{"location":"querystring","locationName":"partNumber","type":"integer"}}},"output":{"type":"structure","members":{"Body":{"streaming":true,"type":"blob"},"DeleteMarker":{"location":"header","locationName":"x-amz-delete-marker","type":"boolean"},"AcceptRanges":{"location":"header","locationName":"accept-ranges"},"Expiration":{"location":"header","locationName":"x-amz-expiration"},"Restore":{"location":"header","locationName":"x-amz-restore"},"LastModified":{"location":"header","locationName":"Last-Modified","type":"timestamp"},"ContentLength":{"location":"header","locationName":"Content-Length","type":"long"},"ETag":{"location":"header","locationName":"ETag"},"MissingMeta":{"location":"header","locationName":"x-amz-missing-meta","type":"integer"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"CacheControl":{"location":"header","locationName":"Cache-Control"},"ContentDisposition":{"location":"header","locationName":"Content-Disposition"},"ContentEncoding":{"location":"header","locationName":"Content-Encoding"},"ContentLanguage":{"location":"header","locationName":"Content-Language"},"ContentRange":{"location":"header","locationName":"Content-Range"},"ContentType":{"location":"header","locationName":"Content-Type"},"Expires":{"location":"header","locationName":"Expires","type":"timestamp"},"WebsiteRedirectLocation":{"location":"header","locationName":"x-amz-website-redirect-location"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"Metadata":{"shape":"S11","location":"headers","locationName":"x-amz-meta-"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"StorageClass":{"location":"header","locationName":"x-amz-storage-class"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"},"ReplicationStatus":{"location":"header","locationName":"x-amz-replication-status"},"PartsCount":{"location":"header","locationName":"x-amz-mp-parts-count","type":"integer"},"TagCount":{"location":"header","locationName":"x-amz-tagging-count","type":"integer"}},"payload":"Body"}},"GetObjectAcl":{"http":{"method":"GET","requestUri":"/{Bucket}/{Key+}?acl"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"VersionId":{"location":"querystring","locationName":"versionId"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"Owner":{"shape":"S2u"},"Grants":{"shape":"S2x","locationName":"AccessControlList"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"GetObjectTagging":{"http":{"method":"GET","requestUri":"/{Bucket}/{Key+}?tagging"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"VersionId":{"location":"querystring","locationName":"versionId"}}},"output":{"type":"structure","required":["TagSet"],"members":{"VersionId":{"location":"header","locationName":"x-amz-version-id"},"TagSet":{"shape":"S3c"}}}},"GetObjectTorrent":{"http":{"method":"GET","requestUri":"/{Bucket}/{Key+}?torrent"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"Body":{"streaming":true,"type":"blob"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}},"payload":"Body"}},"HeadBucket":{"http":{"method":"HEAD","requestUri":"/{Bucket}"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}}},"HeadObject":{"http":{"method":"HEAD","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"IfMatch":{"location":"header","locationName":"If-Match"},"IfModifiedSince":{"location":"header","locationName":"If-Modified-Since","type":"timestamp"},"IfNoneMatch":{"location":"header","locationName":"If-None-Match"},"IfUnmodifiedSince":{"location":"header","locationName":"If-Unmodified-Since","type":"timestamp"},"Key":{"location":"uri","locationName":"Key"},"Range":{"location":"header","locationName":"Range"},"VersionId":{"location":"querystring","locationName":"versionId"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"PartNumber":{"location":"querystring","locationName":"partNumber","type":"integer"}}},"output":{"type":"structure","members":{"DeleteMarker":{"location":"header","locationName":"x-amz-delete-marker","type":"boolean"},"AcceptRanges":{"location":"header","locationName":"accept-ranges"},"Expiration":{"location":"header","locationName":"x-amz-expiration"},"Restore":{"location":"header","locationName":"x-amz-restore"},"LastModified":{"location":"header","locationName":"Last-Modified","type":"timestamp"},"ContentLength":{"location":"header","locationName":"Content-Length","type":"long"},"ETag":{"location":"header","locationName":"ETag"},"MissingMeta":{"location":"header","locationName":"x-amz-missing-meta","type":"integer"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"CacheControl":{"location":"header","locationName":"Cache-Control"},"ContentDisposition":{"location":"header","locationName":"Content-Disposition"},"ContentEncoding":{"location":"header","locationName":"Content-Encoding"},"ContentLanguage":{"location":"header","locationName":"Content-Language"},"ContentType":{"location":"header","locationName":"Content-Type"},"Expires":{"location":"header","locationName":"Expires","type":"timestamp"},"WebsiteRedirectLocation":{"location":"header","locationName":"x-amz-website-redirect-location"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"Metadata":{"shape":"S11","location":"headers","locationName":"x-amz-meta-"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"StorageClass":{"location":"header","locationName":"x-amz-storage-class"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"},"ReplicationStatus":{"location":"header","locationName":"x-amz-replication-status"},"PartsCount":{"location":"header","locationName":"x-amz-mp-parts-count","type":"integer"}}}},"ListBucketAnalyticsConfigurations":{"http":{"method":"GET","requestUri":"/{Bucket}?analytics"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContinuationToken":{"location":"querystring","locationName":"continuation-token"}}},"output":{"type":"structure","members":{"IsTruncated":{"type":"boolean"},"ContinuationToken":{},"NextContinuationToken":{},"AnalyticsConfigurationList":{"locationName":"AnalyticsConfiguration","type":"list","member":{"shape":"S36"},"flattened":true}}}},"ListBucketInventoryConfigurations":{"http":{"method":"GET","requestUri":"/{Bucket}?inventory"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContinuationToken":{"location":"querystring","locationName":"continuation-token"}}},"output":{"type":"structure","members":{"ContinuationToken":{},"InventoryConfigurationList":{"locationName":"InventoryConfiguration","type":"list","member":{"shape":"S3z"},"flattened":true},"IsTruncated":{"type":"boolean"},"NextContinuationToken":{}}}},"ListBucketMetricsConfigurations":{"http":{"method":"GET","requestUri":"/{Bucket}?metrics"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContinuationToken":{"location":"querystring","locationName":"continuation-token"}}},"output":{"type":"structure","members":{"IsTruncated":{"type":"boolean"},"ContinuationToken":{},"NextContinuationToken":{},"MetricsConfigurationList":{"locationName":"MetricsConfiguration","type":"list","member":{"shape":"S59"},"flattened":true}}}},"ListBuckets":{"http":{"method":"GET"},"output":{"type":"structure","members":{"Buckets":{"type":"list","member":{"locationName":"Bucket","type":"structure","members":{"Name":{},"CreationDate":{"type":"timestamp"}}}},"Owner":{"shape":"S2u"}}},"alias":"GetService"},"ListMultipartUploads":{"http":{"method":"GET","requestUri":"/{Bucket}?uploads"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Delimiter":{"location":"querystring","locationName":"delimiter"},"EncodingType":{"location":"querystring","locationName":"encoding-type"},"KeyMarker":{"location":"querystring","locationName":"key-marker"},"MaxUploads":{"location":"querystring","locationName":"max-uploads","type":"integer"},"Prefix":{"location":"querystring","locationName":"prefix"},"UploadIdMarker":{"location":"querystring","locationName":"upload-id-marker"}}},"output":{"type":"structure","members":{"Bucket":{},"KeyMarker":{},"UploadIdMarker":{},"NextKeyMarker":{},"Prefix":{},"Delimiter":{},"NextUploadIdMarker":{},"MaxUploads":{"type":"integer"},"IsTruncated":{"type":"boolean"},"Uploads":{"locationName":"Upload","type":"list","member":{"type":"structure","members":{"UploadId":{},"Key":{},"Initiated":{"type":"timestamp"},"StorageClass":{},"Owner":{"shape":"S2u"},"Initiator":{"shape":"S8q"}}},"flattened":true},"CommonPrefixes":{"shape":"S8r"},"EncodingType":{}}}},"ListObjectVersions":{"http":{"method":"GET","requestUri":"/{Bucket}?versions"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Delimiter":{"location":"querystring","locationName":"delimiter"},"EncodingType":{"location":"querystring","locationName":"encoding-type"},"KeyMarker":{"location":"querystring","locationName":"key-marker"},"MaxKeys":{"location":"querystring","locationName":"max-keys","type":"integer"},"Prefix":{"location":"querystring","locationName":"prefix"},"VersionIdMarker":{"location":"querystring","locationName":"version-id-marker"}}},"output":{"type":"structure","members":{"IsTruncated":{"type":"boolean"},"KeyMarker":{},"VersionIdMarker":{},"NextKeyMarker":{},"NextVersionIdMarker":{},"Versions":{"locationName":"Version","type":"list","member":{"type":"structure","members":{"ETag":{},"Size":{"type":"integer"},"StorageClass":{},"Key":{},"VersionId":{},"IsLatest":{"type":"boolean"},"LastModified":{"type":"timestamp"},"Owner":{"shape":"S2u"}}},"flattened":true},"DeleteMarkers":{"locationName":"DeleteMarker","type":"list","member":{"type":"structure","members":{"Owner":{"shape":"S2u"},"Key":{},"VersionId":{},"IsLatest":{"type":"boolean"},"LastModified":{"type":"timestamp"}}},"flattened":true},"Name":{},"Prefix":{},"Delimiter":{},"MaxKeys":{"type":"integer"},"CommonPrefixes":{"shape":"S8r"},"EncodingType":{}}},"alias":"GetBucketObjectVersions"},"ListObjects":{"http":{"method":"GET","requestUri":"/{Bucket}"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Delimiter":{"location":"querystring","locationName":"delimiter"},"EncodingType":{"location":"querystring","locationName":"encoding-type"},"Marker":{"location":"querystring","locationName":"marker"},"MaxKeys":{"location":"querystring","locationName":"max-keys","type":"integer"},"Prefix":{"location":"querystring","locationName":"prefix"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"IsTruncated":{"type":"boolean"},"Marker":{},"NextMarker":{},"Contents":{"shape":"S99"},"Name":{},"Prefix":{},"Delimiter":{},"MaxKeys":{"type":"integer"},"CommonPrefixes":{"shape":"S8r"},"EncodingType":{}}},"alias":"GetBucket"},"ListObjectsV2":{"http":{"method":"GET","requestUri":"/{Bucket}?list-type=2"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Delimiter":{"location":"querystring","locationName":"delimiter"},"EncodingType":{"location":"querystring","locationName":"encoding-type"},"MaxKeys":{"location":"querystring","locationName":"max-keys","type":"integer"},"Prefix":{"location":"querystring","locationName":"prefix"},"ContinuationToken":{"location":"querystring","locationName":"continuation-token"},"FetchOwner":{"location":"querystring","locationName":"fetch-owner","type":"boolean"},"StartAfter":{"location":"querystring","locationName":"start-after"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"IsTruncated":{"type":"boolean"},"Contents":{"shape":"S99"},"Name":{},"Prefix":{},"Delimiter":{},"MaxKeys":{"type":"integer"},"CommonPrefixes":{"shape":"S8r"},"EncodingType":{},"KeyCount":{"type":"integer"},"ContinuationToken":{},"NextContinuationToken":{},"StartAfter":{}}}},"ListParts":{"http":{"method":"GET","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key","UploadId"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"MaxParts":{"location":"querystring","locationName":"max-parts","type":"integer"},"PartNumberMarker":{"location":"querystring","locationName":"part-number-marker","type":"integer"},"UploadId":{"location":"querystring","locationName":"uploadId"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"AbortDate":{"location":"header","locationName":"x-amz-abort-date","type":"timestamp"},"AbortRuleId":{"location":"header","locationName":"x-amz-abort-rule-id"},"Bucket":{},"Key":{},"UploadId":{},"PartNumberMarker":{"type":"integer"},"NextPartNumberMarker":{"type":"integer"},"MaxParts":{"type":"integer"},"IsTruncated":{"type":"boolean"},"Parts":{"locationName":"Part","type":"list","member":{"type":"structure","members":{"PartNumber":{"type":"integer"},"LastModified":{"type":"timestamp"},"ETag":{},"Size":{"type":"integer"}}},"flattened":true},"Initiator":{"shape":"S8q"},"Owner":{"shape":"S2u"},"StorageClass":{},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"PutBucketAccelerateConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?accelerate"},"input":{"type":"structure","required":["Bucket","AccelerateConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"AccelerateConfiguration":{"locationName":"AccelerateConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"Status":{}}}},"payload":"AccelerateConfiguration"}},"PutBucketAcl":{"http":{"method":"PUT","requestUri":"/{Bucket}?acl"},"input":{"type":"structure","required":["Bucket"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"AccessControlPolicy":{"shape":"S9r","locationName":"AccessControlPolicy","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}},"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWrite":{"location":"header","locationName":"x-amz-grant-write"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"}},"payload":"AccessControlPolicy"}},"PutBucketAnalyticsConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?analytics"},"input":{"type":"structure","required":["Bucket","Id","AnalyticsConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"},"AnalyticsConfiguration":{"shape":"S36","locationName":"AnalyticsConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"AnalyticsConfiguration"}},"PutBucketCors":{"http":{"method":"PUT","requestUri":"/{Bucket}?cors"},"input":{"type":"structure","required":["Bucket","CORSConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"CORSConfiguration":{"locationName":"CORSConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["CORSRules"],"members":{"CORSRules":{"shape":"S3m","locationName":"CORSRule"}}},"ContentMD5":{"location":"header","locationName":"Content-MD5"}},"payload":"CORSConfiguration"}},"PutBucketInventoryConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?inventory"},"input":{"type":"structure","required":["Bucket","Id","InventoryConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"},"InventoryConfiguration":{"shape":"S3z","locationName":"InventoryConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"InventoryConfiguration"}},"PutBucketLifecycle":{"http":{"method":"PUT","requestUri":"/{Bucket}?lifecycle"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"LifecycleConfiguration":{"locationName":"LifecycleConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["Rules"],"members":{"Rules":{"shape":"S4c","locationName":"Rule"}}}},"payload":"LifecycleConfiguration"},"deprecated":true},"PutBucketLifecycleConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?lifecycle"},"input":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"LifecycleConfiguration":{"locationName":"LifecycleConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["Rules"],"members":{"Rules":{"shape":"S4r","locationName":"Rule"}}}},"payload":"LifecycleConfiguration"}},"PutBucketLogging":{"http":{"method":"PUT","requestUri":"/{Bucket}?logging"},"input":{"type":"structure","required":["Bucket","BucketLoggingStatus"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"BucketLoggingStatus":{"locationName":"BucketLoggingStatus","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"LoggingEnabled":{"shape":"S51"}}},"ContentMD5":{"location":"header","locationName":"Content-MD5"}},"payload":"BucketLoggingStatus"}},"PutBucketMetricsConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?metrics"},"input":{"type":"structure","required":["Bucket","Id","MetricsConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Id":{"location":"querystring","locationName":"id"},"MetricsConfiguration":{"shape":"S59","locationName":"MetricsConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"MetricsConfiguration"}},"PutBucketNotification":{"http":{"method":"PUT","requestUri":"/{Bucket}?notification"},"input":{"type":"structure","required":["Bucket","NotificationConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"NotificationConfiguration":{"shape":"S5d","locationName":"NotificationConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"NotificationConfiguration"},"deprecated":true},"PutBucketNotificationConfiguration":{"http":{"method":"PUT","requestUri":"/{Bucket}?notification"},"input":{"type":"structure","required":["Bucket","NotificationConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"NotificationConfiguration":{"shape":"S5o","locationName":"NotificationConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"NotificationConfiguration"}},"PutBucketPolicy":{"http":{"method":"PUT","requestUri":"/{Bucket}?policy"},"input":{"type":"structure","required":["Bucket","Policy"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"Policy":{}},"payload":"Policy"}},"PutBucketReplication":{"http":{"method":"PUT","requestUri":"/{Bucket}?replication"},"input":{"type":"structure","required":["Bucket","ReplicationConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"ReplicationConfiguration":{"shape":"S67","locationName":"ReplicationConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"ReplicationConfiguration"}},"PutBucketRequestPayment":{"http":{"method":"PUT","requestUri":"/{Bucket}?requestPayment"},"input":{"type":"structure","required":["Bucket","RequestPaymentConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"RequestPaymentConfiguration":{"locationName":"RequestPaymentConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["Payer"],"members":{"Payer":{}}}},"payload":"RequestPaymentConfiguration"}},"PutBucketTagging":{"http":{"method":"PUT","requestUri":"/{Bucket}?tagging"},"input":{"type":"structure","required":["Bucket","Tagging"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"Tagging":{"shape":"Sab","locationName":"Tagging","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"Tagging"}},"PutBucketVersioning":{"http":{"method":"PUT","requestUri":"/{Bucket}?versioning"},"input":{"type":"structure","required":["Bucket","VersioningConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"MFA":{"location":"header","locationName":"x-amz-mfa"},"VersioningConfiguration":{"locationName":"VersioningConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"MFADelete":{"locationName":"MfaDelete"},"Status":{}}}},"payload":"VersioningConfiguration"}},"PutBucketWebsite":{"http":{"method":"PUT","requestUri":"/{Bucket}?website"},"input":{"type":"structure","required":["Bucket","WebsiteConfiguration"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"WebsiteConfiguration":{"locationName":"WebsiteConfiguration","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","members":{"ErrorDocument":{"shape":"S6t"},"IndexDocument":{"shape":"S6r"},"RedirectAllRequestsTo":{"shape":"S6o"},"RoutingRules":{"shape":"S6u"}}}},"payload":"WebsiteConfiguration"}},"PutObject":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"Body":{"streaming":true,"type":"blob"},"Bucket":{"location":"uri","locationName":"Bucket"},"CacheControl":{"location":"header","locationName":"Cache-Control"},"ContentDisposition":{"location":"header","locationName":"Content-Disposition"},"ContentEncoding":{"location":"header","locationName":"Content-Encoding"},"ContentLanguage":{"location":"header","locationName":"Content-Language"},"ContentLength":{"location":"header","locationName":"Content-Length","type":"long"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"ContentType":{"location":"header","locationName":"Content-Type"},"Expires":{"location":"header","locationName":"Expires","type":"timestamp"},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"},"Key":{"location":"uri","locationName":"Key"},"Metadata":{"shape":"S11","location":"headers","locationName":"x-amz-meta-"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"StorageClass":{"location":"header","locationName":"x-amz-storage-class"},"WebsiteRedirectLocation":{"location":"header","locationName":"x-amz-website-redirect-location"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"Tagging":{"location":"header","locationName":"x-amz-tagging"}},"payload":"Body"},"output":{"type":"structure","members":{"Expiration":{"location":"header","locationName":"x-amz-expiration"},"ETag":{"location":"header","locationName":"ETag"},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"VersionId":{"location":"header","locationName":"x-amz-version-id"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"PutObjectAcl":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}?acl"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"ACL":{"location":"header","locationName":"x-amz-acl"},"AccessControlPolicy":{"shape":"S9r","locationName":"AccessControlPolicy","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}},"Bucket":{"location":"uri","locationName":"Bucket"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"GrantFullControl":{"location":"header","locationName":"x-amz-grant-full-control"},"GrantRead":{"location":"header","locationName":"x-amz-grant-read"},"GrantReadACP":{"location":"header","locationName":"x-amz-grant-read-acp"},"GrantWrite":{"location":"header","locationName":"x-amz-grant-write"},"GrantWriteACP":{"location":"header","locationName":"x-amz-grant-write-acp"},"Key":{"location":"uri","locationName":"Key"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"},"VersionId":{"location":"querystring","locationName":"versionId"}},"payload":"AccessControlPolicy"},"output":{"type":"structure","members":{"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"PutObjectTagging":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}?tagging"},"input":{"type":"structure","required":["Bucket","Key","Tagging"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"VersionId":{"location":"querystring","locationName":"versionId"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"Tagging":{"shape":"Sab","locationName":"Tagging","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"}}},"payload":"Tagging"},"output":{"type":"structure","members":{"VersionId":{"location":"header","locationName":"x-amz-version-id"}}}},"RestoreObject":{"http":{"requestUri":"/{Bucket}/{Key+}?restore"},"input":{"type":"structure","required":["Bucket","Key"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"Key":{"location":"uri","locationName":"Key"},"VersionId":{"location":"querystring","locationName":"versionId"},"RestoreRequest":{"locationName":"RestoreRequest","xmlNamespace":{"uri":"http://s3.amazonaws.com/doc/2006-03-01/"},"type":"structure","required":["Days"],"members":{"Days":{"type":"integer"},"GlacierJobParameters":{"type":"structure","required":["Tier"],"members":{"Tier":{}}}}},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}},"payload":"RestoreRequest"},"output":{"type":"structure","members":{"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}},"alias":"PostObjectRestore"},"UploadPart":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","Key","PartNumber","UploadId"],"members":{"Body":{"streaming":true,"type":"blob"},"Bucket":{"location":"uri","locationName":"Bucket"},"ContentLength":{"location":"header","locationName":"Content-Length","type":"long"},"ContentMD5":{"location":"header","locationName":"Content-MD5"},"Key":{"location":"uri","locationName":"Key"},"PartNumber":{"location":"querystring","locationName":"partNumber","type":"integer"},"UploadId":{"location":"querystring","locationName":"uploadId"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}},"payload":"Body"},"output":{"type":"structure","members":{"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"ETag":{"location":"header","locationName":"ETag"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}}}},"UploadPartCopy":{"http":{"method":"PUT","requestUri":"/{Bucket}/{Key+}"},"input":{"type":"structure","required":["Bucket","CopySource","Key","PartNumber","UploadId"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"},"CopySource":{"location":"header","locationName":"x-amz-copy-source"},"CopySourceIfMatch":{"location":"header","locationName":"x-amz-copy-source-if-match"},"CopySourceIfModifiedSince":{"location":"header","locationName":"x-amz-copy-source-if-modified-since","type":"timestamp"},"CopySourceIfNoneMatch":{"location":"header","locationName":"x-amz-copy-source-if-none-match"},"CopySourceIfUnmodifiedSince":{"location":"header","locationName":"x-amz-copy-source-if-unmodified-since","type":"timestamp"},"CopySourceRange":{"location":"header","locationName":"x-amz-copy-source-range"},"Key":{"location":"uri","locationName":"Key"},"PartNumber":{"location":"querystring","locationName":"partNumber","type":"integer"},"UploadId":{"location":"querystring","locationName":"uploadId"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKey":{"shape":"S19","location":"header","locationName":"x-amz-server-side-encryption-customer-key"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"CopySourceSSECustomerAlgorithm":{"location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-algorithm"},"CopySourceSSECustomerKey":{"shape":"S1c","location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-key"},"CopySourceSSECustomerKeyMD5":{"location":"header","locationName":"x-amz-copy-source-server-side-encryption-customer-key-MD5"},"RequestPayer":{"location":"header","locationName":"x-amz-request-payer"}}},"output":{"type":"structure","members":{"CopySourceVersionId":{"location":"header","locationName":"x-amz-copy-source-version-id"},"CopyPartResult":{"type":"structure","members":{"ETag":{},"LastModified":{"type":"timestamp"}}},"ServerSideEncryption":{"location":"header","locationName":"x-amz-server-side-encryption"},"SSECustomerAlgorithm":{"location":"header","locationName":"x-amz-server-side-encryption-customer-algorithm"},"SSECustomerKeyMD5":{"location":"header","locationName":"x-amz-server-side-encryption-customer-key-MD5"},"SSEKMSKeyId":{"shape":"Sj","location":"header","locationName":"x-amz-server-side-encryption-aws-kms-key-id"},"RequestCharged":{"location":"header","locationName":"x-amz-request-charged"}},"payload":"CopyPartResult"}}},"shapes":{"Sj":{"type":"string","sensitive":true},"S11":{"type":"map","key":{},"value":{}},"S19":{"type":"blob","sensitive":true},"S1c":{"type":"blob","sensitive":true},"S2u":{"type":"structure","members":{"DisplayName":{},"ID":{}}},"S2x":{"type":"list","member":{"locationName":"Grant","type":"structure","members":{"Grantee":{"shape":"S2z"},"Permission":{}}}},"S2z":{"type":"structure","required":["Type"],"members":{"DisplayName":{},"EmailAddress":{},"ID":{},"Type":{"locationName":"xsi:type","xmlAttribute":true},"URI":{}},"xmlNamespace":{"prefix":"xsi","uri":"http://www.w3.org/2001/XMLSchema-instance"}},"S36":{"type":"structure","required":["Id","StorageClassAnalysis"],"members":{"Id":{},"Filter":{"type":"structure","members":{"Prefix":{},"Tag":{"shape":"S39"},"And":{"type":"structure","members":{"Prefix":{},"Tags":{"shape":"S3c","flattened":true,"locationName":"Tag"}}}}},"StorageClassAnalysis":{"type":"structure","members":{"DataExport":{"type":"structure","required":["OutputSchemaVersion","Destination"],"members":{"OutputSchemaVersion":{},"Destination":{"type":"structure","required":["S3BucketDestination"],"members":{"S3BucketDestination":{"type":"structure","required":["Format","Bucket"],"members":{"Format":{},"BucketAccountId":{},"Bucket":{},"Prefix":{}}}}}}}}}}},"S39":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}},"S3c":{"type":"list","member":{"shape":"S39","locationName":"Tag"}},"S3m":{"type":"list","member":{"type":"structure","required":["AllowedMethods","AllowedOrigins"],"members":{"AllowedHeaders":{"locationName":"AllowedHeader","type":"list","member":{},"flattened":true},"AllowedMethods":{"locationName":"AllowedMethod","type":"list","member":{},"flattened":true},"AllowedOrigins":{"locationName":"AllowedOrigin","type":"list","member":{},"flattened":true},"ExposeHeaders":{"locationName":"ExposeHeader","type":"list","member":{},"flattened":true},"MaxAgeSeconds":{"type":"integer"}}},"flattened":true},"S3z":{"type":"structure","required":["Destination","IsEnabled","Id","IncludedObjectVersions","Schedule"],"members":{"Destination":{"type":"structure","required":["S3BucketDestination"],"members":{"S3BucketDestination":{"type":"structure","required":["Bucket","Format"],"members":{"AccountId":{},"Bucket":{},"Format":{},"Prefix":{}}}}},"IsEnabled":{"type":"boolean"},"Filter":{"type":"structure","required":["Prefix"],"members":{"Prefix":{}}},"Id":{},"IncludedObjectVersions":{},"OptionalFields":{"type":"list","member":{"locationName":"Field"}},"Schedule":{"type":"structure","required":["Frequency"],"members":{"Frequency":{}}}}},"S4c":{"type":"list","member":{"type":"structure","required":["Prefix","Status"],"members":{"Expiration":{"shape":"S4e"},"ID":{},"Prefix":{},"Status":{},"Transition":{"shape":"S4j"},"NoncurrentVersionTransition":{"shape":"S4l"},"NoncurrentVersionExpiration":{"shape":"S4m"},"AbortIncompleteMultipartUpload":{"shape":"S4n"}}},"flattened":true},"S4e":{"type":"structure","members":{"Date":{"shape":"S4f"},"Days":{"type":"integer"},"ExpiredObjectDeleteMarker":{"type":"boolean"}}},"S4f":{"type":"timestamp","timestampFormat":"iso8601"},"S4j":{"type":"structure","members":{"Date":{"shape":"S4f"},"Days":{"type":"integer"},"StorageClass":{}}},"S4l":{"type":"structure","members":{"NoncurrentDays":{"type":"integer"},"StorageClass":{}}},"S4m":{"type":"structure","members":{"NoncurrentDays":{"type":"integer"}}},"S4n":{"type":"structure","members":{"DaysAfterInitiation":{"type":"integer"}}},"S4r":{"type":"list","member":{"type":"structure","required":["Status"],"members":{"Expiration":{"shape":"S4e"},"ID":{},"Prefix":{"deprecated":true},"Filter":{"type":"structure","members":{"Prefix":{},"Tag":{"shape":"S39"},"And":{"type":"structure","members":{"Prefix":{},"Tags":{"shape":"S3c","flattened":true,"locationName":"Tag"}}}}},"Status":{},"Transitions":{"locationName":"Transition","type":"list","member":{"shape":"S4j"},"flattened":true},"NoncurrentVersionTransitions":{"locationName":"NoncurrentVersionTransition","type":"list","member":{"shape":"S4l"},"flattened":true},"NoncurrentVersionExpiration":{"shape":"S4m"},"AbortIncompleteMultipartUpload":{"shape":"S4n"}}},"flattened":true},"S51":{"type":"structure","members":{"TargetBucket":{},"TargetGrants":{"type":"list","member":{"locationName":"Grant","type":"structure","members":{"Grantee":{"shape":"S2z"},"Permission":{}}}},"TargetPrefix":{}}},"S59":{"type":"structure","required":["Id"],"members":{"Id":{},"Filter":{"type":"structure","members":{"Prefix":{},"Tag":{"shape":"S39"},"And":{"type":"structure","members":{"Prefix":{},"Tags":{"shape":"S3c","flattened":true,"locationName":"Tag"}}}}}}},"S5c":{"type":"structure","required":["Bucket"],"members":{"Bucket":{"location":"uri","locationName":"Bucket"}}},"S5d":{"type":"structure","members":{"TopicConfiguration":{"type":"structure","members":{"Id":{},"Events":{"shape":"S5g","locationName":"Event"},"Event":{"deprecated":true},"Topic":{}}},"QueueConfiguration":{"type":"structure","members":{"Id":{},"Event":{"deprecated":true},"Events":{"shape":"S5g","locationName":"Event"},"Queue":{}}},"CloudFunctionConfiguration":{"type":"structure","members":{"Id":{},"Event":{"deprecated":true},"Events":{"shape":"S5g","locationName":"Event"},"CloudFunction":{},"InvocationRole":{}}}}},"S5g":{"type":"list","member":{},"flattened":true},"S5o":{"type":"structure","members":{"TopicConfigurations":{"locationName":"TopicConfiguration","type":"list","member":{"type":"structure","required":["TopicArn","Events"],"members":{"Id":{},"TopicArn":{"locationName":"Topic"},"Events":{"shape":"S5g","locationName":"Event"},"Filter":{"shape":"S5r"}}},"flattened":true},"QueueConfigurations":{"locationName":"QueueConfiguration","type":"list","member":{"type":"structure","required":["QueueArn","Events"],"members":{"Id":{},"QueueArn":{"locationName":"Queue"},"Events":{"shape":"S5g","locationName":"Event"},"Filter":{"shape":"S5r"}}},"flattened":true},"LambdaFunctionConfigurations":{"locationName":"CloudFunctionConfiguration","type":"list","member":{"type":"structure","required":["LambdaFunctionArn","Events"],"members":{"Id":{},"LambdaFunctionArn":{"locationName":"CloudFunction"},"Events":{"shape":"S5g","locationName":"Event"},"Filter":{"shape":"S5r"}}},"flattened":true}}},"S5r":{"type":"structure","members":{"Key":{"locationName":"S3Key","type":"structure","members":{"FilterRules":{"locationName":"FilterRule","type":"list","member":{"type":"structure","members":{"Name":{},"Value":{}}},"flattened":true}}}}},"S67":{"type":"structure","required":["Role","Rules"],"members":{"Role":{},"Rules":{"locationName":"Rule","type":"list","member":{"type":"structure","required":["Prefix","Status","Destination"],"members":{"ID":{},"Prefix":{},"Status":{},"Destination":{"type":"structure","required":["Bucket"],"members":{"Bucket":{},"StorageClass":{}}}}},"flattened":true}}},"S6o":{"type":"structure","required":["HostName"],"members":{"HostName":{},"Protocol":{}}},"S6r":{"type":"structure","required":["Suffix"],"members":{"Suffix":{}}},"S6t":{"type":"structure","required":["Key"],"members":{"Key":{}}},"S6u":{"type":"list","member":{"locationName":"RoutingRule","type":"structure","required":["Redirect"],"members":{"Condition":{"type":"structure","members":{"HttpErrorCodeReturnedEquals":{},"KeyPrefixEquals":{}}},"Redirect":{"type":"structure","members":{"HostName":{},"HttpRedirectCode":{},"Protocol":{},"ReplaceKeyPrefixWith":{},"ReplaceKeyWith":{}}}}}},"S8q":{"type":"structure","members":{"ID":{},"DisplayName":{}}},"S8r":{"type":"list","member":{"type":"structure","members":{"Prefix":{}}},"flattened":true},"S99":{"type":"list","member":{"type":"structure","members":{"Key":{},"LastModified":{"type":"timestamp"},"ETag":{},"Size":{"type":"integer"},"StorageClass":{},"Owner":{"shape":"S2u"}}},"flattened":true},"S9r":{"type":"structure","members":{"Grants":{"shape":"S2x","locationName":"AccessControlList"},"Owner":{"shape":"S2u"}}},"Sab":{"type":"structure","required":["TagSet"],"members":{"TagSet":{"shape":"S3c"}}}}}

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = {"pagination":{"ListBuckets":{"result_key":"Buckets"},"ListMultipartUploads":{"input_token":["KeyMarker","UploadIdMarker"],"limit_key":"MaxUploads","more_results":"IsTruncated","output_token":["NextKeyMarker","NextUploadIdMarker"],"result_key":["Uploads","CommonPrefixes"]},"ListObjectVersions":{"input_token":["KeyMarker","VersionIdMarker"],"limit_key":"MaxKeys","more_results":"IsTruncated","output_token":["NextKeyMarker","NextVersionIdMarker"],"result_key":["Versions","DeleteMarkers","CommonPrefixes"]},"ListObjects":{"input_token":"Marker","limit_key":"MaxKeys","more_results":"IsTruncated","output_token":"NextMarker || Contents[-1].Key","result_key":["Contents","CommonPrefixes"]},"ListObjectsV2":{"input_token":"ContinuationToken","limit_key":"MaxKeys","output_token":"NextContinuationToken","result_key":["Contents","CommonPrefixes"]},"ListParts":{"input_token":"PartNumberMarker","limit_key":"MaxParts","more_results":"IsTruncated","output_token":"NextPartNumberMarker","result_key":"Parts"}}}

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = {"version":2,"waiters":{"BucketExists":{"delay":5,"operation":"HeadBucket","maxAttempts":20,"acceptors":[{"expected":200,"matcher":"status","state":"success"},{"expected":301,"matcher":"status","state":"success"},{"expected":403,"matcher":"status","state":"success"},{"expected":404,"matcher":"status","state":"retry"}]},"BucketNotExists":{"delay":5,"operation":"HeadBucket","maxAttempts":20,"acceptors":[{"expected":404,"matcher":"status","state":"success"}]},"ObjectExists":{"delay":5,"operation":"HeadObject","maxAttempts":20,"acceptors":[{"expected":200,"matcher":"status","state":"success"},{"expected":404,"matcher":"status","state":"retry"}]},"ObjectNotExists":{"delay":5,"operation":"HeadObject","maxAttempts":20,"acceptors":[{"expected":404,"matcher":"status","state":"success"}]}}}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjcwN2ViNDBkZTAzNjhkMzY0MWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9zaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvc3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyX2xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9idWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9qc29uL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvam1lc3BhdGgvam1lc3BhdGguanMiLCJ3ZWJwYWNrOi8vL2ZzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9xdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0X3htbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEZWNsYXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTENvbW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERvY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9wYWdpbmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3Jlc291cmNlX3dhaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2h0dHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcXVlbnRpYWxfZXhlY3V0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjRfY3JlZGVudGlhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ibG9iLXVwbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvczMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9idWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MU3RyaW5naWZpZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFdmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFREQXR0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRERW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVERFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVEROb3RhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxUZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9hcGlfbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnX2RhdGEuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudF9saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc3RhdGVfbWFjaGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Jlc291cmNlX3dhaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy9yZXF1ZXN0X3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92Mi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92M2h0dHBzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3MzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3ByZXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3BhcmFtX3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL21ldGFkYXRhLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhMjU2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3RlbXBvcmFyeV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvc3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvc3RzLTIwMTEtMDYtMTUubWluLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9zdHMtMjAxMS0wNi0xNS5wYWdpbmF0b3JzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3dlYl9pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL2NvZ25pdG9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvY29nbml0b2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLm1pbi5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvc2FtbF9jcmVkZW50aWFscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2Jyb3dzZXJfcGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvczMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3MzL21hbmFnZWRfdXBsb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5taW4uanNvbiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEucGFnaW5hdG9ycy5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS53YWl0ZXJzMi5qc29uIl0sIm5hbWVzIjpbIlMzIiwicHJpdmF0ZVZhcnMiLCJXZWFrTWFwIiwiQmxvYlVwbG9hZGVyIiwiYXBpVXJsIiwiVHlwZUVycm9yIiwic2V0IiwidXJpIiwicHJvdG90eXBlIiwicmV0cmlldmVCbG9iVXJsIiwidXVpZCIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImdldCIsInZhcnMiLCJoYXNPd25Qcm9wZXJ0eSIsInJlcXVlc3QiLCJSZXF1ZXN0IiwibWV0aG9kIiwibW9kZSIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImFwaVJlc3BvbnNlIiwiZ2V0VXJsIiwiY2F0Y2giLCJlcnIiLCJ1cGxvYWRCbG9iIiwiYmxvYiIsInByb2dyZXNzRm4iLCJzMyIsImFjY2Vzc0tleUlkIiwiY3JlZGVudGlhbHMiLCJBY2Nlc3NLZXlJZCIsInNlY3JldEFjY2Vzc0tleSIsIlNlY3JldEFjY2Vzc0tleSIsInNlc3Npb25Ub2tlbiIsIlNlc3Npb25Ub2tlbiIsInJlZ2lvbiIsInBhcmFtcyIsIkJ1Y2tldCIsImJ1Y2tldCIsIktleSIsImlkIiwiQm9keSIsIm1hbmFnZWRVcGxvYWQiLCJ1cGxvYWQiLCJvbiIsImV2dCIsImxvYWRlZCIsInRvdGFsIiwicHJvbWlzZSIsImNhbmNlbCIsImFib3J0IiwidXBsb2FkSW1hZ2UiLCJpbWFnZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiaGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsIl90aGlzIiwicmVzb2x2ZSIsInRvQmxvYiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9COztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUssS0FBSztBQUM1RDtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxtQ0FBbUMsbUNBQW1DLEVBQUU7QUFDeEUsNkJBQTZCLDBCQUEwQixFQUFFO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QixFQUFFO0FBQ3pFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRCw4Q0FBOEMsRUFBRTtBQUNoRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE9BQU8saUNBQWlDO0FBQ3hDO0FBQ0EsT0FBTywyQkFBMkIsRUFBRSxLQUFLO0FBQ3pDO0FBQ0EsT0FBTywyQkFBMkIsRUFBRSxNQUFNO0FBQzFDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0IsRUFBRTtBQUMvRCx3Q0FBd0MsZUFBZSxFQUFFO0FBQ3pELG1DQUFtQyxxQ0FBcUMsRUFBRTtBQUMxRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFLDZDQUE2QyxpQkFBaUI7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsV0FBVztBQUNYLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7O0FDMVVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7QUN2THRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDLFdBQVcsRUFBRTtBQUM1RCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLEVBQUU7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxXQUFXLEVBQUU7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFdBQVcsRUFBRTtBQUM1RCx3Q0FBd0MsZUFBZTtBQUN2RCwwQ0FBMEMsZUFBZTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL1ZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsRUE7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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akI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1QkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7Ozs7QUNsb0R0RCxlOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7O0FDbk5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUM7Ozs7Ozs7QUMzTEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOzs7Ozs7O0FDekVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3RCQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OENDb0V5Qix1Qjs7Ozs7NEJBQUEsb0I7Ozs7Ozs7OzJCQUFiQSxFO0FBdkVaO0FBQ0E7O0FBRUEsTUFBTUMsY0FBYyxJQUFJQyxPQUFKLEVBQXBCOztBQUVBLFdBQVNDLFlBQVQsQ0FBdUJDLE1BQXZCLENBQThCLGFBQTlCLEVBQTZDO0FBQzNDLFFBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1gsWUFBTSxJQUFJQyxTQUFKLENBQWMscURBQWQsQ0FBTjtBQUNEO0FBQ0RKLGdCQUFZSyxHQUFaLENBQWdCLElBQWhCLEVBQXNCO0FBQ3BCQyxXQUFLSDtBQURlLEtBQXRCO0FBR0Q7O0FBRURELGVBQWFLLFNBQWIsQ0FBdUJDLGVBQXZCLEdBQXlDLFVBQ3ZDQyxJQUR1QyxDQUNsQztBQURrQyxJQUV2QyxzQkFBdUI7QUFDdkIsUUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFDVCxhQUFPQyxRQUFRQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLDRCQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELFFBQUksQ0FBQ1osV0FBRCxJQUFnQixDQUFDQSxZQUFZYSxHQUFaLENBQWdCLElBQWhCLENBQXJCLEVBQTRDO0FBQzFDLGFBQU9ILFFBQVFDLE1BQVIsQ0FBZSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBZixDQUFQO0FBQ0Q7QUFDRCxRQUFNRSxPQUFPZCxZQUFZYSxHQUFaLENBQWdCLElBQWhCLENBQWI7QUFDQSxRQUFJLENBQUNDLElBQUQsSUFBUyxDQUFDQSxLQUFLQyxjQUFMLENBQW9CLEtBQXBCLENBQWQsRUFBMEM7QUFDeEMsYUFBT0wsUUFBUUMsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNSSxVQUFVLElBQUlDLE9BQUosQ0FBWUgsS0FBS1IsR0FBTCxHQUFXLGVBQVgsR0FBNkJHLElBQXpDLEVBQStDO0FBQzdEUyxjQUFRLEtBRHFEO0FBRTdEQyxZQUFNO0FBRnVELEtBQS9DLENBQWhCOztBQUtBLFdBQU9DLE1BQU1KLE9BQU4sRUFDSkssSUFESSxDQUNDLFVBQUNDLFFBQUQsRUFBYztBQUNsQixVQUFJLENBQUNBLFNBQVNDLEVBQWQsRUFBa0I7QUFDaEIsZUFBT2IsUUFBUUMsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVVUsU0FBU0UsTUFBVCxHQUFrQixHQUFsQixHQUF3QkYsU0FBU0csVUFBM0MsQ0FBZixDQUFQO0FBQ0Q7QUFDRCxhQUFPSCxTQUFTSSxJQUFULEVBQVA7QUFDRCxLQU5JLEVBT0pMLElBUEksQ0FPQyxVQUFDTSxXQUFEO0FBQUEsYUFBaUJBLFlBQVlDLE1BQTdCO0FBQUEsS0FQRCxFQVFKQyxLQVJJLENBUUUsVUFBQ0MsR0FBRDtBQUFBLGFBQVNwQixRQUFRQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLGdDQUFnQ2tCLEdBQTFDLENBQWYsQ0FBVDtBQUFBLEtBUkYsQ0FBUDtBQVNELEdBN0JEOztBQStCQTVCLGVBQWFLLFNBQWIsQ0FBdUJ3QixVQUF2QixHQUFvQyxVQUNsQ0MsSUFEa0MsQ0FDN0I7QUFENkIsSUFFbENDLFVBRmtDLENBRXZCO0FBRnVCLElBR2xDLHNCQUF1QjtBQUN2QixRQUFJLENBQUNELElBQUwsRUFBVztBQUNULGFBQU90QixRQUFRQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLDRCQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELFFBQU1FLE9BQU9kLFlBQVlhLEdBQVosQ0FBZ0IsSUFBaEIsQ0FBYjtBQUNBLFFBQUksQ0FBQ0MsSUFBRCxJQUFTLENBQUNBLEtBQUtDLGNBQUwsQ0FBb0IsS0FBcEIsQ0FBZCxFQUEwQztBQUN4QyxhQUFPTCxRQUFRQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLGlDQUFWLENBQWYsQ0FBUDtBQUNEOztBQUVELFFBQU1JLFVBQVUsSUFBSUMsT0FBSixDQUFZSCxLQUFLUixHQUFMLEdBQVcseUJBQXZCLEVBQWtEO0FBQ2hFWSxjQUFRLEtBRHdEO0FBRWhFQyxZQUFNO0FBRjBELEtBQWxELENBQWhCOztBQUtBLFdBQU9DLE1BQU1KLE9BQU4sRUFDSkssSUFESSxDQUNDLFVBQUNDLFFBQUQsRUFBYztBQUNsQixVQUFJLENBQUNBLFNBQVNDLEVBQWQsRUFBa0I7QUFDaEIsZUFBT2IsUUFBUUMsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVVUsU0FBU0UsTUFBVCxHQUFrQixHQUFsQixHQUF3QkYsU0FBU0csVUFBM0MsQ0FBZixDQUFQO0FBQ0Q7QUFDRCxhQUFPSCxTQUFTSSxJQUFULEVBQVA7QUFDRCxLQU5JLEVBT0pMLElBUEksQ0FPQyxVQUFDTSxXQUFELEVBQWlCO0FBRXJCLFVBQU1PLEtBQUssSUFBSW5DLEVBQUosQ0FBTztBQUNoQm9DLHFCQUFhUixZQUFZUyxXQUFaLENBQXdCQyxXQURyQjtBQUVoQkMseUJBQWlCWCxZQUFZUyxXQUFaLENBQXdCRyxlQUZ6QjtBQUdoQkMsc0JBQWNiLFlBQVlTLFdBQVosQ0FBd0JLLFlBSHRCO0FBSWhCQyxnQkFBUWYsWUFBWWU7QUFKSixPQUFQLENBQVg7QUFNQSxVQUFNQyxTQUFTO0FBQ2JDLGdCQUFRakIsWUFBWWtCLE1BRFA7QUFFYkMsYUFBS25CLFlBQVlvQixFQUZKO0FBR2JDLGNBQU1oQjtBQUhPLE9BQWY7QUFLQSxVQUFNaUIsZ0JBQWdCZixHQUFHZ0IsTUFBSCxDQUFVUCxNQUFWLENBQXRCO0FBQ0EsVUFBSVYsVUFBSixFQUFnQjtBQUNkZ0Isc0JBQWNFLEVBQWQsQ0FBaUIsb0JBQWpCLEVBQXVDLFVBQUNDLEdBQUQsRUFBUztBQUM5Q25CLHFCQUFXbUIsSUFBSUMsTUFBZixFQUF1QkQsSUFBSUUsS0FBM0I7QUFDRCxTQUZEO0FBR0Q7QUFDRCxhQUFPO0FBQ0xKLGdCQUFRO0FBQUEsaUJBQU1ELGNBQWNNLE9BQWQsRUFBTjtBQUFBLFNBREg7QUFFTEMsZ0JBQVE7QUFBQSxpQkFBTVAsY0FBY1EsS0FBZCxFQUFOO0FBQUEsU0FGSDtBQUdMVixZQUFJcEIsWUFBWW9CO0FBSFgsT0FBUDtBQUtELEtBL0JJLEVBZ0NKbEIsS0FoQ0ksQ0FnQ0UsVUFBQ0MsR0FBRDtBQUFBLGFBQVNwQixRQUFRQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLDRCQUE0QmtCLEdBQXRDLENBQWYsQ0FBVDtBQUFBLEtBaENGLENBQVA7QUFpQ0QsR0FuREQ7O0FBcURBNUIsZUFBYUssU0FBYixDQUF1Qm1ELFdBQXZCLEdBQXFDLFVBQ25DQyxLQURtQyxDQUM3QjtBQUQ2QixJQUVuQzFCLFVBRm1DLENBRXhCO0FBRndCLElBR25DLHNCQUF1QjtBQUN2QixRQUFJLENBQUMwQixLQUFMLEVBQVk7QUFDVixhQUFPakQsUUFBUUMsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVSw2QkFBVixDQUFmLENBQVA7QUFDRDs7QUFFRCxRQUFNRSxPQUFPZCxZQUFZYSxHQUFaLENBQWdCLElBQWhCLENBQWI7QUFDQSxRQUFJLENBQUNDLElBQUQsSUFBUyxDQUFDQSxLQUFLQyxjQUFMLENBQW9CLEtBQXBCLENBQWQsRUFBMEM7QUFDeEMsYUFBT0wsUUFBUUMsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFmLENBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQU1nRCxTQUFTQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQUYsV0FBT0csS0FBUCxHQUFlSixNQUFNSSxLQUFyQjtBQUNBSCxXQUFPSSxNQUFQLEdBQWdCTCxNQUFNSyxNQUF0Qjs7QUFFQTtBQUNBLFFBQU1DLE1BQU1MLE9BQU9NLFVBQVAsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBRCxRQUFJRSxTQUFKLENBQWNSLEtBQWQsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEI7QUFDQSxRQUFNUyxRQUFRLElBQWQ7O0FBRUEsV0FBTyxJQUFJMUQsT0FBSixDQUFZLFVBQUMyRCxPQUFELEVBQVUxRCxNQUFWLEVBQXFCO0FBQ3RDaUQsYUFBT1UsTUFBUCxDQUFjLFVBQUN0QyxJQUFELEVBQVU7QUFDdEJxQyxnQkFBUUQsTUFBTXJDLFVBQU4sQ0FBaUJDLElBQWpCLEVBQXVCQyxVQUF2QixDQUFSO0FBQ0QsT0FGRDtBQUdELEtBSk0sQ0FBUDtBQUtELEdBNUJEOztBQThCQXNDLFNBQU9DLE9BQVAsR0FBaUJ0RSxZQUFqQjs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNuQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDekxEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Es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Q0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7Ozs7Ozs7O0FDckJBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7O0FDcEVEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsZ0NBQWdDLEdBQUcsRUFBRTtBQUNwRixnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQzs7Ozs7OztBQ25FRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUM7Ozs7Ozs7QUNuRkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7O0FDN0NEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsQ0FBQzs7Ozs7OztBQ3ZERDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEJBQTBCLHlEQUF5RCxFQUFFLGtCQUFrQiwwQkFBMEIsRUFBRSxtQ0FBbUMsOEJBQThCLG9DQUFvQyxjQUFjLEVBQUU7QUFDOVIsZ0JBQWdCOztBQUVoQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDOzs7Ozs7O0FDaEREO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEIseURBQXlELEVBQUUsa0JBQWtCLDBCQUEwQixFQUFFLG1DQUFtQyw4QkFBOEIsb0NBQW9DLGNBQWMsRUFBRTtBQUM5UixnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILENBQUM7Ozs7Ozs7QUNoREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUIsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixxQkFBcUIsUUFBUTtBQUM3QixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ3prQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNCQUFzQjtBQUM1QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZCQUE2QjtBQUM5RCwyQ0FBMkMsd0JBQXdCLEVBQUU7QUFDckU7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlELG9EQUFvRCxNQUFNLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0EscUNBQXFDLE1BQU0sbUJBQW1CLE1BQU07QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksRUFBRTtBQUNqRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZLEVBQUU7QUFDckQ7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZEQUE2RCxhQUFhO0FBQzFFLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYSxhQUFhO0FBQy9ELGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDcHlCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLEdBQUc7QUFDSCxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssWUFBWSxnQkFBZ0I7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQ3hNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUMzTUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUM1Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLG1FQUFtRSxFQUFFOztBQUVyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7Ozs7Ozs7QUNsTkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7OztBQzlCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzREMzdEJBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUMscUJBQXFCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFDSCxFQUFFO0FBQ0Ysc0NBQXNDO0FBQ3RDO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU87QUFDVDtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7OztBQ2poQkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BGQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QixJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUIsS0FBSyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRCxNQUFNLHdCQUF3QjtBQUM5Qix5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9COztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTs7QUFFQSxDQUFDOzs7Ozs7O0FDdkhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xELHdEQUF3RCxrQkFBa0I7QUFDMUUsVUFBVSxnQkFBZ0IsR0FBRyxXQUFXLE1BQU0sMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDOUNELGtCQUFrQiw0QkFBNEIsa1NBQWtTLGVBQWUsY0FBYyxTQUFTLHVFQUF1RSxZQUFZLHFCQUFxQixZQUFZLG9CQUFvQixpQkFBaUIsZ0JBQWdCLGtCQUFrQixpQkFBaUIsV0FBVyxpRUFBaUUsZUFBZSxhQUFhLG9CQUFvQixhQUFhLHFCQUFxQixvQkFBb0IsdUJBQXVCLFNBQVMsb0ZBQW9GLFlBQVksa0JBQWtCLG1CQUFtQixZQUFZLG9CQUFvQixtQkFBbUIsV0FBVyx5RUFBeUUsZUFBZSxhQUFhLG9CQUFvQixhQUFhLHFCQUFxQixpQkFBaUIsYUFBYSxpQkFBaUIsWUFBWSxjQUFjLHNCQUFzQiw4QkFBOEIsU0FBUywwRkFBMEYsWUFBWSxxQkFBcUIsc0JBQXNCLGdCQUFnQixZQUFZLG9CQUFvQixtQkFBbUIsV0FBVyxnRkFBZ0YsZUFBZSxhQUFhLGlDQUFpQyxvQkFBb0IsYUFBYSxxQkFBcUIsaUJBQWlCLGNBQWMsaUJBQWlCLCtCQUErQixTQUFTLDREQUE0RCxxQkFBcUIsV0FBVyxpRkFBaUYsc0JBQXNCLHNCQUFzQixTQUFTLGdDQUFnQyxXQUFXLHdFQUF3RSxXQUFXLGFBQWEsWUFBWSx1QkFBdUIsU0FBUyxrREFBa0QsU0FBUyxZQUFZLG9CQUFvQixtQkFBbUIsV0FBVyx5RUFBeUUsZUFBZSxhQUFhLGtCQUFrQixtRUFBbUUsb0JBQW9CLFdBQVcscUJBQXFCLG9CQUFvQixvQkFBb0IsU0FBUyw4QkFBOEIsbUJBQW1CLGlCQUFpQixrQkFBa0IsaUJBQWlCLFdBQVcsc0VBQXNFLGVBQWUsaUJBQWlCLFdBQVcsTUFBTSx1R0FBdUcsZ0JBQWdCLHFCQUFxQixrQkFBa0IsZUFBZSxxQkFBcUIsT0FBTyxpRUFBaUUsa0JBQWtCLGE7Ozs7OztBQ0F0aUcsa0JBQWtCLGdCOzs7Ozs7QUNBbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsR0FBRzs7QUFFSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9COztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQzdHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOENBQThDO0FBQ2xEO0FBQ0EsNkNBQTZDLDBCQUEwQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQ0FBa0M7QUFDdEMsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsbUNBQW1DO0FBQzNDLFFBQVEsa0NBQWtDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOENBQThDO0FBQ3RELFFBQVEsa0NBQWtDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUNBQW1DO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLGtDQUFrQyw4Q0FBOEM7QUFDaEYsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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OztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN1NBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RCx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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Q1Q7QUFDQSxLQUFLLFlBQVk7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FB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b0QsRUFBRSxvREFBb0QsRUFBRSxrREFBa0QsRUFBRSxvQkFBb0Isa0VBQWtFLG9EQUFvRCxFQUFFLGlCQUFpQixrRUFBa0Usb0RBQW9ELEVBQUUsa0RBQWtELEVBQUUsb0JBQW9CLGtFQUFrRSxvREFBb0QsSSIsImZpbGUiOiJibS1ibG9iLXVwbG9hZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGY3MDdlYjQwZGUwMzY4ZDM2NDFlIiwiLyoqXG4gKiBUaGUgbWFpbiBBV1MgbmFtZXNwYWNlXG4gKi9cbnZhciBBV1MgPSB7IHV0aWw6IHJlcXVpcmUoJy4vdXRpbCcpIH07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAIW1hY3JvIFtuZXddIG5vYnJvd3NlclxuICogICBAbm90ZSBUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvZiB0aGUgU0RLLlxuICovXG52YXIgX2hpZGRlbiA9IHt9OyBfaGlkZGVuLnRvU3RyaW5nKCk7IC8vIGhhY2sgdG8gcGFyc2UgbWFjcm9cblxubW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MsIHtcblxuICAvKipcbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBWRVJTSU9OOiAnMi4xMDAuMCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgU2lnbmVyczoge30sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgUHJvdG9jb2w6IHtcbiAgICBKc29uOiByZXF1aXJlKCcuL3Byb3RvY29sL2pzb24nKSxcbiAgICBRdWVyeTogcmVxdWlyZSgnLi9wcm90b2NvbC9xdWVyeScpLFxuICAgIFJlc3Q6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdCcpLFxuICAgIFJlc3RKc29uOiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfanNvbicpLFxuICAgIFJlc3RYbWw6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF94bWwnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFhNTDoge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4veG1sL2J1aWxkZXInKSxcbiAgICBQYXJzZXI6IG51bGwgLy8gY29uZGl0aW9uYWxseSBzZXQgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBKU09OOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9qc29uL2J1aWxkZXInKSxcbiAgICBQYXJzZXI6IHJlcXVpcmUoJy4vanNvbi9wYXJzZXInKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIE1vZGVsOiB7XG4gICAgQXBpOiByZXF1aXJlKCcuL21vZGVsL2FwaScpLFxuICAgIE9wZXJhdGlvbjogcmVxdWlyZSgnLi9tb2RlbC9vcGVyYXRpb24nKSxcbiAgICBTaGFwZTogcmVxdWlyZSgnLi9tb2RlbC9zaGFwZScpLFxuICAgIFBhZ2luYXRvcjogcmVxdWlyZSgnLi9tb2RlbC9wYWdpbmF0b3InKSxcbiAgICBSZXNvdXJjZVdhaXRlcjogcmVxdWlyZSgnLi9tb2RlbC9yZXNvdXJjZV93YWl0ZXInKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaUxvYWRlcjogcmVxdWlyZSgnLi9hcGlfbG9hZGVyJylcbn0pO1xuXG5yZXF1aXJlKCcuL3NlcnZpY2UnKTtcbnJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnJlcXVpcmUoJy4vaHR0cCcpO1xucmVxdWlyZSgnLi9zZXF1ZW50aWFsX2V4ZWN1dG9yJyk7XG5yZXF1aXJlKCcuL2V2ZW50X2xpc3RlbmVycycpO1xucmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5yZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5yZXF1aXJlKCcuL3Jlc291cmNlX3dhaXRlcicpO1xucmVxdWlyZSgnLi9zaWduZXJzL3JlcXVlc3Rfc2lnbmVyJyk7XG5yZXF1aXJlKCcuL3BhcmFtX3ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEByZWFkb25seVxuICogQHJldHVybiBbQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl0gYSBjb2xsZWN0aW9uIG9mIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdGhhdFxuICogICBhcmUgYXR0YWNoZWQgdG8gZXZlcnkgc2VudCByZXF1ZXN0LlxuICogQHNlZSBBV1MuUmVxdWVzdCBBV1MuUmVxdWVzdCBmb3IgYSBsaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yXG4gKiBAZXhhbXBsZSBMb2dnaW5nIHRoZSB0aW1lIHRha2VuIHRvIHNlbmQgYSByZXF1ZXN0XG4gKiAgIEFXUy5ldmVudHMub24oJ3NlbmQnLCBmdW5jdGlvbiBzdGFydFNlbmQocmVzcCkge1xuICogICAgIHJlc3Auc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gKiAgIH0pLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbWUocmVzcCkge1xuICogICAgIHZhciB0aW1lID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzcC5zdGFydFRpbWUpIC8gMTAwMDtcbiAqICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCB0b29rICcgKyB0aW1lICsgJyBzZWNvbmRzJyk7XG4gKiAgIH0pO1xuICpcbiAqICAgbmV3IEFXUy5TMygpLmxpc3RCdWNrZXRzKCk7IC8vIHByaW50cyAnUmVxdWVzdCB0b29rIDAuMjg1IHNlY29uZHMnXG4gKi9cbkFXUy5ldmVudHMgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGVzbGludCBndWFyZC1mb3ItaW46MCAqL1xudmFyIEFXUztcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgZm9yIHVzZSB3aXRoIHRoZSBBV1MgU0RLLlxuICpcbiAqIEAhYXR0cmlidXRlIGFib3J0XG4gKiAgIFJldHVybiB0aGlzIHZhbHVlIGZyb20gYW4gaXRlcmF0b3IgZnVuY3Rpb24ge2VhY2h9IG9yIHthcnJheUVhY2h9XG4gKiAgIHRvIGJyZWFrIG91dCBvZiB0aGUgaXRlcmF0aW9uLlxuICogICBAZXhhbXBsZSBCcmVha2luZyBvdXQgb2YgYW4gaXRlcmF0b3IgZnVuY3Rpb25cbiAqICAgICBBV1MudXRpbC5lYWNoKHthOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICogICAgICAgaWYgKGtleSA9PSAnYicpIHJldHVybiBBV1MudXRpbC5hYm9ydDtcbiAqICAgICB9KTtcbiAqICAgQHNlZSBlYWNoXG4gKiAgIEBzZWUgYXJyYXlFYWNoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIHV0aWwgPSB7XG4gIGVudmlyb25tZW50OiAnbm9kZWpzJyxcbiAgZW5naW5lOiBmdW5jdGlvbiBlbmdpbmUoKSB7XG4gICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5naW5lID0gcHJvY2Vzcy5wbGF0Zm9ybSArICcvJyArIHByb2Nlc3MudmVyc2lvbjtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5BV1NfRVhFQ1VUSU9OX0VOVikge1xuICAgICAgICBlbmdpbmUgKz0gJyBleGVjLWVudi8nICsgcHJvY2Vzcy5lbnYuQVdTX0VYRUNVVElPTl9FTlY7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5naW5lO1xuICAgIH1cbiAgfSxcblxuICB1c2VyQWdlbnQ6IGZ1bmN0aW9uIHVzZXJBZ2VudCgpIHtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZW52aXJvbm1lbnQ7XG4gICAgdmFyIGFnZW50ID0gJ2F3cy1zZGstJyArIG5hbWUgKyAnLycgKyByZXF1aXJlKCcuL2NvcmUnKS5WRVJTSU9OO1xuICAgIGlmIChuYW1lID09PSAnbm9kZWpzJykgYWdlbnQgKz0gJyAnICsgdXRpbC5lbmdpbmUoKTtcbiAgICByZXR1cm4gYWdlbnQ7XG4gIH0sXG5cbiAgaXNCcm93c2VyOiBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7IHJldHVybiBwcm9jZXNzICYmIHByb2Nlc3MuYnJvd3NlcjsgfSxcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7IHJldHVybiAhdXRpbC5pc0Jyb3dzZXIoKTsgfSxcbiAgdXJpRXNjYXBlOiBmdW5jdGlvbiB1cmlFc2NhcGUoc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpO1xuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOV8uflxcLSVdKy9nLCBlc2NhcGUpO1xuXG4gICAgLy8gQVdTIHBlcmNlbnQtZW5jb2RlcyBzb21lIGV4dHJhIG5vbi1zdGFuZGFyZCBjaGFyYWN0ZXJzIGluIGEgVVJJXG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1sqXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuICclJyArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIHVyaUVzY2FwZVBhdGg6IGZ1bmN0aW9uIHVyaUVzY2FwZVBhdGgoc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goc3RyaW5nLnNwbGl0KCcvJyksIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKHBhcnQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xuICB9LFxuXG4gIHVybFBhcnNlOiBmdW5jdGlvbiB1cmxQYXJzZSh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwucGFyc2UodXJsKTtcbiAgfSxcblxuICB1cmxGb3JtYXQ6IGZ1bmN0aW9uIHVybEZvcm1hdCh1cmwpIHtcbiAgICByZXR1cm4gdXRpbC51cmwuZm9ybWF0KHVybCk7XG4gIH0sXG5cbiAgcXVlcnlTdHJpbmdQYXJzZTogZnVuY3Rpb24gcXVlcnlTdHJpbmdQYXJzZShxcykge1xuICAgIHJldHVybiB1dGlsLnF1ZXJ5c3RyaW5nLnBhcnNlKHFzKTtcbiAgfSxcblxuICBxdWVyeVBhcmFtc1RvU3RyaW5nOiBmdW5jdGlvbiBxdWVyeVBhcmFtc1RvU3RyaW5nKHBhcmFtcykge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBlc2NhcGUgPSB1dGlsLnVyaUVzY2FwZTtcbiAgICB2YXIgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpO1xuXG4gICAgdXRpbC5hcnJheUVhY2goc29ydGVkS2V5cywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgICAgdmFyIGVuYW1lID0gZXNjYXBlKG5hbWUpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVuYW1lICsgJz0nO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIHV0aWwuYXJyYXlFYWNoKHZhbHVlLCBmdW5jdGlvbihpdGVtKSB7IHZhbHMucHVzaChlc2NhcGUoaXRlbSkpOyB9KTtcbiAgICAgICAgcmVzdWx0ID0gZW5hbWUgKyAnPScgKyB2YWxzLnNvcnQoKS5qb2luKCcmJyArIGVuYW1lICsgJz0nKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBlbmFtZSArICc9JyArIGVzY2FwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXMuam9pbignJicpO1xuICB9LFxuXG4gIHJlYWRGaWxlU3luYzogZnVuY3Rpb24gcmVhZEZpbGVTeW5jKHBhdGgpIHtcbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHBhdGgsICd1dGYtOCcpO1xuICB9LFxuXG4gIGJhc2U2NDoge1xuICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlNjQoc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBiYXNlNjQgZW5jb2RlIG51bWJlciAnICsgc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgYnVmID0gKHR5cGVvZiB1dGlsLkJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmIHV0aWwuQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkgPyB1dGlsLkJ1ZmZlci5mcm9tKHN0cmluZykgOiBuZXcgdXRpbC5CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0sXG5cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZTY0KHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgYmFzZTY0IGRlY29kZSBudW1iZXIgJyArIHN0cmluZykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0eXBlb2YgdXRpbC5CdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsLkJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pID8gdXRpbC5CdWZmZXIuZnJvbShzdHJpbmcsICdiYXNlNjQnKSA6IG5ldyB1dGlsLkJ1ZmZlcihzdHJpbmcsICdiYXNlNjQnKTtcbiAgICB9XG5cbiAgfSxcblxuICBidWZmZXI6IHtcbiAgICB0b1N0cmVhbTogZnVuY3Rpb24gdG9TdHJlYW0oYnVmZmVyKSB7XG4gICAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIGJ1ZmZlciA9IG5ldyB1dGlsLkJ1ZmZlcihidWZmZXIpO1xuXG4gICAgICB2YXIgcmVhZGFibGUgPSBuZXcgKHV0aWwuc3RyZWFtLlJlYWRhYmxlKSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICByZWFkYWJsZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgaWYgKHBvcyA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gcmVhZGFibGUucHVzaChudWxsKTtcblxuICAgICAgICB2YXIgZW5kID0gcG9zICsgc2l6ZTtcbiAgICAgICAgaWYgKGVuZCA+IGJ1ZmZlci5sZW5ndGgpIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHJlYWRhYmxlLnB1c2goYnVmZmVyLnNsaWNlKHBvcywgZW5kKSk7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZWFkYWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIGEgbGlzdCBvZiBCdWZmZXIgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBjb25jYXQ6IGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSAwLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgYnVmZmVyID0gbnVsbCwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgPSBuZXcgdXRpbC5CdWZmZXIobGVuZ3RoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmZmVyc1tpXS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfSxcblxuICBzdHJpbmc6IHtcbiAgICBieXRlTGVuZ3RoOiBmdW5jdGlvbiBieXRlTGVuZ3RoKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHN0cmluZyA9IG5ldyB1dGlsLkJ1ZmZlcihzdHJpbmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZy5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmluZy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNpemU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykubHN0YXRTeW5jKHN0cmluZy5wYXRoKS5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlcm1pbmUgbGVuZ3RoIG9mICcgKyBzdHJpbmcpLFxuICAgICAgICAgIHsgb2JqZWN0OiBzdHJpbmcgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwcGVyRmlyc3Q6IGZ1bmN0aW9uIHVwcGVyRmlyc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyKDEpO1xuICAgIH0sXG5cbiAgICBsb3dlckZpcnN0OiBmdW5jdGlvbiBsb3dlckZpcnN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZ1swXS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pOiB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHN0cmluZyhpbmkpIHtcbiAgICAgIHZhciBjdXJyZW50U2VjdGlvbiwgbWFwID0ge307XG4gICAgICB1dGlsLmFycmF5RWFjaChpbmkuc3BsaXQoL1xccj9cXG4vKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBsaW5lID0gbGluZS5zcGxpdCgvKF58XFxzKVs7I10vKVswXTsgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgIHZhciBzZWN0aW9uID0gbGluZS5tYXRjaCgvXlxccypcXFsoW15cXFtcXF1dKylcXF1cXHMqJC8pO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2VjdGlvbikge1xuICAgICAgICAgIHZhciBpdGVtID0gbGluZS5tYXRjaCgvXlxccyooLis/KVxccyo9XFxzKiguKz8pXFxzKiQvKTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbWFwW2N1cnJlbnRTZWN0aW9uXSA9IG1hcFtjdXJyZW50U2VjdGlvbl0gfHwge307XG4gICAgICAgICAgICBtYXBbY3VycmVudFNlY3Rpb25dW2l0ZW1bMV1dID0gaXRlbVsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSxcblxuICBmbjoge1xuICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBUdXJuIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBhcyBcImFzeW5jXCIgZnVuY3Rpb24gYnkgbWFraW5nIGl0IGNhbGxcbiAgICAgKiBhIGNhbGxiYWNrLiBUaGUgdW5kZXJseWluZyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhbGwgYnV0IHRoZSBsYXN0IGFyZ3VtZW50LFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHBhc3NlZCBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogb2YgbnVsbCBvbiBzdWNjZXNzIHRvIG1pbWljayBzdGFuZGFyZCBub2RlIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBtYWtlQXN5bmM6IGZ1bmN0aW9uIG1ha2VBc3luYyhmbiwgZXhwZWN0ZWRBcmdzKSB7XG4gICAgICBpZiAoZXhwZWN0ZWRBcmdzICYmIGV4cGVjdGVkQXJncyA8PSBmbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERhdGUgYW5kIHRpbWUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAqL1xuICBkYXRlOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtEYXRlXSB0aGUgY3VycmVudCBKYXZhU2NyaXB0IGRhdGUgb2JqZWN0LiBTaW5jZSBhbGxcbiAgICAgKiAgIEFXUyBzZXJ2aWNlcyByZWx5IG9uIHRoaXMgZGF0ZSBvYmplY3QsIHlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiAgIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBhIHNwZWNpYWwgdGltZSB2YWx1ZSB0byBBV1Mgc2VydmljZVxuICAgICAqICAgcmVxdWVzdHMuXG4gICAgICovXG4gICAgZ2V0RGF0ZTogZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgICAgIGlmICghQVdTKSBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbiAgICAgIGlmIChBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KSB7IC8vIHVzZSBvZmZzZXQgd2hlbiBub24temVyb1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyBBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRlIGluIElTTy04NjAxIGZvcm1hdFxuICAgICAqL1xuICAgIGlzbzg2MDE6IGZ1bmN0aW9uIGlzbzg2MDEoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9cXC5cXGR7M31aJC8sICdaJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIGRhdGUgaW4gUkZDIDgyMiBmb3JtYXRcbiAgICAgKi9cbiAgICByZmM4MjI6IGZ1bmN0aW9uIHJmYzgyMihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgVU5JWCB0aW1lc3RhbXAgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgICB1bml4VGltZXN0YW1wOiBmdW5jdGlvbiB1bml4VGltZXN0YW1wKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbU3RyaW5nLG51bWJlcixEYXRlXSBkYXRlXG4gICAgICogQHJldHVybiBbRGF0ZV1cbiAgICAgKi9cbiAgICBmcm9tOiBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSAqIDEwMDApOyAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIERhdGUgb3IgZGF0ZS1saWtlIHZhbHVlLCB0aGlzIGZ1bmN0aW9uIGZvcm1hdHMgdGhlXG4gICAgICogZGF0ZSBpbnRvIGEgc3RyaW5nIG9mIHRoZSByZXF1ZXN0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIFtTdHJpbmcsbnVtYmVyLERhdGVdIGRhdGVcbiAgICAgKiBAcGFyYW0gW1N0cmluZ10gZm9ybWF0dGVyIFZhbGlkIGZvcm1hdHMgYXJlOlxuICAgICAjICAgKiAnaXNvODYwMSdcbiAgICAgIyAgICogJ3JmYzgyMidcbiAgICAgIyAgICogJ3VuaXhUaW1lc3RhbXAnXG4gICAgICogQHJldHVybiBbU3RyaW5nXVxuICAgICAqL1xuICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KGRhdGUsIGZvcm1hdHRlcikge1xuICAgICAgaWYgKCFmb3JtYXR0ZXIpIGZvcm1hdHRlciA9ICdpc284NjAxJztcbiAgICAgIHJldHVybiB1dGlsLmRhdGVbZm9ybWF0dGVyXSh1dGlsLmRhdGUuZnJvbShkYXRlKSk7XG4gICAgfSxcblxuICAgIHBhcnNlVGltZXN0YW1wOiBmdW5jdGlvbiBwYXJzZVRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsgLy8gdW5peCB0aW1lc3RhbXAgKG51bWJlcilcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFxkKyQvKSkgeyAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUgKiAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubWF0Y2goL15cXGR7NH0vKSkgeyAvLyBpc284NjAxXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFx3ezN9LC8pKSB7IC8vIHJmYzgyMlxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihcbiAgICAgICAgICBuZXcgRXJyb3IoJ3VuaGFuZGxlZCB0aW1lc3RhbXAgZm9ybWF0OiAnICsgdmFsdWUpLFxuICAgICAgICAgIHtjb2RlOiAnVGltZXN0YW1wUGFyc2VyRXJyb3InfSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0sXG5cbiAgY3J5cHRvOiB7XG4gICAgY3JjMzJUYWJsZTogW1xuICAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweEVFMEU2MTJDLCAweDk5MDk1MUJBLCAweDA3NkRDNDE5LFxuICAgICAweDcwNkFGNDhGLCAweEU5NjNBNTM1LCAweDlFNjQ5NUEzLCAweDBFREI4ODMyLCAweDc5RENCOEE0LFxuICAgICAweEUwRDVFOTFFLCAweDk3RDJEOTg4LCAweDA5QjY0QzJCLCAweDdFQjE3Q0JELCAweEU3QjgyRDA3LFxuICAgICAweDkwQkYxRDkxLCAweDFEQjcxMDY0LCAweDZBQjAyMEYyLCAweEYzQjk3MTQ4LCAweDg0QkU0MURFLFxuICAgICAweDFBREFENDdELCAweDZERERFNEVCLCAweEY0RDRCNTUxLCAweDgzRDM4NUM3LCAweDEzNkM5ODU2LFxuICAgICAweDY0NkJBOEMwLCAweEZENjJGOTdBLCAweDhBNjVDOUVDLCAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LFxuICAgICAweEZBMEYzRDYzLCAweDhEMDgwREY1LCAweDNCNkUyMEM4LCAweDRDNjkxMDVFLCAweEQ1NjA0MUU0LFxuICAgICAweEEyNjc3MTcyLCAweDNDMDNFNEQxLCAweDRCMDRENDQ3LCAweEQyMEQ4NUZELCAweEE1MEFCNTZCLFxuICAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLCAweDMyRDg2Q0UzLFxuICAgICAweDQ1REY1Qzc1LCAweERDRDYwRENGLCAweEFCRDEzRDU5LCAweDI2RDkzMEFDLCAweDUxREUwMDNBLFxuICAgICAweEM4RDc1MTgwLCAweEJGRDA2MTE2LCAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LFxuICAgICAweEI4QkRBNTBGLCAweDI4MDJCODlFLCAweDVGMDU4ODA4LCAweEM2MENEOUIyLCAweEIxMEJFOTI0LFxuICAgICAweDJGNkY3Qzg3LCAweDU4Njg0QzExLCAweEMxNjExREFCLCAweEI2NjYyRDNELCAweDc2REM0MTkwLFxuICAgICAweDAxREI3MTA2LCAweDk4RDIyMEJDLCAweEVGRDUxMDJBLCAweDcxQjE4NTg5LCAweDA2QjZCNTFGLFxuICAgICAweDlGQkZFNEE1LCAweEU4QjhENDMzLCAweDc4MDdDOUEyLCAweDBGMDBGOTM0LCAweDk2MDlBODhFLFxuICAgICAweEUxMEU5ODE4LCAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLFxuICAgICAweDZCNkI1MUY0LCAweDFDNkM2MTYyLCAweDg1NjUzMEQ4LCAweEYyNjIwMDRFLCAweDZDMDY5NUVELFxuICAgICAweDFCMDFBNTdCLCAweDgyMDhGNEMxLCAweEY1MEZDNDU3LCAweDY1QjBEOUM2LCAweDEyQjdFOTUwLFxuICAgICAweDhCQkVCOEVBLCAweEZDQjk4ODdDLCAweDYyREQxRERGLCAweDE1REEyRDQ5LCAweDhDRDM3Q0YzLFxuICAgICAweEZCRDQ0QzY1LCAweDREQjI2MTU4LCAweDNBQjU1MUNFLCAweEEzQkMwMDc0LCAweEQ0QkIzMEUyLFxuICAgICAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLCAweDQzNjlFOTZBLFxuICAgICAweDM0NkVEOUZDLCAweEFENjc4ODQ2LCAweERBNjBCOEQwLCAweDQ0MDQyRDczLCAweDMzMDMxREU1LFxuICAgICAweEFBMEE0QzVGLCAweEREMEQ3Q0M5LCAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLFxuICAgICAweEM5MEMyMDg2LCAweDU3NjhCNTI1LCAweDIwNkY4NUIzLCAweEI5NjZENDA5LCAweENFNjFFNDlGLFxuICAgICAweDVFREVGOTBFLCAweDI5RDlDOTk4LCAweEIwRDA5ODIyLCAweEM3RDdBOEI0LCAweDU5QjMzRDE3LFxuICAgICAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELCAweEVEQjg4MzIwLCAweDlBQkZCM0I2LFxuICAgICAweDAzQjZFMjBDLCAweDc0QjFEMjlBLCAweEVBRDU0NzM5LCAweDlERDI3N0FGLCAweDA0REIyNjE1LFxuICAgICAweDczREMxNjgzLCAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LFxuICAgICAweEU0MEVDRjBCLCAweDkzMDlGRjlELCAweDBBMDBBRTI3LCAweDdEMDc5RUIxLCAweEYwMEY5MzQ0LFxuICAgICAweDg3MDhBM0QyLCAweDFFMDFGMjY4LCAweDY5MDZDMkZFLCAweEY3NjI1NzVELCAweDgwNjU2N0NCLFxuICAgICAweDE5NkMzNjcxLCAweDZFNkIwNkU3LCAweEZFRDQxQjc2LCAweDg5RDMyQkUwLCAweDEwREE3QTVBLFxuICAgICAweDY3REQ0QUNDLCAweEY5QjlERjZGLCAweDhFQkVFRkY5LCAweDE3QjdCRTQzLCAweDYwQjA4RUQ1LFxuICAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLCAweEQxQkI2N0YxLFxuICAgICAweEE2QkM1NzY3LCAweDNGQjUwNkRELCAweDQ4QjIzNjRCLCAweEQ4MEQyQkRBLCAweEFGMEExQjRDLFxuICAgICAweDM2MDM0QUY2LCAweDQxMDQ3QTYwLCAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLFxuICAgICAweDQ2NjlCRTc5LCAweENCNjFCMzhDLCAweEJDNjY4MzFBLCAweDI1NkZEMkEwLCAweDUyNjhFMjM2LFxuICAgICAweENDMEM3Nzk1LCAweEJCMEI0NzAzLCAweDIyMDIxNkI5LCAweDU1MDUyNjJGLCAweEM1QkEzQkJFLFxuICAgICAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LCAweEMyRDdGRkE3LCAweEI1RDBDRjMxLFxuICAgICAweDJDRDk5RThCLCAweDVCREVBRTFELCAweDlCNjRDMkIwLCAweEVDNjNGMjI2LCAweDc1NkFBMzlDLFxuICAgICAweDAyNkQ5MzBBLCAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAgICAweDk1QkY0QTgyLCAweEUyQjg3QTE0LCAweDdCQjEyQkFFLCAweDBDQjYxQjM4LCAweDkyRDI4RTlCLFxuICAgICAweEU1RDVCRTBELCAweDdDRENFRkI3LCAweDBCREJERjIxLCAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLFxuICAgICAweDY4RERCM0Y4LCAweDFGREE4MzZFLCAweDgxQkUxNkNELCAweEY2QjkyNjVCLCAweDZGQjA3N0UxLFxuICAgICAweDE4Qjc0Nzc3LCAweDg4MDg1QUU2LCAweEZGMEY2QTcwLCAweDY2MDYzQkNBLCAweDExMDEwQjVDLFxuICAgICAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LCAweEEwMEFFMjc4LFxuICAgICAweEQ3MEREMkVFLCAweDRFMDQ4MzU0LCAweDM5MDNCM0MyLCAweEE3NjcyNjYxLCAweEQwNjAxNkY3LFxuICAgICAweDQ5Njk0NzRELCAweDNFNkU3N0RCLCAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LFxuICAgICAweDM3RDgzQkYwLCAweEE5QkNBRTUzLCAweERFQkI5RUM1LCAweDQ3QjJDRjdGLCAweDMwQjVGRkU5LFxuICAgICAweEJEQkRGMjFDLCAweENBQkFDMjhBLCAweDUzQjM5MzMwLCAweDI0QjRBM0E2LCAweEJBRDAzNjA1LFxuICAgICAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLCAweEIzNjY3QTJFLCAweEM0NjE0QUI4LFxuICAgICAweDVENjgxQjAyLCAweDJBNkYyQjk0LCAweEI0MEJCRTM3LCAweEMzMEM4RUExLCAweDVBMDVERjFCLFxuICAgICAweDJEMDJFRjhEXSxcblxuICAgIGNyYzMyOiBmdW5jdGlvbiBjcmMzMihkYXRhKSB7XG4gICAgICB2YXIgdGJsID0gdXRpbC5jcnlwdG8uY3JjMzJUYWJsZTtcbiAgICAgIHZhciBjcmMgPSAwIF4gLTE7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyB1dGlsLkJ1ZmZlcihkYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gZGF0YS5yZWFkVUludDgoaSk7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGJsWyhjcmMgXiBjb2RlKSAmIDB4RkZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjcmMgXiAtMSkgPj4+IDA7XG4gICAgfSxcblxuICAgIGhtYWM6IGZ1bmN0aW9uIGhtYWMoa2V5LCBzdHJpbmcsIGRpZ2VzdCwgZm4pIHtcbiAgICAgIGlmICghZGlnZXN0KSBkaWdlc3QgPSAnYmluYXJ5JztcbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKCFmbikgZm4gPSAnc2hhMjU2JztcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gbmV3IHV0aWwuQnVmZmVyKHN0cmluZyk7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8ubGliLmNyZWF0ZUhtYWMoZm4sIGtleSkudXBkYXRlKHN0cmluZykuZGlnZXN0KGRpZ2VzdCk7XG4gICAgfSxcblxuICAgIG1kNTogZnVuY3Rpb24gbWQ1KGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5oYXNoKCdtZDUnLCBkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc2hhMjU2OiBmdW5jdGlvbiBzaGEyNTYoZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmhhc2goJ3NoYTI1NicsIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBoYXNoOiBmdW5jdGlvbihhbGdvcml0aG0sIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBoYXNoID0gdXRpbC5jcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pO1xuICAgICAgaWYgKCFkaWdlc3QpIHsgZGlnZXN0ID0gJ2JpbmFyeSc7IH1cbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyB1dGlsLkJ1ZmZlcihkYXRhKTtcbiAgICAgIHZhciBzbGljZUZuID0gdXRpbC5hcnJheVNsaWNlRm4oZGF0YSk7XG4gICAgICB2YXIgaXNCdWZmZXIgPSB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgICAgIC8vSWRlbnRpZnlpbmcgb2JqZWN0cyB3aXRoIGFuIEFycmF5QnVmZmVyIGFzIGJ1ZmZlcnNcbiAgICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBpc0J1ZmZlciA9IHRydWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB0eXBlb2YgZGF0YS5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNCdWZmZXIpIHtcbiAgICAgICAgZGF0YS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7IGhhc2gudXBkYXRlKGNodW5rKTsgfSk7XG4gICAgICAgIGRhdGEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuICAgICAgICBkYXRhLm9uKCdlbmQnLCBmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCwgaGFzaC5kaWdlc3QoZGlnZXN0KSk7IH0pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAmJiBzbGljZUZuICYmICFpc0J1ZmZlciAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIEZpbGUvQmxvYlxuICAgICAgICB2YXIgaW5kZXggPSAwLCBzaXplID0gMTAyNCAqIDUxMjtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBkYXRhLicpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBidWYgPSBuZXcgdXRpbC5CdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCkpO1xuICAgICAgICAgIGhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgICAgaW5kZXggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBkYXRhLnNpemUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhc2guZGlnZXN0KGRpZ2VzdCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiYWNrID0gaW5kZXggKyBzaXplO1xuICAgICAgICAgIGlmIChiYWNrID4gZGF0YS5zaXplKSBiYWNrID0gZGF0YS5zaXplO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzbGljZUZuLmNhbGwoZGF0YSwgaW5kZXgsIGJhY2spKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIuX2NvbnRpbnVlUmVhZGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICFpc0J1ZmZlcikge1xuICAgICAgICAgIGRhdGEgPSBuZXcgdXRpbC5CdWZmZXIobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBoYXNoLnVwZGF0ZShkYXRhKS5kaWdlc3QoZGlnZXN0KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b0hleDogZnVuY3Rpb24gdG9IZXgoZGF0YSkge1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKCgnMCcgKyBkYXRhLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUhhc2g6IGZ1bmN0aW9uIGNyZWF0ZUhhc2goYWxnb3JpdGhtKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8ubGliLmNyZWF0ZUhhc2goYWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgfSxcblxuICAvKiogQCFpZ25vcmUgKi9cblxuICAvKiBBYm9ydCBjb25zdGFudCAqL1xuICBhYm9ydDoge30sXG5cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmplY3QsIGl0ZXJGdW5jdGlvbikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIHZhciByZXQgPSBpdGVyRnVuY3Rpb24uY2FsbCh0aGlzLCBrZXksIG9iamVjdFtrZXldKTtcbiAgICAgICAgaWYgKHJldCA9PT0gdXRpbC5hYm9ydCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFycmF5RWFjaDogZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpZHggaW4gYXJyYXkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGlkeCkpIHtcbiAgICAgICAgdmFyIHJldCA9IGl0ZXJGdW5jdGlvbi5jYWxsKHRoaXMsIGFycmF5W2lkeF0sIHBhcnNlSW50KGlkeCwgMTApKTtcbiAgICAgICAgaWYgKHJldCA9PT0gdXRpbC5hYm9ydCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iajEsIG9iajIpIHtcbiAgICB1dGlsLmVhY2gob2JqMiwgZnVuY3Rpb24gaXRlcmF0b3Ioa2V5LCBpdGVtKSB7XG4gICAgICBvYmoxW2tleV0gPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmoxO1xuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShvYmoxLCBvYmoyKSB7XG4gICAgcmV0dXJuIHV0aWwudXBkYXRlKHV0aWwuY29weShvYmoxKSwgb2JqMik7XG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gY29weShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gb2JqZWN0O1xuICAgIHZhciBkdXBlID0ge307XG4gICAgLy8ganNoaW50IGZvcmluOmZhbHNlXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgZHVwZVtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiBkdXBlO1xuICB9LFxuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGFycmF5U2xpY2VGbjogZnVuY3Rpb24gYXJyYXlTbGljZUZuKG9iaikge1xuICAgIHZhciBmbiA9IG9iai5zbGljZSB8fCBvYmoud2Via2l0U2xpY2UgfHwgb2JqLm1velNsaWNlO1xuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IG51bGw7XG4gIH0sXG5cbiAgaXNUeXBlOiBmdW5jdGlvbiBpc1R5cGUob2JqLCB0eXBlKSB7XG4gICAgLy8gaGFuZGxlIGNyb3NzLVwiZnJhbWVcIiBvYmplY3RzXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB0eXBlID0gdXRpbC50eXBlTmFtZSh0eXBlKTtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nO1xuICB9LFxuXG4gIHR5cGVOYW1lOiBmdW5jdGlvbiB0eXBlTmFtZSh0eXBlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLCAnbmFtZScpKSByZXR1cm4gdHlwZS5uYW1lO1xuICAgIHZhciBzdHIgPSB0eXBlLnRvU3RyaW5nKCk7XG4gICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKC9eXFxzKmZ1bmN0aW9uICguKylcXCgvKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IHN0cjtcbiAgfSxcblxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZXJyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbmFsRXJyb3IgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGVyci5tZXNzYWdlICE9PSAnJykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyB8fCAob3B0aW9ucyAmJiBvcHRpb25zLm1lc3NhZ2UpKSB7XG4gICAgICAgIG9yaWdpbmFsRXJyb3IgPSB1dGlsLmNvcHkoZXJyKTtcbiAgICAgICAgb3JpZ2luYWxFcnJvci5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICB1dGlsLnVwZGF0ZShlcnIsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSlcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICBpZiAob3B0aW9ucy5jb2RlIHx8IG9wdGlvbnMubmFtZSlcbiAgICAgICAgZXJyLmNvZGUgPSBvcHRpb25zLmNvZGUgfHwgb3B0aW9ucy5uYW1lO1xuICAgICAgaWYgKG9wdGlvbnMuc3RhY2spXG4gICAgICAgIGVyci5zdGFjayA9IG9wdGlvbnMuc3RhY2s7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge3dyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZX0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ21lc3NhZ2UnLCB7ZW51bWVyYWJsZTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGVyci5uYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLm5hbWUgfHwgZXJyLm5hbWUgfHwgZXJyLmNvZGUgfHwgJ0Vycm9yJztcbiAgICBlcnIudGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAob3JpZ2luYWxFcnJvcikgZXJyLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXG4gICAgcmV0dXJuIGVycjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbmhlcml0OiBmdW5jdGlvbiBpbmhlcml0KGtsYXNzLCBmZWF0dXJlcykge1xuICAgIHZhciBuZXdPYmplY3QgPSBudWxsO1xuICAgIGlmIChmZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZWF0dXJlcyA9IGtsYXNzO1xuICAgICAga2xhc3MgPSBPYmplY3Q7XG4gICAgICBuZXdPYmplY3QgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbiBDb25zdHJ1Y3RvcldyYXBwZXIoKSB7fTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgbmV3T2JqZWN0ID0gbmV3IGN0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBub3Qgc3VwcGxpZWQsIGNyZWF0ZSBwYXNzLXRocm91Z2ggY3RvclxuICAgIGlmIChmZWF0dXJlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBmZWF0dXJlcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoa2xhc3MgIT09IE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBrbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ld09iamVjdDtcbiAgICB1dGlsLnVwZGF0ZShmZWF0dXJlcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGZlYXR1cmVzKTtcbiAgICBmZWF0dXJlcy5jb25zdHJ1Y3Rvci5fX3N1cGVyX18gPSBrbGFzcztcbiAgICByZXR1cm4gZmVhdHVyZXMuY29uc3RydWN0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbWl4aW46IGZ1bmN0aW9uIG1peGluKCkge1xuICAgIHZhciBrbGFzcyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8ganNoaW50IGZvcmluOmZhbHNlXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3VtZW50c1tpXS5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2ldLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGlkZVByb3BlcnRpZXM6IGZ1bmN0aW9uIGhpZGVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgdXRpbC5hcnJheUVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcm9wZXJ0eTogZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSwgZW51bWVyYWJsZSwgaXNWYWx1ZSkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkID8gZW51bWVyYWJsZSA6IHRydWVcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWlzVmFsdWUpIHtcbiAgICAgIG9wdHMuZ2V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0cy52YWx1ZSA9IHZhbHVlOyBvcHRzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBvcHRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtZW1vaXplZFByb3BlcnR5OiBmdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSwgZ2V0LCBlbnVtZXJhYmxlKSB7XG4gICAgdmFyIGNhY2hlZFZhbHVlID0gbnVsbDtcblxuICAgIC8vIGJ1aWxkIGVudW1lcmFibGUgYXR0cmlidXRlIGZvciBlYWNoIHZhbHVlIHdpdGggbGF6eSBhY2Nlc3Nvci5cbiAgICB1dGlsLnByb3BlcnR5KG9iaiwgbmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY2FjaGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVkVmFsdWUgPSBnZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICB9LCBlbnVtZXJhYmxlKTtcbiAgfSxcblxuICAvKipcbiAgICogVE9ETyBSZW1vdmUgaW4gbWFqb3IgdmVyc2lvbiByZXZpc2lvblxuICAgKiBUaGlzIGJhY2tmaWxsIHBvcHVsYXRlcyByZXNwb25zZSBkYXRhIHdpdGhvdXQgdGhlXG4gICAqIHRvcC1sZXZlbCBwYXlsb2FkIG5hbWUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaG9pc3RQYXlsb2FkTWVtYmVyOiBmdW5jdGlvbiBob2lzdFBheWxvYWRNZW1iZXIocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5vcGVyYXRpb247XG4gICAgdmFyIG91dHB1dCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0ub3V0cHV0O1xuICAgIGlmIChvdXRwdXQucGF5bG9hZCkge1xuICAgICAgdmFyIHBheWxvYWRNZW1iZXIgPSBvdXRwdXQubWVtYmVyc1tvdXRwdXQucGF5bG9hZF07XG4gICAgICB2YXIgcmVzcG9uc2VQYXlsb2FkID0gcmVzcC5kYXRhW291dHB1dC5wYXlsb2FkXTtcbiAgICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICAgIHV0aWwuZWFjaChyZXNwb25zZVBheWxvYWQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB1dGlsLnByb3BlcnR5KHJlc3AuZGF0YSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGUgU0hBLTI1NiBjaGVja3N1bXMgb2Ygc3RyZWFtc1xuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVTaGEyNTY6IGZ1bmN0aW9uIGNvbXB1dGVTaGEyNTYoYm9keSwgZG9uZSkge1xuICAgIGlmICh1dGlsLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgU3RyZWFtID0gdXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keS5wYXRoID09PSAnc3RyaW5nJykgeyAvLyBhc3N1bWUgZmlsZSBvYmplY3RcbiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHkuc3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zdGFydCA9IGJvZHkuc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5lbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5lbmQgPSBib2R5LmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oYm9keS5wYXRoLCBzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRPRE8gc3VwcG9ydCBvdGhlciBzdHJlYW0gdHlwZXNcbiAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ05vbi1maWxlIHN0cmVhbSBvYmplY3RzIGFyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzdXBwb3J0ZWQgd2l0aCBTaWdWNCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWwuY3J5cHRvLnNoYTI1Nihib2R5LCAnaGV4JywgZnVuY3Rpb24oZXJyLCBzaGEpIHtcbiAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgIGVsc2UgZG9uZShudWxsLCBzaGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzQ2xvY2tTa2V3ZWQ6IGZ1bmN0aW9uIGlzQ2xvY2tTa2V3ZWQoc2VydmVyVGltZSkge1xuICAgIGlmIChzZXJ2ZXJUaW1lKSB7XG4gICAgICB1dGlsLnByb3BlcnR5KEFXUy5jb25maWcsICdpc0Nsb2NrU2tld2VkJyxcbiAgICAgICAgTWF0aC5hYnMobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzZXJ2ZXJUaW1lKSA+PSAzMDAwMDAsIGZhbHNlKTtcbiAgICAgIHJldHVybiBBV1MuY29uZmlnLmlzQ2xvY2tTa2V3ZWQ7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5Q2xvY2tPZmZzZXQ6IGZ1bmN0aW9uIGFwcGx5Q2xvY2tPZmZzZXQoc2VydmVyVGltZSkge1xuICAgIGlmIChzZXJ2ZXJUaW1lKVxuICAgICAgQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCA9IHNlcnZlclRpbWUgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0UmVxdWVzdElkOiBmdW5jdGlvbiBleHRyYWN0UmVxdWVzdElkKHJlc3ApIHtcbiAgICB2YXIgcmVxdWVzdElkID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddIHx8XG4gICAgICAgICAgICAgICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ107XG5cbiAgICBpZiAoIXJlcXVlc3RJZCAmJiByZXNwLmRhdGEgJiYgcmVzcC5kYXRhLlJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgIHJlcXVlc3RJZCA9IHJlc3AuZGF0YS5SZXNwb25zZU1ldGFkYXRhLlJlcXVlc3RJZDtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdElkKSB7XG4gICAgICByZXNwLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB9XG5cbiAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgcmVzcC5lcnJvci5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZFByb21pc2VzOiBmdW5jdGlvbiBhZGRQcm9taXNlcyhjb25zdHJ1Y3RvcnMsIFByb21pc2VEZXBlbmRlbmN5KSB7XG4gICAgaWYgKFByb21pc2VEZXBlbmRlbmN5ID09PSB1bmRlZmluZWQgJiYgQVdTICYmIEFXUy5jb25maWcpIHtcbiAgICAgIFByb21pc2VEZXBlbmRlbmN5ID0gQVdTLmNvbmZpZy5nZXRQcm9taXNlc0RlcGVuZGVuY3koKTtcbiAgICB9XG4gICAgaWYgKFByb21pc2VEZXBlbmRlbmN5ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBQcm9taXNlRGVwZW5kZW5jeSA9IFByb21pc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgUHJvbWlzZURlcGVuZGVuY3kgIT09ICdmdW5jdGlvbicpIHZhciBkZWxldGVQcm9taXNlcyA9IHRydWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnN0cnVjdG9ycykpIGNvbnN0cnVjdG9ycyA9IFtjb25zdHJ1Y3RvcnNdO1xuXG4gICAgZm9yICh2YXIgaW5kID0gMDsgaW5kIDwgY29uc3RydWN0b3JzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yc1tpbmRdO1xuICAgICAgaWYgKGRlbGV0ZVByb21pc2VzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5kZWxldGVQcm9taXNlc0Zyb21DbGFzcykge1xuICAgICAgICAgIGNvbnN0cnVjdG9yLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IuYWRkUHJvbWlzZXNUb0NsYXNzKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yLmFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByb21pc2lmeU1ldGhvZDogZnVuY3Rpb24gcHJvbWlzaWZ5TWV0aG9kKG1ldGhvZE5hbWUsIFByb21pc2VEZXBlbmRlbmN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2VEZXBlbmRlbmN5KGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmW21ldGhvZE5hbWVdKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzRHVhbHN0YWNrQXZhaWxhYmxlOiBmdW5jdGlvbiBpc0R1YWxzdGFja0F2YWlsYWJsZShzZXJ2aWNlKSB7XG4gICAgaWYgKCFzZXJ2aWNlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi4vYXBpcy9tZXRhZGF0YS5qc29uJyk7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJykgc2VydmljZSA9IHNlcnZpY2Uuc2VydmljZUlkZW50aWZpZXI7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoc2VydmljZSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gISFtZXRhZGF0YVtzZXJ2aWNlXS5kdWFsc3RhY2tBdmFpbGFibGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlUmV0cnlEZWxheTogZnVuY3Rpb24gY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCByZXRyeURlbGF5T3B0aW9ucykge1xuICAgIGlmICghcmV0cnlEZWxheU9wdGlvbnMpIHJldHJ5RGVsYXlPcHRpb25zID0ge307XG4gICAgdmFyIGN1c3RvbUJhY2tvZmYgPSByZXRyeURlbGF5T3B0aW9ucy5jdXN0b21CYWNrb2ZmIHx8IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21CYWNrb2ZmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY3VzdG9tQmFja29mZihyZXRyeUNvdW50KTtcbiAgICB9XG4gICAgdmFyIGJhc2UgPSB0eXBlb2YgcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA9PT0gJ251bWJlcicgPyByZXRyeURlbGF5T3B0aW9ucy5iYXNlIDogMTAwO1xuICAgIHZhciBkZWxheSA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiBiYXNlKTtcbiAgICByZXR1cm4gZGVsYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzOiBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0V2l0aFJldHJpZXMoaHR0cFJlcXVlc3QsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGh0dHAgPSBBV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSgpO1xuICAgIHZhciBodHRwT3B0aW9ucyA9IG9wdGlvbnMuaHR0cE9wdGlvbnMgfHwge307XG4gICAgdmFyIHJldHJ5Q291bnQgPSAwO1xuXG4gICAgdmFyIGVyckNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICB2YXIgbWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCAwO1xuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcicpIGVyci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgaWYgKGVyciAmJiBlcnIucmV0cnlhYmxlICYmIHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgdmFyIGRlbGF5ID0gdXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIG9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMpO1xuICAgICAgICBzZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCBkZWxheSArIChlcnIucmV0cnlBZnRlciB8fCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICBodHRwLmhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHsgZGF0YSArPSBjaHVuay50b1N0cmluZygpOyB9KTtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICBjYihudWxsLCBkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSBwYXJzZUludChodHRwUmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSwgMTApICogMTAwMCB8fCAwO1xuICAgICAgICAgICAgdmFyIGVyciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgICAgIHsgcmV0cnlhYmxlOiBzdGF0dXNDb2RlID49IDUwMCB8fCBzdGF0dXNDb2RlID09PSA0MjkgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyICYmIGVyci5yZXRyeWFibGUpIGVyci5yZXRyeUFmdGVyID0gcmV0cnlBZnRlcjtcbiAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVyckNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgQVdTLnV0aWwuZGVmZXIoc2VuZFJlcXVlc3QpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHV1aWQ6IHtcbiAgICB2NDogZnVuY3Rpb24gdXVpZFY0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ3V1aWQnKS52NCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nOiBmdW5jdGlvbiBjb252ZXJ0UGF5bG9hZFRvU3RyaW5nKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb24gPSByZXEub3BlcmF0aW9uO1xuICAgIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0ub3V0cHV0IHx8IHt9O1xuICAgIGlmIChydWxlcy5wYXlsb2FkICYmIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSkge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRQcm9maWxlOiAnZGVmYXVsdCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlnT3B0SW5FbnY6ICdBV1NfU0RLX0xPQURfQ09ORklHJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaGFyZWRDcmVkZW50aWFsc0ZpbGVFbnY6ICdBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNoYXJlZENvbmZpZ0ZpbGVFbnY6ICdBV1NfQ09ORklHX0ZJTEUnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gKiAgIHRoaXMueCA9IDA7XG4gKiAgIHRoaXMueSA9IDA7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICogfVxuICpcbiAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gKiB9KTtcbiAqXG4gKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDRGF0YSwgWE1MQ29tbWVudCwgWE1MRGVjbGFyYXRpb24sIFhNTERvY1R5cGUsIFhNTEVsZW1lbnQsIFhNTE5vZGUsIFhNTFJhdywgWE1MVGV4dCwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbiAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Z1bmN0aW9uJyk7XG5cbiAgaXNFbXB0eSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0VtcHR5Jyk7XG5cbiAgWE1MRWxlbWVudCA9IG51bGw7XG5cbiAgWE1MQ0RhdGEgPSBudWxsO1xuXG4gIFhNTENvbW1lbnQgPSBudWxsO1xuXG4gIFhNTERlY2xhcmF0aW9uID0gbnVsbDtcblxuICBYTUxEb2NUeXBlID0gbnVsbDtcblxuICBYTUxSYXcgPSBudWxsO1xuXG4gIFhNTFRleHQgPSBudWxsO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxOb2RlKHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnBhcmVudC5vcHRpb25zO1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSB0aGlzLnBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAoWE1MRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG4gICAgICAgIFhNTENEYXRhID0gcmVxdWlyZSgnLi9YTUxDRGF0YScpO1xuICAgICAgICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG4gICAgICAgIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuICAgICAgICBYTUxEb2NUeXBlID0gcmVxdWlyZSgnLi9YTUxEb2NUeXBlJyk7XG4gICAgICAgIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG4gICAgICAgIFhNTFRleHQgPSByZXF1aXJlKCcuL1hNTFRleHQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkTm9kZSwgaXRlbSwgaiwgaywga2V5LCBsYXN0Q2hpbGQsIGxlbiwgbGVuMSwgcmVmLCB2YWw7XG4gICAgICBsYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZiA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZlswXSwgYXR0cmlidXRlcyA9IHJlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGl0ZW0gPSBuYW1lW2pdO1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChuYW1lLmFwcGx5KCkpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgdmFsID0gbmFtZVtrZXldO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGlzT2JqZWN0KHZhbCkpICYmIChpc0VtcHR5KHZhbCkpKSB7XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkgJiYga2V5LmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleSkgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuYXR0cmlidXRlKGtleS5zdWJzdHIodGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleS5sZW5ndGgpLCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRQSUtleSAmJiBrZXkuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkpID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmluc3RydWN0aW9uKGtleS5zdWJzdHIodGhpcy5zdHJpbmdpZnkuY29udmVydFBJS2V5Lmxlbmd0aCksIHZhbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLnNlcGFyYXRlQXJyYXlJdGVtcyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSB2YWwubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSB2YWxba107XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHt9O1xuICAgICAgICAgICAgICBjaGlsZE5vZGVba2V5XSA9IGl0ZW07XG4gICAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSk7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuZWxlbWVudCh2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoa2V5LCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0VGV4dEtleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy50ZXh0KHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDRGF0YUtleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmNkYXRhKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q29tbWVudEtleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jb21tZW50KHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMucmF3KHRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgYW55IGVsZW1lbnRzIHdpdGg6IFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdENoaWxkO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc2VydCBlbGVtZW50cyBhdCByb290IGxldmVsXCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICByZW1vdmVkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGkpO1xuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zZXJ0IGVsZW1lbnRzIGF0IHJvb3QgbGV2ZWxcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSArIDEpO1xuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCByZWY7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgcm9vdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBbXS5zcGxpY2UuYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIFtpLCBpIC0gaSArIDFdLmNvbmNhdChyZWYgPSBbXSkpLCByZWY7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGQsIHJlZjtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy52YWx1ZU9mKCk7XG4gICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJlZiA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZlswXSwgYXR0cmlidXRlcyA9IHJlZlsxXTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gbmV3IFhNTEVsZW1lbnQodGhpcywgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGNoaWxkLnRleHQodGV4dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTFRleHQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxDRGF0YSh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MQ29tbWVudCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxSYXcodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICB2YXIgZG9jLCB4bWxkZWM7XG4gICAgICBkb2MgPSB0aGlzLmRvY3VtZW50KCk7XG4gICAgICB4bWxkZWMgPSBuZXcgWE1MRGVjbGFyYXRpb24oZG9jLCB2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSk7XG4gICAgICBkb2MueG1sZGVjID0geG1sZGVjO1xuICAgICAgcmV0dXJuIGRvYy5yb290KCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRvY3R5cGUgPSBmdW5jdGlvbihwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHZhciBkb2MsIGRvY3R5cGU7XG4gICAgICBkb2MgPSB0aGlzLmRvY3VtZW50KCk7XG4gICAgICBkb2N0eXBlID0gbmV3IFhNTERvY1R5cGUoZG9jLCBwdWJJRCwgc3lzSUQpO1xuICAgICAgZG9jLmRvY3R5cGUgPSBkb2N0eXBlO1xuICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJvb3Qgbm9kZSBoYXMgbm8gcGFyZW50LiBVc2UgZG9jKCkgaWYgeW91IG5lZWQgdG8gZ2V0IHRoZSBkb2N1bWVudCBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50O1xuICAgICAgd2hpbGUgKCFjaGlsZC5pc1Jvb3QpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290KCkuZG9jdW1lbnRPYmplY3Q7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCkudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3Qgbm9kZSBoYXMgbm8gc2libGluZ3NcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIGlmIChpIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGF0IHRoZSBmaXJzdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgLSAxXTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBub2RlIGhhcyBubyBzaWJsaW5nc1wiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPT09IC0xIHx8IGkgPT09IHRoaXMucGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgbGFzdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgKyAxXTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW1wb3J0WE1MQnVpbGRlciA9IGZ1bmN0aW9uKHhtbGJ1aWxkZXIpIHtcbiAgICAgIHZhciBjbG9uZWRSb290O1xuICAgICAgY2xvbmVkUm9vdCA9IHhtbGJ1aWxkZXIucm9vdCgpLmNsb25lKCk7XG4gICAgICBjbG9uZWRSb290LnBhcmVudCA9IHRoaXM7XG4gICAgICBjbG9uZWRSb290LmlzUm9vdCA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNsb25lZFJvb3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmVsZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLm5vZCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnR4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZGF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRlYyA9IGZ1bmN0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmR0ZCA9IGZ1bmN0aW9uKHB1YklELCBzeXNJRCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdHlwZShwdWJJRCwgc3lzSUQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUubiA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxOb2RlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBwcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXRpbC5wcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVkUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gIGlmICghb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXSkge1xuICAgIHV0aWwubWVtb2l6ZWRQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFNoYXBlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHByb3BlcnR5KHRoaXMsICdzaGFwZScsIHNoYXBlLnNoYXBlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICd0eXBlJywgc2hhcGUudHlwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdlbnVtJywgc2hhcGUuZW51bSk7XG4gIHByb3BlcnR5KHRoaXMsICdtaW4nLCBzaGFwZS5taW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWF4Jywgc2hhcGUubWF4KTtcbiAgcHJvcGVydHkodGhpcywgJ3BhdHRlcm4nLCBzaGFwZS5wYXR0ZXJuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xvY2F0aW9uJywgc2hhcGUubG9jYXRpb24gfHwgdGhpcy5sb2NhdGlvbiB8fCAnYm9keScpO1xuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHRoaXMubmFtZSB8fCBzaGFwZS54bWxOYW1lIHx8IHNoYXBlLnF1ZXJ5TmFtZSB8fFxuICAgIHNoYXBlLmxvY2F0aW9uTmFtZSB8fCBtZW1iZXJOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzU3RyZWFtaW5nJywgc2hhcGUuc3RyZWFtaW5nIHx8IHRoaXMuaXNTdHJlYW1pbmcgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNDb21wb3NpdGUnLCBzaGFwZS5pc0NvbXBvc2l0ZSB8fCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NoYXBlJywgdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNRdWVyeU5hbWUnLCBCb29sZWFuKHNoYXBlLnF1ZXJ5TmFtZSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzTG9jYXRpb25OYW1lJywgQm9vbGVhbihzaGFwZS5sb2NhdGlvbk5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0lkZW1wb3RlbnQnLCBzaGFwZS5pZGVtcG90ZW5jeVRva2VuID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzSnNvblZhbHVlJywgc2hhcGUuanNvbnZhbHVlID09PSB0cnVlKTtcblxuICBpZiAob3B0aW9ucy5kb2N1bWVudGF0aW9uKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb24nLCBzaGFwZS5kb2N1bWVudGF0aW9uKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvblVybCcsIHNoYXBlLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG5cbiAgaWYgKHNoYXBlLnhtbEF0dHJpYnV0ZSkge1xuICAgIHByb3BlcnR5KHRoaXMsICdpc1htbEF0dHJpYnV0ZScsIHNoYXBlLnhtbEF0dHJpYnV0ZSB8fCBmYWxzZSk7XG4gIH1cblxuICAvLyB0eXBlIGNvbnZlcnNpb24gYW5kIHBhcnNpbmdcbiAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIG51bGwpO1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TaGFwZS5ub3JtYWxpemVkVHlwZXMgPSB7XG4gIGNoYXJhY3RlcjogJ3N0cmluZycsXG4gIGRvdWJsZTogJ2Zsb2F0JyxcbiAgbG9uZzogJ2ludGVnZXInLFxuICBzaG9ydDogJ2ludGVnZXInLFxuICBiaWdpbnRlZ2VyOiAnaW50ZWdlcicsXG4gIGJpZ2RlY2ltYWw6ICdmbG9hdCcsXG4gIGJsb2I6ICdiaW5hcnknXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TaGFwZS50eXBlcyA9IHtcbiAgJ3N0cnVjdHVyZSc6IFN0cnVjdHVyZVNoYXBlLFxuICAnbGlzdCc6IExpc3RTaGFwZSxcbiAgJ21hcCc6IE1hcFNoYXBlLFxuICAnYm9vbGVhbic6IEJvb2xlYW5TaGFwZSxcbiAgJ3RpbWVzdGFtcCc6IFRpbWVzdGFtcFNoYXBlLFxuICAnZmxvYXQnOiBGbG9hdFNoYXBlLFxuICAnaW50ZWdlcic6IEludGVnZXJTaGFwZSxcbiAgJ3N0cmluZyc6IFN0cmluZ1NoYXBlLFxuICAnYmFzZTY0JzogQmFzZTY0U2hhcGUsXG4gICdiaW5hcnknOiBCaW5hcnlTaGFwZVxufTtcblxuU2hhcGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgaWYgKHNoYXBlLnNoYXBlKSB7XG4gICAgdmFyIHJlZlNoYXBlID0gb3B0aW9ucy5hcGkuc2hhcGVzW3NoYXBlLnNoYXBlXTtcbiAgICBpZiAoIXJlZlNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNoYXBlIHJlZmVyZW5jZTogJyArIHNoYXBlLnNoYXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmU2hhcGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblNoYXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSkge1xuICBpZiAoc2hhcGUuaXNTaGFwZSkgcmV0dXJuIHNoYXBlO1xuXG4gIHZhciByZWZTaGFwZSA9IFNoYXBlLnJlc29sdmUoc2hhcGUsIG9wdGlvbnMpO1xuICBpZiAocmVmU2hhcGUpIHtcbiAgICB2YXIgZmlsdGVyZWRLZXlzID0gT2JqZWN0LmtleXMoc2hhcGUpO1xuICAgIGlmICghb3B0aW9ucy5kb2N1bWVudGF0aW9uKSB7XG4gICAgICBmaWx0ZXJlZEtleXMgPSBmaWx0ZXJlZEtleXMuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICFuYW1lLm1hdGNoKC9kb2N1bWVudGF0aW9uLyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW4gaW5saW5lIHNoYXBlIHdpdGggZXh0cmEgbWVtYmVyc1xuICAgIHZhciBJbmxpbmVTaGFwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVmU2hhcGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSk7XG4gICAgfTtcbiAgICBJbmxpbmVTaGFwZS5wcm90b3R5cGUgPSByZWZTaGFwZTtcbiAgICByZXR1cm4gbmV3IElubGluZVNoYXBlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2V0IHR5cGUgaWYgbm90IHNldFxuICAgIGlmICghc2hhcGUudHlwZSkge1xuICAgICAgaWYgKHNoYXBlLm1lbWJlcnMpIHNoYXBlLnR5cGUgPSAnc3RydWN0dXJlJztcbiAgICAgIGVsc2UgaWYgKHNoYXBlLm1lbWJlcikgc2hhcGUudHlwZSA9ICdsaXN0JztcbiAgICAgIGVsc2UgaWYgKHNoYXBlLmtleSkgc2hhcGUudHlwZSA9ICdtYXAnO1xuICAgICAgZWxzZSBzaGFwZS50eXBlID0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHR5cGVzXG4gICAgdmFyIG9yaWdUeXBlID0gc2hhcGUudHlwZTtcbiAgICBpZiAoU2hhcGUubm9ybWFsaXplZFR5cGVzW3NoYXBlLnR5cGVdKSB7XG4gICAgICBzaGFwZS50eXBlID0gU2hhcGUubm9ybWFsaXplZFR5cGVzW3NoYXBlLnR5cGVdO1xuICAgIH1cblxuICAgIGlmIChTaGFwZS50eXBlc1tzaGFwZS50eXBlXSkge1xuICAgICAgcmV0dXJuIG5ldyBTaGFwZS50eXBlc1tzaGFwZS50eXBlXShzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIHNoYXBlIHR5cGU6ICcgKyBvcmlnVHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBDb21wb3NpdGVTaGFwZShzaGFwZSkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNDb21wb3NpdGUnLCB0cnVlKTtcblxuICBpZiAoc2hhcGUuZmxhdHRlbmVkKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2ZsYXR0ZW5lZCcsIHNoYXBlLmZsYXR0ZW5lZCB8fCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gU3RydWN0dXJlU2hhcGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgdmFyIHJlcXVpcmVkTWFwID0gbnVsbCwgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcblxuICBDb21wb3NpdGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChmaXJzdEluaXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCB7fSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlck5hbWVzJywgW10pO1xuICAgIHByb3BlcnR5KHRoaXMsICdyZXF1aXJlZCcsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNSZXF1aXJlZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICB9XG5cbiAgaWYgKHNoYXBlLm1lbWJlcnMpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnbWVtYmVycycsIG5ldyBDb2xsZWN0aW9uKHNoYXBlLm1lbWJlcnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShtZW1iZXIsIG9wdGlvbnMsIG5hbWUpO1xuICAgIH0pKTtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNoYXBlLnhtbE9yZGVyIHx8IE9iamVjdC5rZXlzKHNoYXBlLm1lbWJlcnMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNoYXBlLnJlcXVpcmVkKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3JlcXVpcmVkJywgc2hhcGUucmVxdWlyZWQpO1xuICAgIHByb3BlcnR5KHRoaXMsICdpc1JlcXVpcmVkJywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCFyZXF1aXJlZE1hcCkge1xuICAgICAgICByZXF1aXJlZE1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVxdWlyZWRNYXBbc2hhcGUucmVxdWlyZWRbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWlyZWRNYXBbbmFtZV07XG4gICAgfSwgZmFsc2UsIHRydWUpO1xuICB9XG5cbiAgcHJvcGVydHkodGhpcywgJ3Jlc3VsdFdyYXBwZXInLCBzaGFwZS5yZXN1bHRXcmFwcGVyIHx8IG51bGwpO1xuXG4gIGlmIChzaGFwZS5wYXlsb2FkKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3BheWxvYWQnLCBzaGFwZS5wYXlsb2FkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2hhcGUueG1sTmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgIHByb3BlcnR5KHRoaXMsICd4bWxOYW1lc3BhY2VVcmknLCBzaGFwZS54bWxOYW1lc3BhY2UpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzaGFwZS54bWxOYW1lc3BhY2UgPT09ICdvYmplY3QnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVByZWZpeCcsIHNoYXBlLnhtbE5hbWVzcGFjZS5wcmVmaXgpO1xuICAgIHByb3BlcnR5KHRoaXMsICd4bWxOYW1lc3BhY2VVcmknLCBzaGFwZS54bWxOYW1lc3BhY2UudXJpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBMaXN0U2hhcGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLCBmaXJzdEluaXQgPSAhdGhpcy5pc1NoYXBlO1xuICBDb21wb3NpdGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChmaXJzdEluaXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG4gIH1cblxuICBpZiAoc2hhcGUubWVtYmVyKSB7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbWVtYmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLm1lbWJlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5mbGF0dGVuZWQpIHtcbiAgICB2YXIgb2xkTmFtZSA9IHRoaXMubmFtZTtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICduYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VsZi5tZW1iZXIubmFtZSB8fCBvbGROYW1lO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1hcFNoYXBlKHNoYXBlLCBvcHRpb25zKSB7XG4gIHZhciBmaXJzdEluaXQgPSAhdGhpcy5pc1NoYXBlO1xuICBDb21wb3NpdGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChmaXJzdEluaXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG4gICAgcHJvcGVydHkodGhpcywgJ2tleScsIFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cmluZyd9LCBvcHRpb25zKSk7XG4gICAgcHJvcGVydHkodGhpcywgJ3ZhbHVlJywgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RyaW5nJ30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5rZXkpIHtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdrZXknLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUua2V5LCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoc2hhcGUudmFsdWUpIHtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICd2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS52YWx1ZSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVGltZXN0YW1wU2hhcGUoc2hhcGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmICh0aGlzLmxvY2F0aW9uID09PSAnaGVhZGVyJykge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAncmZjODIyJyk7XG4gIH0gZWxzZSBpZiAoc2hhcGUudGltZXN0YW1wRm9ybWF0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsIHNoYXBlLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH0gZWxzZSBpZiAoIXRoaXMudGltZXN0YW1wRm9ybWF0ICYmIHRoaXMuYXBpKSB7XG4gICAgaWYgKHRoaXMuYXBpLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsIHRoaXMuYXBpLnRpbWVzdGFtcEZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIGNhc2UgJ3Jlc3QtanNvbic6XG4gICAgICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICd1bml4VGltZXN0YW1wJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3QteG1sJzpcbiAgICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgICBjYXNlICdlYzInOlxuICAgICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAnaXNvODYwMScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b1VUQ1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICB1dGlsLmRhdGUucGFyc2VUaW1lc3RhbXAodmFsdWUpIDogbnVsbDtcbiAgfTtcblxuICB0aGlzLnRvV2lyZUZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwuZGF0ZS5mb3JtYXQodmFsdWUsIHNlbGYudGltZXN0YW1wRm9ybWF0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gU3RyaW5nU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdmFyIG51bGxMZXNzUHJvdG9jb2xzID0gWydyZXN0LXhtbCcsICdxdWVyeScsICdlYzInXTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlID0gdGhpcy5hcGkgJiYgbnVsbExlc3NQcm90b2NvbHMuaW5kZXhPZih0aGlzLmFwaS5wcm90b2NvbCkgPiAtMSA/XG4gICAgICB2YWx1ZSB8fCAnJyA6IHZhbHVlO1xuICAgIGlmICh0aGlzLmlzSnNvblZhbHVlKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSnNvblZhbHVlID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZsb2F0U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH07XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gdGhpcy50b1R5cGU7XG59XG5cbmZ1bmN0aW9uIEludGVnZXJTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBCaW5hcnlTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy50b1R5cGUgPSB1dGlsLmJhc2U2NC5kZWNvZGU7XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gdXRpbC5iYXNlNjQuZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBCYXNlNjRTaGFwZSgpIHtcbiAgQmluYXJ5U2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gQm9vbGVhblNoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHZhbHVlID09PSAndHJ1ZSc7XG4gIH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLnNoYXBlcyA9IHtcbiAgU3RydWN0dXJlU2hhcGU6IFN0cnVjdHVyZVNoYXBlLFxuICBMaXN0U2hhcGU6IExpc3RTaGFwZSxcbiAgTWFwU2hhcGU6IE1hcFNoYXBlLFxuICBTdHJpbmdTaGFwZTogU3RyaW5nU2hhcGUsXG4gIEJvb2xlYW5TaGFwZTogQm9vbGVhblNoYXBlLFxuICBCYXNlNjRTaGFwZTogQmFzZTY0U2hhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9zaGFwZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWV0aG9kKHJlcSkge1xuICByZXEuaHR0cFJlcXVlc3QubWV0aG9kID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaHR0cE1ldGhvZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVUkkoZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoLCBpbnB1dCwgcGFyYW1zKSB7XG4gIHZhciB1cmkgPSBbZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoXS5qb2luKCcvJyk7XG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG5cbiAgdmFyIHF1ZXJ5U3RyaW5nID0ge30sIHF1ZXJ5U3RyaW5nU2V0ID0gZmFsc2U7XG4gIHV0aWwuZWFjaChpbnB1dC5tZW1iZXJzLCBmdW5jdGlvbiAobmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwgfHwgcGFyYW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3VyaScpIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG1lbWJlci5uYW1lICsgJyhcXFxcKyk/XFxcXH0nKTtcbiAgICAgIHVyaSA9IHVyaS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihfLCBwbHVzKSB7XG4gICAgICAgIHZhciBmbiA9IHBsdXMgPyB1dGlsLnVyaUVzY2FwZVBhdGggOiB1dGlsLnVyaUVzY2FwZTtcbiAgICAgICAgcmV0dXJuIGZuKFN0cmluZyhwYXJhbVZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3F1ZXJ5c3RyaW5nJykge1xuICAgICAgcXVlcnlTdHJpbmdTZXQgPSB0cnVlO1xuXG4gICAgICBpZiAobWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBxdWVyeVN0cmluZ1ttZW1iZXIubmFtZV0gPSBwYXJhbVZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICAgIHV0aWwuZWFjaChwYXJhbVZhbHVlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nW2tleV0gPSB1dGlsLnVyaUVzY2FwZShTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHJpbmdbbWVtYmVyLm5hbWVdID0gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHBhcmFtVmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChxdWVyeVN0cmluZ1NldCkge1xuICAgIHVyaSArPSAodXJpLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB1dGlsLmFycmF5RWFjaChPYmplY3Qua2V5cyhxdWVyeVN0cmluZykuc29ydCgpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShxdWVyeVN0cmluZ1trZXldKSkge1xuICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gW3F1ZXJ5U3RyaW5nW2tleV1dO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVN0cmluZ1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2godXRpbC51cmlFc2NhcGUoU3RyaW5nKGtleSkpICsgJz0nICsgcXVlcnlTdHJpbmdba2V5XVtpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXJpICs9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlVVJJKHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBpbnB1dCA9IG9wZXJhdGlvbi5pbnB1dDtcblxuICB2YXIgdXJpID0gZ2VuZXJhdGVVUkkocmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50LnBhdGgsIG9wZXJhdGlvbi5odHRwUGF0aCwgaW5wdXQsIHJlcS5wYXJhbXMpO1xuICByZXEuaHR0cFJlcXVlc3QucGF0aCA9IHVyaTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVIZWFkZXJzKHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHV0aWwuZWFjaChvcGVyYXRpb24uaW5wdXQubWVtYmVycywgZnVuY3Rpb24gKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciB2YWx1ZSA9IHJlcS5wYXJhbXNbbmFtZV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXJzJyAmJiBtZW1iZXIudHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgIHV0aWwuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oa2V5LCBtZW1iZXJWYWx1ZSkge1xuICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1ttZW1iZXIubmFtZSArIGtleV0gPSBtZW1iZXJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVyJykge1xuICAgICAgdmFsdWUgPSBtZW1iZXIudG9XaXJlRm9ybWF0KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgaWYgKG1lbWJlci5pc0pzb25WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHV0aWwuYmFzZTY0LmVuY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1ttZW1iZXIubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHBvcHVsYXRlTWV0aG9kKHJlcSk7XG4gIHBvcHVsYXRlVVJJKHJlcSk7XG4gIHBvcHVsYXRlSGVhZGVycyhyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IoKSB7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIHIgPSByZXNwLmh0dHBSZXNwb25zZTtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcblxuICAvLyBub3JtYWxpemUgaGVhZGVycyBuYW1lcyB0byBsb3dlci1jYXNlZCBrZXlzIGZvciBtYXRjaGluZ1xuICB2YXIgaGVhZGVycyA9IHt9O1xuICB1dGlsLmVhY2goci5oZWFkZXJzLCBmdW5jdGlvbiAoaywgdikge1xuICAgIGhlYWRlcnNbay50b0xvd2VyQ2FzZSgpXSA9IHY7XG4gIH0pO1xuXG4gIHV0aWwuZWFjaChvdXRwdXQubWVtYmVycywgZnVuY3Rpb24obmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIGhlYWRlciA9IChtZW1iZXIubmFtZSB8fCBuYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXJzJyAmJiBtZW1iZXIudHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgIGRhdGFbbmFtZV0gPSB7fTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IG1lbWJlci5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlci5uYW1lIDogJyc7XG4gICAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14nICsgbG9jYXRpb24gKyAnKC4rKScsICdpJyk7XG4gICAgICB1dGlsLmVhY2goci5oZWFkZXJzLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gay5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGFbbmFtZV1bcmVzdWx0WzFdXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVyJykge1xuICAgICAgaWYgKGhlYWRlcnNbaGVhZGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1lbWJlci5pc0pzb25WYWx1ZSA/XG4gICAgICAgICAgdXRpbC5iYXNlNjQuZGVjb2RlKGhlYWRlcnNbaGVhZGVyXSkgOlxuICAgICAgICAgIGhlYWRlcnNbaGVhZGVyXTtcbiAgICAgICAgZGF0YVtuYW1lXSA9IG1lbWJlci50b1R5cGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnc3RhdHVzQ29kZScpIHtcbiAgICAgIGRhdGFbbmFtZV0gPSBwYXJzZUludChyLnN0YXR1c0NvZGUsIDEwKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlc3AuZGF0YSA9IGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YSxcbiAgZ2VuZXJhdGVVUkk6IGdlbmVyYXRlVVJJXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydzdHMnXSA9IHt9O1xuQVdTLlNUUyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnc3RzJywgWycyMDExLTA2LTE1J10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL3N0cycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snc3RzJ10sICcyMDExLTA2LTE1Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3N0cy0yMDExLTA2LTE1Lm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvc3RzLTIwMTEtMDYtMTUucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNUUztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9zdHMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gYnJvd3NlciBzcGVjaWZpYyBtb2R1bGVzXG51dGlsLmNyeXB0by5saWIgPSByZXF1aXJlKCdjcnlwdG8tYnJvd3NlcmlmeScpO1xudXRpbC5CdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xudXRpbC51cmwgPSByZXF1aXJlKCd1cmwvJyk7XG51dGlsLnF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcvJyk7XG51dGlsLmVudmlyb25tZW50ID0gJ2pzJztcblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xubW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5cbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbicpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NvZ25pdG9faWRlbnRpdHlfY3JlZGVudGlhbHMnKTtcbnJlcXVpcmUoJy4vY3JlZGVudGlhbHMvc2FtbF9jcmVkZW50aWFscycpO1xuXG4vLyBMb2FkIHRoZSBET01QYXJzZXIgWE1MIHBhcnNlclxuQVdTLlhNTC5QYXJzZXIgPSByZXF1aXJlKCcuL3htbC9icm93c2VyX3BhcnNlcicpO1xuXG4vLyBMb2FkIHRoZSBYSFIgSHR0cENsaWVudFxucmVxdWlyZSgnLi9odHRwL3hocicpO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gIHByb2Nlc3MgPSB7XG4gICAgYnJvd3NlcjogdHJ1ZVxuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJfbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEpzb25CdWlsZGVyID0gcmVxdWlyZSgnLi4vanNvbi9idWlsZGVyJyk7XG52YXIgSnNvblBhcnNlciA9IHJlcXVpcmUoJy4uL2pzb24vcGFyc2VyJyk7XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICB2YXIgYXBpID0gcmVxLnNlcnZpY2UuYXBpO1xuICB2YXIgdGFyZ2V0ID0gYXBpLnRhcmdldFByZWZpeCArICcuJyArIGFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm5hbWU7XG4gIHZhciB2ZXJzaW9uID0gYXBpLmpzb25WZXJzaW9uIHx8ICcxLjAnO1xuICB2YXIgaW5wdXQgPSBhcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcblxuICBpZiAodmVyc2lvbiA9PT0gMSkgdmVyc2lvbiA9ICcxLjAnO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zIHx8IHt9LCBpbnB1dCk7XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtYW16LWpzb24tJyArIHZlcnNpb247XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVRhcmdldCddID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICB2YXIgZXJyb3IgPSB7fTtcbiAgdmFyIGh0dHBSZXNwb25zZSA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuXG4gIGVycm9yLmNvZGUgPSBodHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLWVycm9ydHlwZSddIHx8ICdVbmtub3duRXJyb3InO1xuICBpZiAodHlwZW9mIGVycm9yLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLmNvZGUuc3BsaXQoJzonKVswXTtcbiAgfVxuXG4gIGlmIChodHRwUmVzcG9uc2UuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlID0gSlNPTi5wYXJzZShodHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpKTtcbiAgICAgIGlmIChlLl9fdHlwZSB8fCBlLmNvZGUpIHtcbiAgICAgICAgZXJyb3IuY29kZSA9IChlLl9fdHlwZSB8fCBlLmNvZGUpLnNwbGl0KCcjJykucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1JlcXVlc3RFbnRpdHlUb29MYXJnZScpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9ICdSZXF1ZXN0IGJvZHkgbXVzdCBiZSBsZXNzIHRoYW4gMSBNQic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gKGUubWVzc2FnZSB8fCBlLk1lc3NhZ2UgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpIHx8ICd7fSc7XG4gIGlmIChyZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY29udmVydFJlc3BvbnNlVHlwZXMgPT09IGZhbHNlKSB7XG4gICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIHNoYXBlID0gb3BlcmF0aW9uLm91dHB1dCB8fCB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICByZXNwLmRhdGEgPSBwYXJzZXIucGFyc2UoYm9keSwgc2hhcGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL2pzb24uanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25CdWlsZGVyKCkgeyB9XG5cbkpzb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgdmFyIHN0cnVjdCA9IHt9O1xuICB1dGlsLmVhY2goc3RydWN0dXJlLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlKSB7XG4gICAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IG1lbWJlclNoYXBlLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyU2hhcGUubmFtZSA6IG5hbWU7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0cnVjdFtsb2NhdGlvbk5hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBvdXQucHVzaChyZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTWFwKG1hcCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1dpcmVGb3JtYXQodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25CdWlsZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9idWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBKc29uUGFyc2VyKCkgeyB9XG5cbkpzb25QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoSlNPTi5wYXJzZSh2YWx1ZSksIHNoYXBlKTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiB0cmFuc2xhdGVTdHJ1Y3R1cmUodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gdHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiB0cmFuc2xhdGVMaXN0KHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVN0cnVjdHVyZShzdHJ1Y3R1cmUsIHNoYXBlKSB7XG4gIGlmIChzdHJ1Y3R1cmUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgc3RydWN0ID0ge307XG4gIHZhciBzaGFwZU1lbWJlcnMgPSBzaGFwZS5tZW1iZXJzO1xuICB1dGlsLmVhY2goc2hhcGVNZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXJTaGFwZSkge1xuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RydWN0dXJlLCBsb2NhdGlvbk5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJ1Y3R1cmVbbG9jYXRpb25OYW1lXTtcbiAgICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgc3RydWN0W25hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0gW107XG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dC5wdXNoKG51bGwpO1xuICAgIGVsc2Ugb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIGlmIChtYXAgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB2YXIgb3V0ID0ge307XG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBvdXRba2V5XSA9IG51bGw7XG4gICAgZWxzZSBvdXRba2V5XSA9IHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlLnRvVHlwZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBhcnNlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2pzb24vcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUT0tfTk9UOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTm90RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW3JpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfU1RBUjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhIG11bHRpc2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIFthLCBiLCAqXVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0ge3R5cGU6IFwiSWRlbnRpdHlcIn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJWYWx1ZVByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZCh0b2tlbi50eXBlLCB7dHlwZTogXCJJZGVudGl0eVwifSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbe3R5cGU6IFwiSWRlbnRpdHlcIn1dfTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19OVU1CRVIgfHwgdGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RJZlNsaWNlKHt0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1NUQVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkKDEpID09PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifSwgcmlnaHRdfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgY2FzZSBUT0tfRVhQUkVGOlxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuRXhwcmVmKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJFeHByZXNzaW9uUmVmZXJlbmNlXCIsIGNoaWxkcmVuOiBbZXhwcmVzc2lvbl19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUlBBUkVOKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DVVJSRU5UKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlZDogZnVuY3Rpb24odG9rZW5OYW1lLCBsZWZ0KSB7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgc3dpdGNoKHRva2VuTmFtZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0RPVDpcbiAgICAgICAgICAgIHZhciByYnAgPSBiaW5kaW5nUG93ZXIuRG90O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1NUQVIpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlN1YmV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyBhIHByb2plY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19TVEFSKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0aGlzLl9sb29rYWhlYWRUb2tlbigwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9tYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gdG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIHRva2VuVHlwZSArIFwiLCBnb3Q6IFwiICsgdC50eXBlKTtcbiAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2Vycm9yVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlICsgXCIpOiBcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcblxuXG4gICAgICBfcGFyc2VJbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTiB8fCB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTbGljZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9sb29rYWhlYWRUb2tlbigwKS52YWx1ZX07XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3Byb2plY3RJZlNsaWNlOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBpbmRleEV4cHIgPSB7dHlwZTogXCJJbmRleEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBcIlNsaWNlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtpbmRleEV4cHIsIHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuU3RhcildXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4RXhwcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VTbGljZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gd2hlcmUgZWFjaCBwYXJ0IGlzIG9wdGlvbmFsLCBhcyB3ZWxsIGFzIHRoZSBsYXN0XG4gICAgICAgICAgLy8gY29sb24uXG4gICAgICAgICAgdmFyIHBhcnRzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudFRva2VuICE9PSBUT0tfUkJSQUNLRVQgJiYgaW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnRzXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZUNvbXBhcmF0b3I6IGZ1bmN0aW9uKGxlZnQsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJDb21wYXJhdG9yXCIsIG5hbWU6IGNvbXBhcmF0b3IsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZURvdFJIUzogZnVuY3Rpb24ocmJwKSB7XG4gICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB2YXIgZXhwclRva2VucyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUiwgVE9LX1NUQVJdO1xuICAgICAgICAgIGlmIChleHByVG9rZW5zLmluZGV4T2YobG9va2FoZWFkKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0UpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VQcm9qZWN0aW9uUkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLl9sb29rYWhlYWQoMCldIDwgMTApIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19GSUxURVIpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0RPVCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfRE9UKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5dGFueCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSArIFwiKFwiICsgdC50eXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0TGlzdFwiLCBjaGlsZHJlbjogZXhwcmVzc2lvbnN9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyVHlwZXMgPSBbVE9LX1VOUVVPVEVESURFTlRJRklFUiwgVE9LX1FVT1RFRElERU5USUZJRVJdO1xuICAgICAgICB2YXIga2V5VG9rZW4sIGtleU5hbWUsIHZhbHVlLCBub2RlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAga2V5VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllclR5cGVzLmluZGV4T2Yoa2V5VG9rZW4udHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaWRlbnRpZmllciB0b2tlbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU5hbWUgPSBrZXlUb2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTE9OKTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICBub2RlID0ge3R5cGU6IFwiS2V5VmFsdWVQYWlyXCIsIG5hbWU6IGtleU5hbWUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgICAgcGFpcnMucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJNdWx0aVNlbGVjdEhhc2hcIiwgY2hpbGRyZW46IHBhaXJzfTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIFRyZWVJbnRlcnByZXRlcihydW50aW1lKSB7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgfVxuXG4gIFRyZWVJbnRlcnByZXRlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZWFyY2g6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQsIGN1cnJlbnQsIHJlc3VsdCwgZmlyc3QsIHNlY29uZCwgZmllbGQsIGxlZnQsIHJpZ2h0LCBjb2xsZWN0ZWQsIGk7XG4gICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGN1cnJlbnRTcGVjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgKyBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3R5cGVNYXRjaGVzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBhcmdWYWx1ZSkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9OVU1CRVIgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgdHlwZSBjYW4gZWl0aGVyIGp1c3QgYmUgYXJyYXksXG4gICAgICAgICAgICAvLyBvciBpdCBjYW4gcmVxdWlyZSBhIHNwZWNpZmljIHN1YnR5cGUgKGFycmF5IG9mIG51bWJlcnMpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBjYXNlIGlzIGlmIFwiYXJyYXlcIiB3aXRoIG5vIHN1YnR5cGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2hlY2sgc3VidHlwZXMuXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIGhhcyBwb3RlbnRpYWwgdG8gYmUgaW1wcm92ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90eXBlTWF0Y2hlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUeXBlTmFtZShhcmdWYWx1ZVtpXSksIHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VHlwZU5hbWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX1NUUklORztcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQk9PTEVBTjtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bGxdXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwcmVmLiAgSWYgaXQgaGFzLCBpdCdzIGJlZW5cbiAgICAgICAgICAgICAgLy8gdGFnZ2VkIHdpdGggYSBqbWVzcGF0aFR5cGUgYXR0ciBvZiAnRXhwcmVmJztcbiAgICAgICAgICAgICAgaWYgKG9iai5qbWVzcGF0aFR5cGUgPT09IFRPS19FWFBSRUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9FWFBSRUY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfT0JKRUNUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU3RhcnRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGFzdEluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uRW5kc1dpdGg6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgc3VmZml4ID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gc2VhcmNoU3RyLmluZGV4T2Yoc3VmZml4LCBzZWFyY2hTdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25SZXZlcnNlOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0ciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgcmV2ZXJzZWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvcmlnaW5hbFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXZlcnNlZFN0ciArPSBvcmlnaW5hbFN0cltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkU3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXZlcnNlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdLnNsaWNlKDApO1xuICAgICAgICAgIHJldmVyc2VkQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZXZlcnNlZEFycmF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkFiczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ2VpbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQXZnOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBpbnB1dEFycmF5Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ29udGFpbnM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA+PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25GbG9vcjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkxlbmd0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgaWYgKCFpc09iamVjdChyZXNvbHZlZEFyZ3NbMF0pKSB7XG4gICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlJ3Mgbm8gd2F5IHRvIGdldCB0aGUgbGVuZ3RoXG4gICAgICAgICAvLyBvZiBhbiBvYmplY3Qgd2l0aG91dCBPKG4pIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QuXG4gICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKS5sZW5ndGg7XG4gICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXA6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIGludGVycHJldGVyID0gdGhpcy5faW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXBwZWQucHVzaChpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBlbGVtZW50c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWVyZ2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWF4RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1heEVsZW1lbnQubG9jYWxlQ29tcGFyZShlbGVtZW50c1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXhFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1heEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWluRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmxvY2FsZUNvbXBhcmUobWluRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtaW5FbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdW06IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbGlzdFRvU3VtID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0VG9TdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGxpc3RUb1N1bVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIGNhc2UgVFlQRV9BUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX09CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9FWFBSRUY6XG4gICAgICAgICAgICByZXR1cm4gXCJleHByZWZcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25LZXlzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblZhbHVlczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uSm9pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBqb2luQ2hhciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RKb2luID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gbGlzdEpvaW4uam9pbihqb2luQ2hhcik7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvQXJyYXk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSA9PT0gVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzb2x2ZWRBcmdzWzBdXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvTnVtYmVyOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSArcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk5vdE51bGw6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1tpXSkgIT09IFRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnQ6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIHNvcnRlZEFycmF5LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Tb3J0Qnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHZhciByZXF1aXJlZFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShcbiAgICAgICAgICAgIGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHNvcnRlZEFycmF5WzBdKSk7XG4gICAgICAgIGlmIChbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXS5pbmRleE9mKHJlcXVpcmVkVHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSBzdGFibGUgc29ydCBvdXQgb2YgYW4gdW5zdGFibGVcbiAgICAgICAgLy8gc29ydCBhbGdvcml0aG0sIHdlIGRlY29yYXRlL3NvcnQvdW5kZWNvcmF0ZSAoRFNVKVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG5ldyBsaXN0IG9mIFtpbmRleCwgZWxlbWVudF0gcGFpcnMuXG4gICAgICAgIC8vIEluIHRoZSBjbXAgZnVuY3Rpb24sIGlmIHRoZSBldmFsdWF0ZWQgZWxlbWVudHMgYXJlXG4gICAgICAgIC8vIGVxdWFsLCB0aGVuIHRoZSBpbmRleCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRpZWJyZWFrZXIuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBkZWNvcmF0ZWQgbGlzdCBoYXMgYmVlbiBzb3J0ZWQsIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdG8gZXh0cmFjdCB0aGUgb3JpZ2luYWwgZWxlbWVudHMuXG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY29yYXRlZC5wdXNoKFtpLCBzb3J0ZWRBcnJheVtpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZXhwckEgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBhWzFdKTtcbiAgICAgICAgICB2YXIgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICBpZiAodGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpICE9PSByZXF1aXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3I6IGV4cGVjdGVkIFwiICsgcmVxdWlyZWRUeXBlICsgXCIsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFR5cGVOYW1lKGV4cHJBKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwckEgPCBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGVxdWFsIGNvbXBhcmUgdGhlIGl0ZW1zIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBvcmRlciB0byBtYWludGFpbiByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBrZXlzXG4gICAgICAgICAgICAvLyAoaS5lLiB0byBnZXQgYSBzdGFibGUgc29ydCkuXG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5kZWNvcmF0ZTogZXh0cmFjdCBvdXQgdGhlIG9yaWdpbmFsIGxpc3QgZWxlbWVudHMuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVjb3JhdGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc29ydGVkQXJyYXlbal0gPSBkZWNvcmF0ZWRbal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXhCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIHZhciByZXNvbHZlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXSk7XG4gICAgICB2YXIgbWF4TnVtYmVyID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICBtYXhOdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1heFJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhSZWNvcmQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbkJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtaW5OdW1iZXIgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5SZWNvcmQ7XG4gICAgICB2YXIgY3VycmVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0ga2V5RnVuY3Rpb24ocmVzb2x2ZWRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgbWluTnVtYmVyKSB7XG4gICAgICAgICAgbWluTnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUmVjb3JkO1xuICAgIH0sXG5cbiAgICBjcmVhdGVLZXlGdW5jdGlvbjogZnVuY3Rpb24oZXhwcmVmTm9kZSwgYWxsb3dlZFR5cGVzKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBrZXlGdW5jID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHgpO1xuICAgICAgICBpZiAoYWxsb3dlZFR5cGVzLmluZGV4T2YodGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCkpIDwgMCkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgb25lIG9mIFwiICsgYWxsb3dlZFR5cGVzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHJlY2VpdmVkIFwiICsgdGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtleUZ1bmM7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZShzdHJlYW0pIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgIHJldHVybiBsZXhlci50b2tlbml6ZShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkLiAgQm90aCB0aGUgaW50ZXJwcmV0ZXIgYW5kIHJ1bnRpbWUgZGVwZW5kIG9uXG4gICAgICAvLyBlYWNoIG90aGVyLiAgVGhlIHJ1bnRpbWUgbmVlZHMgdGhlIGludGVycHJldGVyIHRvIHN1cHBvcnQgZXhwcmVmcy5cbiAgICAgIC8vIFRoZXJlJ3MgbGlrZWx5IGEgY2xlYW4gd2F5IHRvIGF2b2lkIHRoZSBjeWNsaWMgZGVwZW5kZW5jeS5cbiAgICAgIHZhciBydW50aW1lID0gbmV3IFJ1bnRpbWUoKTtcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IG5ldyBUcmVlSW50ZXJwcmV0ZXIocnVudGltZSk7XG4gICAgICBydW50aW1lLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgdmFyIG5vZGUgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXIuc2VhcmNoKG5vZGUsIGRhdGEpO1xuICB9XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuICBleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuICBleHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbiAgZXhwb3J0cy5zdHJpY3REZWVwRXF1YWwgPSBzdHJpY3REZWVwRXF1YWw7XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuam1lc3BhdGggPSB7fSA6IGV4cG9ydHMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvam1lc3BhdGgvam1lc3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZnMgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGhhc2g6IGhhc2ggfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2hlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFF1ZXJ5UGFyYW1TZXJpYWxpemVyID0gcmVxdWlyZSgnLi4vcXVlcnkvcXVlcnlfcGFyYW1fc2VyaWFsaXplcicpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vbW9kZWwvc2hhcGUnKTtcblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPVxuICAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnO1xuICBodHRwUmVxdWVzdC5wYXJhbXMgPSB7XG4gICAgVmVyc2lvbjogcmVxLnNlcnZpY2UuYXBpLmFwaVZlcnNpb24sXG4gICAgQWN0aW9uOiBvcGVyYXRpb24ubmFtZVxuICB9O1xuXG4gIC8vIGNvbnZlcnQgdGhlIHJlcXVlc3QgcGFyYW1ldGVycyBpbnRvIGEgbGlzdCBvZiBxdWVyeSBwYXJhbXMsXG4gIC8vIGUuZy4gRGVlcGx5Lk5lc3RlZFBhcmFtLjAuTmFtZT12YWx1ZVxuICB2YXIgYnVpbGRlciA9IG5ldyBRdWVyeVBhcmFtU2VyaWFsaXplcigpO1xuICBidWlsZGVyLnNlcmlhbGl6ZShyZXEucGFyYW1zLCBvcGVyYXRpb24uaW5wdXQsIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaHR0cFJlcXVlc3QucGFyYW1zW25hbWVdID0gdmFsdWU7XG4gIH0pO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gdXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKGh0dHBSZXF1ZXN0LnBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIHZhciBkYXRhLCBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpO1xuICBpZiAoYm9keS5tYXRjaCgnPFVua25vd25PcGVyYXRpb25FeGNlcHRpb24nKSkge1xuICAgIGRhdGEgPSB7XG4gICAgICBDb2RlOiAnVW5rbm93bk9wZXJhdGlvbicsXG4gICAgICBNZXNzYWdlOiAnVW5rbm93biBvcGVyYXRpb24gJyArIHJlc3AucmVxdWVzdC5vcGVyYXRpb25cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gbmV3IEFXUy5YTUwuUGFyc2VyKCkucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgQ29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgTWVzc2FnZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGF0YS5yZXF1ZXN0SWQgJiYgIXJlc3AucmVxdWVzdElkKSByZXNwLnJlcXVlc3RJZCA9IGRhdGEucmVxdWVzdElkO1xuICBpZiAoZGF0YS5FcnJvcnMpIGRhdGEgPSBkYXRhLkVycm9ycztcbiAgaWYgKGRhdGEuRXJyb3IpIGRhdGEgPSBkYXRhLkVycm9yO1xuICBpZiAoZGF0YS5Db2RlKSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IGRhdGEuQ29kZSxcbiAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgbWVzc2FnZTogbnVsbFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgc2hhcGUgPSBvcGVyYXRpb24ub3V0cHV0IHx8IHt9O1xuICB2YXIgb3JpZ1J1bGVzID0gc2hhcGU7XG5cbiAgaWYgKG9yaWdSdWxlcy5yZXN1bHRXcmFwcGVyKSB7XG4gICAgdmFyIHRtcCA9IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9KTtcbiAgICB0bXAubWVtYmVyc1tvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0gPSBzaGFwZTtcbiAgICB0bXAubWVtYmVyTmFtZXMgPSBbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdO1xuICAgIHV0aWwucHJvcGVydHkoc2hhcGUsICduYW1lJywgc2hhcGUucmVzdWx0V3JhcHBlcik7XG4gICAgc2hhcGUgPSB0bXA7XG4gIH1cblxuICB2YXIgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG5cbiAgLy8gVE9ETzogUmVmYWN0b3IgWE1MIFBhcnNlciB0byBwYXJzZSBSZXF1ZXN0SWQgZnJvbSByZXNwb25zZS5cbiAgaWYgKHNoYXBlICYmIHNoYXBlLm1lbWJlcnMgJiYgIXNoYXBlLm1lbWJlcnMuX1hBTVpSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkU2hhcGUgPSBTaGFwZS5jcmVhdGUoXG4gICAgICB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICB7IGFwaTogeyBwcm90b2NvbDogJ3F1ZXJ5JyB9IH0sXG4gICAgICAncmVxdWVzdElkJ1xuICAgICk7XG4gICAgc2hhcGUubWVtYmVycy5fWEFNWlJlcXVlc3RJZCA9IHJlcXVlc3RJZFNoYXBlO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYXJzZXIucGFyc2UocmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpLCBzaGFwZSk7XG4gIHJlc3AucmVxdWVzdElkID0gZGF0YS5fWEFNWlJlcXVlc3RJZCB8fCBkYXRhLnJlcXVlc3RJZDtcblxuICBpZiAoZGF0YS5fWEFNWlJlcXVlc3RJZCkgZGVsZXRlIGRhdGEuX1hBTVpSZXF1ZXN0SWQ7XG5cbiAgaWYgKG9yaWdSdWxlcy5yZXN1bHRXcmFwcGVyKSB7XG4gICAgaWYgKGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdKSB7XG4gICAgICB1dGlsLnVwZGF0ZShkYXRhLCBkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSk7XG4gICAgICBkZWxldGUgZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl07XG4gICAgfVxuICB9XG5cbiAgcmVzcC5kYXRhID0gZGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1lbW9pemVkUHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gbWVtb2l6ZShuYW1lLCB2YWx1ZSwgZm4sIG5hbWVUcikge1xuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsIG5hbWVUcihuYW1lKSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZuKG5hbWUsIHZhbHVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oaXRlcmFibGUsIG9wdGlvbnMsIGZuLCBuYW1lVHIpIHtcbiAgbmFtZVRyID0gbmFtZVRyIHx8IFN0cmluZztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvciAodmFyIGlkIGluIGl0ZXJhYmxlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaWQpKSB7XG4gICAgICBtZW1vaXplLmNhbGwoc2VsZiwgaWQsIGl0ZXJhYmxlW2lkXSwgZm4sIG5hbWVUcik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL2NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgUmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpO1xudmFyIEpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcbnZhciBKc29uQnVpbGRlciA9IHJlcXVpcmUoJy4uL2pzb24vYnVpbGRlcicpO1xudmFyIEpzb25QYXJzZXIgPSByZXF1aXJlKCcuLi9qc29uL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUJvZHkocmVxKSB7XG4gIHZhciBidWlsZGVyID0gbmV3IEpzb25CdWlsZGVyKCk7XG4gIHZhciBpbnB1dCA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuXG4gIGlmIChpbnB1dC5wYXlsb2FkKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHZhciBwYXlsb2FkU2hhcGUgPSBpbnB1dC5tZW1iZXJzW2lucHV0LnBheWxvYWRdO1xuICAgIHBhcmFtcyA9IHJlcS5wYXJhbXNbaW5wdXQucGF5bG9hZF07XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIuYnVpbGQocGFyYW1zLCBwYXlsb2FkU2hhcGUpO1xuICAgICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEpO1xuICAgIH0gZWxzZSB7IC8vIG5vbi1KU09OIHBheWxvYWRcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gcGFyYW1zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIuYnVpbGQocmVxLnBhcmFtcywgaW5wdXQpO1xuICAgIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSkge1xuICBpZiAoIXJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkge1xuICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gR0VUL0hFQUQvREVMRVRFXG4gIGlmIChbJ0dFVCcsICdIRUFEJywgJ0RFTEVURSddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgSnNvbi5leHRyYWN0RXJyb3IocmVzcCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RGF0YShyZXNwKTtcblxuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5vdXRwdXQgfHwge307XG4gIGlmIChydWxlcy5wYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBydWxlcy5tZW1iZXJzW3J1bGVzLnBheWxvYWRdO1xuICAgIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgICBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJyB8fCBwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0gPSBwYXJzZXIucGFyc2UoYm9keSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGF0YSA9IHJlc3AuZGF0YTtcbiAgICBKc29uLmV4dHJhY3REYXRhKHJlc3ApO1xuICAgIHJlc3AuZGF0YSA9IHV0aWwubWVyZ2UoZGF0YSwgcmVzcC5kYXRhKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0X2pzb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFJlc3QgPSByZXF1aXJlKCcuL3Jlc3QnKTtcblxuZnVuY3Rpb24gcG9wdWxhdGVCb2R5KHJlcSkge1xuICB2YXIgaW5wdXQgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgQVdTLlhNTC5CdWlsZGVyKCk7XG4gIHZhciBwYXJhbXMgPSByZXEucGFyYW1zO1xuXG4gIHZhciBwYXlsb2FkID0gaW5wdXQucGF5bG9hZDtcbiAgaWYgKHBheWxvYWQpIHtcbiAgICB2YXIgcGF5bG9hZE1lbWJlciA9IGlucHV0Lm1lbWJlcnNbcGF5bG9hZF07XG4gICAgcGFyYW1zID0gcGFyYW1zW3BheWxvYWRdO1xuICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHBheWxvYWRNZW1iZXIubmFtZTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci50b1hNTChwYXJhbXMsIHBheWxvYWRNZW1iZXIsIHJvb3RFbGVtZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgeyAvLyBub24teG1sIHBheWxvYWRcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gcGFyYW1zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIudG9YTUwocGFyYW1zLCBpbnB1dCwgaW5wdXQubmFtZSB8fFxuICAgICAgaW5wdXQuc2hhcGUgfHwgdXRpbC5zdHJpbmcudXBwZXJGaXJzdChyZXEub3BlcmF0aW9uKSArICdSZXF1ZXN0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICBSZXN0LmJ1aWxkUmVxdWVzdChyZXEpO1xuXG4gIC8vIG5ldmVyIHNlbmQgYm9keSBwYXlsb2FkIG9uIEdFVC9IRUFEXG4gIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5kZXhPZihyZXEuaHR0cFJlcXVlc3QubWV0aG9kKSA8IDApIHtcbiAgICBwb3B1bGF0ZUJvZHkocmVxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICBSZXN0LmV4dHJhY3RFcnJvcihyZXNwKTtcblxuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gbmV3IEFXUy5YTUwuUGFyc2VyKCkucGFyc2UocmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRhdGEgPSB7XG4gICAgICBDb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgTWVzc2FnZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5FcnJvcnMpIGRhdGEgPSBkYXRhLkVycm9ycztcbiAgaWYgKGRhdGEuRXJyb3IpIGRhdGEgPSBkYXRhLkVycm9yO1xuICBpZiAoZGF0YS5Db2RlKSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IGRhdGEuQ29kZSxcbiAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgbWVzc2FnZTogbnVsbFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RGF0YShyZXNwKTtcblxuICB2YXIgcGFyc2VyO1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgYm9keSA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHk7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIG91dHB1dCA9IG9wZXJhdGlvbi5vdXRwdXQ7XG5cbiAgdmFyIHBheWxvYWQgPSBvdXRwdXQucGF5bG9hZDtcbiAgaWYgKHBheWxvYWQpIHtcbiAgICB2YXIgcGF5bG9hZE1lbWJlciA9IG91dHB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIHBheWxvYWRNZW1iZXIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnYmluYXJ5JyB8fCBwYXlsb2FkTWVtYmVyLmlzU3RyZWFtaW5nKSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSBwYXlsb2FkTWVtYmVyLnRvVHlwZShib2R5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9keS5sZW5ndGggPiAwKSB7XG4gICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgdmFyIGRhdGEgPSBwYXJzZXIucGFyc2UoYm9keS50b1N0cmluZygpLCBvdXRwdXQpO1xuICAgIHV0aWwudXBkYXRlKHJlc3AuZGF0YSwgZGF0YSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF94bWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERlY2xhcmF0aW9uLCBYTUxOb2RlLCBjcmVhdGUsIGlzT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEZWNsYXJhdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEZWNsYXJhdGlvbihwYXJlbnQsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgWE1MRGVjbGFyYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChpc09iamVjdCh2ZXJzaW9uKSkge1xuICAgICAgICByZWYgPSB2ZXJzaW9uLCB2ZXJzaW9uID0gcmVmLnZlcnNpb24sIGVuY29kaW5nID0gcmVmLmVuY29kaW5nLCBzdGFuZGFsb25lID0gcmVmLnN0YW5kYWxvbmU7XG4gICAgICB9XG4gICAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgdmVyc2lvbiA9ICcxLjAnO1xuICAgICAgfVxuICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy5zdHJpbmdpZnkueG1sVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgIGlmIChlbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSB0aGlzLnN0cmluZ2lmeS54bWxFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhbG9uZSA9IHRoaXMuc3RyaW5naWZ5LnhtbFN0YW5kYWxvbmUoc3RhbmRhbG9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRGVjbGFyYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPD94bWwnO1xuICAgICAgciArPSAnIHZlcnNpb249XCInICsgdGhpcy52ZXJzaW9uICsgJ1wiJztcbiAgICAgIGlmICh0aGlzLmVuY29kaW5nICE9IG51bGwpIHtcbiAgICAgICAgciArPSAnIGVuY29kaW5nPVwiJyArIHRoaXMuZW5jb2RpbmcgKyAnXCInO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gJyBzdGFuZGFsb25lPVwiJyArIHRoaXMuc3RhbmRhbG9uZSArICdcIic7XG4gICAgICB9XG4gICAgICByICs9ICc/Pic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRGVjbGFyYXRpb247XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEZWNsYXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxBdHRyaWJ1dGUsIFhNTEVsZW1lbnQsIFhNTE5vZGUsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgY3JlYXRlLCBldmVyeSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxuICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnbG9kYXNoL2lzRnVuY3Rpb24nKTtcblxuICBldmVyeSA9IHJlcXVpcmUoJ2xvZGFzaC9ldmVyeScpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBYTUxBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL1hNTEF0dHJpYnV0ZScpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxFbGVtZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRWxlbWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxFbGVtZW50KHBhcmVudCwgbmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgWE1MRWxlbWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICBpZiAoYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXR0LCBhdHROYW1lLCBjbG9uZWRTZWxmLCBpLCBsZW4sIHBpLCByZWYsIHJlZjE7XG4gICAgICBjbG9uZWRTZWxmID0gY3JlYXRlKFhNTEVsZW1lbnQucHJvdG90eXBlLCB0aGlzKTtcbiAgICAgIGlmIChjbG9uZWRTZWxmLmlzUm9vdCkge1xuICAgICAgICBjbG9uZWRTZWxmLmRvY3VtZW50T2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgcmVmID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChhdHROYW1lIGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmW2F0dE5hbWVdO1xuICAgICAgICBjbG9uZWRTZWxmLmF0dHJpYnV0ZXNbYXR0TmFtZV0gPSBhdHQuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICByZWYxID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBpID0gcmVmMVtpXTtcbiAgICAgICAgY2xvbmVkU2VsZi5pbnN0cnVjdGlvbnMucHVzaChwaS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2xvbmVkQ2hpbGQ7XG4gICAgICAgIGNsb25lZENoaWxkID0gY2hpbGQuY2xvbmUoKTtcbiAgICAgICAgY2xvbmVkQ2hpbGQucGFyZW50ID0gY2xvbmVkU2VsZjtcbiAgICAgICAgcmV0dXJuIGNsb25lZFNlbGYuY2hpbGRyZW4ucHVzaChjbG9uZWRDaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbG9uZWRTZWxmO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dE5hbWUsIGF0dFZhbHVlO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0VmFsdWUgPSBuYW1lW2F0dE5hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBOdWxsQXR0cmlidXRlcyB8fCAodmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBuZXcgWE1MQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBpLCBsZW47XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBuYW1lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYXR0TmFtZSA9IG5hbWVbaV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHROYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBpLCBpbnNUYXJnZXQsIGluc1ZhbHVlLCBpbnN0cnVjdGlvbiwgbGVuO1xuICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGFyZ2V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaW5zVGFyZ2V0ID0gdGFyZ2V0W2ldO1xuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24oaW5zVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaW5zVGFyZ2V0IGluIHRhcmdldCkge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHRhcmdldCwgaW5zVGFyZ2V0KSkgY29udGludWU7XG4gICAgICAgICAgaW5zVmFsdWUgPSB0YXJnZXRbaW5zVGFyZ2V0XTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCwgaW5zVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGluc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBjaGlsZCwgaSwgaW5kZW50LCBpbnN0cnVjdGlvbiwgaiwgbGVuLCBsZW4xLCBuYW1lLCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIHJlZjMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSByZWYzW2ldO1xuICAgICAgICByICs9IGluc3RydWN0aW9uLnRvU3RyaW5nKG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwnICsgdGhpcy5uYW1lO1xuICAgICAgcmVmNCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAobmFtZSBpbiByZWY0KSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZjQsIG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgYXR0ID0gcmVmNFtuYW1lXTtcbiAgICAgICAgciArPSBhdHQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgZXZlcnkodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS52YWx1ZSA9PT0gJyc7XG4gICAgICB9KSkge1xuICAgICAgICByICs9ICcvPic7XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldHR5ICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICh0aGlzLmNoaWxkcmVuWzBdLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgIHIgKz0gJz4nO1xuICAgICAgICByICs9IHRoaXMuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgICAgIHIgKz0gJzwvJyArIHRoaXMubmFtZSArICc+JztcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSAnPic7XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmVmNSA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWY1Lmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmNVtqXTtcbiAgICAgICAgICByICs9IGNoaWxkLnRvU3RyaW5nKG9wdGlvbnMsIGxldmVsICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAnPC8nICsgdGhpcy5uYW1lICsgJz4nO1xuICAgICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5hID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmkgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEVsZW1lbnQ7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgY3JlYXRlO1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ocGFyZW50LCB0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBpbnN0cnVjdGlvbiB0YXJnZXRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldCA9IHRoaXMuc3RyaW5naWZ5Lmluc1RhcmdldCh0YXJnZXQpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5pbnNWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZShYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzw/JztcbiAgICAgIHIgKz0gdGhpcy50YXJnZXQ7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICByICs9ICcgJyArIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgICByICs9ICc/Pic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTE5vZGUsIGNyZWF0ZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxDRGF0YSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTENEYXRhLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTENEYXRhKHBhcmVudCwgdGV4dCkge1xuICAgICAgWE1MQ0RhdGEuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBDREFUQSB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5zdHJpbmdpZnkuY2RhdGEodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MQ0RhdGEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKFhNTENEYXRhLnByb3RvdHlwZSwgdGhpcyk7XG4gICAgfTtcblxuICAgIFhNTENEYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwhW0NEQVRBWycgKyB0aGlzLnRleHQgKyAnXV0+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxDRGF0YTtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTENEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENvbW1lbnQsIFhNTE5vZGUsIGNyZWF0ZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxDb21tZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MQ29tbWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxDb21tZW50KHBhcmVudCwgdGV4dCkge1xuICAgICAgWE1MQ29tbWVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNvbW1lbnQgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RyaW5naWZ5LmNvbW1lbnQodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MQ29tbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoWE1MQ29tbWVudC5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxDb21tZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwhLS0gJyArIHRoaXMudGV4dCArICcgLS0+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxDb21tZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ29tbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDRGF0YSwgWE1MQ29tbWVudCwgWE1MRFREQXR0TGlzdCwgWE1MRFRERWxlbWVudCwgWE1MRFRERW50aXR5LCBYTUxEVEROb3RhdGlvbiwgWE1MRG9jVHlwZSwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBjcmVhdGUsIGlzT2JqZWN0O1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuXG4gIFhNTENEYXRhID0gcmVxdWlyZSgnLi9YTUxDRGF0YScpO1xuXG4gIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERW50aXR5ID0gcmVxdWlyZSgnLi9YTUxEVERFbnRpdHknKTtcblxuICBYTUxEVERFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxEVERFbGVtZW50Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERvY1R5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRG9jVHlwZShwYXJlbnQsIHB1YklELCBzeXNJRCkge1xuICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgIHRoaXMuZG9jdW1lbnRPYmplY3QgPSBwYXJlbnQ7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHRoaXMuZG9jdW1lbnRPYmplY3Quc3RyaW5naWZ5O1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgaWYgKGlzT2JqZWN0KHB1YklEKSkge1xuICAgICAgICByZWYgPSBwdWJJRCwgcHViSUQgPSByZWYucHViSUQsIHN5c0lEID0gcmVmLnN5c0lEO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0lEID09IG51bGwpIHtcbiAgICAgICAgcmVmMSA9IFtwdWJJRCwgc3lzSURdLCBzeXNJRCA9IHJlZjFbMF0sIHB1YklEID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRChwdWJJRCk7XG4gICAgICB9XG4gICAgICBpZiAoc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQoc3lzSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERWxlbWVudCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmF0dExpc3QgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxEVERBdHRMaXN0KHRoaXMsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERW50aXR5KHRoaXMsIGZhbHNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLnBFbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERW50aXR5KHRoaXMsIHRydWUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUubm90YXRpb24gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRETm90YXRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxDRGF0YSh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MQ29tbWVudCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmluc3RydWN0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE9iamVjdC5yb290KCk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmRvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE9iamVjdDtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCBpbmRlbnQsIGxlbiwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8IURPQ1RZUEUgJyArIHRoaXMucm9vdCgpLm5hbWU7XG4gICAgICBpZiAodGhpcy5wdWJJRCAmJiB0aGlzLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgdGhpcy5wdWJJRCArICdcIiBcIicgKyB0aGlzLnN5c0lEICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zeXNJRCkge1xuICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICByICs9ICcgWyc7XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmVmMyA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjNbaV07XG4gICAgICAgICAgciArPSBjaGlsZC50b1N0cmluZyhvcHRpb25zLCBsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJ10nO1xuICAgICAgfVxuICAgICAgciArPSAnPic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmF0dCA9IGZ1bmN0aW9uKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dExpc3QoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRpdHkobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5wZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBFbnRpdHkobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90YXRpb24obmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5kYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5jb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdCgpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5kb2MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEb2NUeXBlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEb2NUeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG52YXIgT3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4vc2hhcGUnKTtcbnZhciBQYWdpbmF0b3IgPSByZXF1aXJlKCcuL3BhZ2luYXRvcicpO1xudmFyIFJlc291cmNlV2FpdGVyID0gcmVxdWlyZSgnLi9yZXNvdXJjZV93YWl0ZXInKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEFwaShhcGksIG9wdGlvbnMpIHtcbiAgYXBpID0gYXBpIHx8IHt9O1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hcGkgPSB0aGlzO1xuXG4gIGFwaS5tZXRhZGF0YSA9IGFwaS5tZXRhZGF0YSB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnaXNBcGknLCB0cnVlLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhcGlWZXJzaW9uJywgYXBpLm1ldGFkYXRhLmFwaVZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW5kcG9pbnRQcmVmaXgnLCBhcGkubWV0YWRhdGEuZW5kcG9pbnRQcmVmaXgpO1xuICBwcm9wZXJ0eSh0aGlzLCAnc2lnbmluZ05hbWUnLCBhcGkubWV0YWRhdGEuc2lnbmluZ05hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZ2xvYmFsRW5kcG9pbnQnLCBhcGkubWV0YWRhdGEuZ2xvYmFsRW5kcG9pbnQpO1xuICBwcm9wZXJ0eSh0aGlzLCAnc2lnbmF0dXJlVmVyc2lvbicsIGFwaS5tZXRhZGF0YS5zaWduYXR1cmVWZXJzaW9uKTtcbiAgcHJvcGVydHkodGhpcywgJ2pzb25WZXJzaW9uJywgYXBpLm1ldGFkYXRhLmpzb25WZXJzaW9uKTtcbiAgcHJvcGVydHkodGhpcywgJ3RhcmdldFByZWZpeCcsIGFwaS5tZXRhZGF0YS50YXJnZXRQcmVmaXgpO1xuICBwcm9wZXJ0eSh0aGlzLCAncHJvdG9jb2wnLCBhcGkubWV0YWRhdGEucHJvdG9jb2wpO1xuICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgYXBpLm1ldGFkYXRhLnRpbWVzdGFtcEZvcm1hdCk7XG4gIHByb3BlcnR5KHRoaXMsICd4bWxOYW1lc3BhY2VVcmknLCBhcGkubWV0YWRhdGEueG1sTmFtZXNwYWNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FiYnJldmlhdGlvbicsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlQWJicmV2aWF0aW9uKTtcbiAgcHJvcGVydHkodGhpcywgJ2Z1bGxOYW1lJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VGdWxsTmFtZSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnY2xhc3NOYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSBhcGkubWV0YWRhdGEuc2VydmljZUFiYnJldmlhdGlvbiB8fCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eQW1hem9ufEFXU1xccyp8XFwoLip8XFxzK3xcXFcrL2csICcnKTtcbiAgICBpZiAobmFtZSA9PT0gJ0VsYXN0aWNMb2FkQmFsYW5jaW5nJykgbmFtZSA9ICdFTEInO1xuICAgIHJldHVybiBuYW1lO1xuICB9KTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9ucycsIG5ldyBDb2xsZWN0aW9uKGFwaS5vcGVyYXRpb25zLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24sIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3NoYXBlcycsIG5ldyBDb2xsZWN0aW9uKGFwaS5zaGFwZXMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZSwgb3B0aW9ucyk7XG4gIH0pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAncGFnaW5hdG9ycycsIG5ldyBDb2xsZWN0aW9uKGFwaS5wYWdpbmF0b3JzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IsIG9wdGlvbnMpO1xuICB9KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3dhaXRlcnMnLCBuZXcgQ29sbGVjdGlvbihhcGkud2FpdGVycywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgd2FpdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVdhaXRlcihuYW1lLCB3YWl0ZXIsIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgYXBpLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgYXBpLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXBpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vc2hhcGUnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIG9wZXJhdGlvbi5uYW1lIHx8IG5hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXBpJywgb3B0aW9ucy5hcGksIGZhbHNlKTtcblxuICBvcGVyYXRpb24uaHR0cCA9IG9wZXJhdGlvbi5odHRwIHx8IHt9O1xuICBwcm9wZXJ0eSh0aGlzLCAnaHR0cE1ldGhvZCcsIG9wZXJhdGlvbi5odHRwLm1ldGhvZCB8fCAnUE9TVCcpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaHR0cFBhdGgnLCBvcGVyYXRpb24uaHR0cC5yZXF1ZXN0VXJpIHx8ICcvJyk7XG4gIHByb3BlcnR5KHRoaXMsICdhdXRodHlwZScsIG9wZXJhdGlvbi5hdXRodHlwZSB8fCAnJyk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnaW5wdXQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW9wZXJhdGlvbi5pbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJ1Y3R1cmUnfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZS5jcmVhdGUob3BlcmF0aW9uLmlucHV0LCBvcHRpb25zKTtcbiAgfSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnb3V0cHV0JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFvcGVyYXRpb24ub3V0cHV0KSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShvcGVyYXRpb24ub3V0cHV0LCBvcHRpb25zKTtcbiAgfSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXJyb3JzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICBpZiAoIW9wZXJhdGlvbi5lcnJvcnMpIHJldHVybiBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVyYXRpb24uZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2goU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5lcnJvcnNbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAncGFnaW5hdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYXBpLnBhZ2luYXRvcnNbbmFtZV07XG4gIH0pO1xuXG4gIGlmIChvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvbicsIG9wZXJhdGlvbi5kb2N1bWVudGF0aW9uKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvblVybCcsIG9wZXJhdGlvbi5kb2N1bWVudGF0aW9uVXJsKTtcbiAgfVxuXG4gIC8vIGlkZW1wb3RlbnRNZW1iZXJzIG9ubHkgdHJhY2tzIHRvcC1sZXZlbCBpbnB1dCBzaGFwZXNcbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnaWRlbXBvdGVudE1lbWJlcnMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWRlbXBvdGVudE1lbWJlcnMgPSBbXTtcbiAgICB2YXIgaW5wdXQgPSBzZWxmLmlucHV0O1xuICAgIHZhciBtZW1iZXJzID0gaW5wdXQubWVtYmVycztcbiAgICBpZiAoIWlucHV0Lm1lbWJlcnMpIHtcbiAgICAgIHJldHVybiBpZGVtcG90ZW50TWVtYmVycztcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtZW1iZXJzKSB7XG4gICAgICBpZiAoIW1lbWJlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyc1tuYW1lXS5pc0lkZW1wb3RlbnQgPT09IHRydWUpIHtcbiAgICAgICAgaWRlbXBvdGVudE1lbWJlcnMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkZW1wb3RlbnRNZW1iZXJzO1xuICB9KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL29wZXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgcHJvcGVydHkodGhpcywgJ2lucHV0VG9rZW4nLCBwYWdpbmF0b3IuaW5wdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbGltaXRLZXknLCBwYWdpbmF0b3IubGltaXRfa2V5KTtcbiAgcHJvcGVydHkodGhpcywgJ21vcmVSZXN1bHRzJywgcGFnaW5hdG9yLm1vcmVfcmVzdWx0cyk7XG4gIHByb3BlcnR5KHRoaXMsICdvdXRwdXRUb2tlbicsIHBhZ2luYXRvci5vdXRwdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0S2V5JywgcGFnaW5hdG9yLnJlc3VsdF9rZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2luYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3BhZ2luYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFJlc291cmNlV2FpdGVyKG5hbWUsIHdhaXRlciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgaWYgKHdhaXRlci5vcGVyYXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCh3YWl0ZXIub3BlcmF0aW9uKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrZXlzID0gW1xuICAgICd0eXBlJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdkZWxheScsXG4gICAgJ21heEF0dGVtcHRzJyxcbiAgICAnYWNjZXB0b3JzJ1xuICBdO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB3YWl0ZXJba2V5XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHByb3BlcnR5KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VXYWl0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9yZXNvdXJjZV93YWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgeW91ciBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHMsIHNwZWNpZmljYWxseSB0aGVcbiAqIHthY2Nlc3NLZXlJZH0sIHtzZWNyZXRBY2Nlc3NLZXl9LCBhbmQgb3B0aW9uYWwge3Nlc3Npb25Ub2tlbn0uXG4gKiBDcmVhdGluZyBhIGBDcmVkZW50aWFsc2Agb2JqZWN0IGFsbG93cyB5b3UgdG8gcGFzcyBhcm91bmQgeW91clxuICogc2VjdXJpdHkgaW5mb3JtYXRpb24gdG8gY29uZmlndXJhdGlvbiBhbmQgc2VydmljZSBvYmplY3RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGNsYXNzIHR5cGljYWxseSBkb2VzIG5vdCBuZWVkIHRvIGJlIGNvbnN0cnVjdGVkIG1hbnVhbGx5LFxuICogYXMgdGhlIHtBV1MuQ29uZmlnfSBhbmQge0FXUy5TZXJ2aWNlfSBjbGFzc2VzIGJvdGggYWNjZXB0IHNpbXBsZVxuICogb3B0aW9ucyBoYXNoZXMgd2l0aCB0aGUgdGhyZWUga2V5cy4gVGhlc2Ugc3RydWN0dXJlcyB3aWxsIGJlIGNvbnZlcnRlZFxuICogaW50byBDcmVkZW50aWFscyBvYmplY3RzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogIyMgRXhwaXJpbmcgYW5kIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHNcbiAqXG4gKiBPY2Nhc2lvbmFsbHkgY3JlZGVudGlhbHMgY2FuIGV4cGlyZSBpbiB0aGUgbWlkZGxlIG9mIGEgbG9uZy1ydW5uaW5nXG4gKiBhcHBsaWNhdGlvbi4gSW4gdGhpcyBjYXNlLCB0aGUgU0RLIHdpbGwgYXV0b21hdGljYWxseSBhdHRlbXB0IHRvXG4gKiByZWZyZXNoIHRoZSBjcmVkZW50aWFscyBmcm9tIHRoZSBzdG9yYWdlIGxvY2F0aW9uIGlmIHRoZSBDcmVkZW50aWFsc1xuICogY2xhc3MgaW1wbGVtZW50cyB0aGUge3JlZnJlc2h9IG1ldGhvZC5cbiAqXG4gKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGNyZWRlbnRpYWwgc3RvcmFnZSBsb2NhdGlvbiwgeW91XG4gKiB3aWxsIHdhbnQgdG8gY3JlYXRlIGEgc3ViY2xhc3Mgb2YgdGhlIGBDcmVkZW50aWFsc2AgY2xhc3MgYW5kXG4gKiBvdmVycmlkZSB0aGUge3JlZnJlc2h9IG1ldGhvZC4gVGhpcyBtZXRob2QgYWxsb3dzIGNyZWRlbnRpYWxzIHRvIGJlXG4gKiByZXRyaWV2ZWQgZnJvbSB0aGUgYmFja2luZyBzdG9yZSwgYmUgaXQgYSBmaWxlIHN5c3RlbSwgZGF0YWJhc2UsIG9yXG4gKiBzb21lIG5ldHdvcmsgc3RvcmFnZS4gVGhlIG1ldGhvZCBzaG91bGQgcmVzZXQgdGhlIGNyZWRlbnRpYWwgYXR0cmlidXRlc1xuICogb24gdGhlIG9iamVjdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBleHBpcmVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBleHBpcmVkIGFuZFxuICogICAgIHJlcXVpcmUgYSByZWZyZXNoLiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge2V4cGlyZVRpbWV9LlxuICogQCFhdHRyaWJ1dGUgZXhwaXJlVGltZVxuICogICBAcmV0dXJuIFtEYXRlXSBhIHRpbWUgd2hlbiBjcmVkZW50aWFscyBzaG91bGQgYmUgY29uc2lkZXJlZCBleHBpcmVkLiBVc2VkXG4gKiAgICAgaW4gY29uanVuY3Rpb24gd2l0aCB7ZXhwaXJlZH0uXG4gKiBAIWF0dHJpYnV0ZSBhY2Nlc3NLZXlJZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICogQCFhdHRyaWJ1dGUgc2VjcmV0QWNjZXNzS2V5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICogQCFhdHRyaWJ1dGUgc2Vzc2lvblRva2VuXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gYW4gb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAqL1xuQVdTLkNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBBIGNyZWRlbnRpYWxzIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB1c2luZyBwb3NpdGlvbmFsIGFyZ3VtZW50cyBvciBhbiBvcHRpb25zXG4gICAqIGhhc2guXG4gICAqXG4gICAqIEBvdmVybG9hZCBBV1MuQ3JlZGVudGlhbHMoYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSwgc2Vzc2lvblRva2VuPW51bGwpXG4gICAqICAgQ3JlYXRlcyBhIENyZWRlbnRpYWxzIG9iamVjdCB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWwgaW5mb3JtYXRpb25cbiAgICogICBhcyBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICogICBAcGFyYW0gYWNjZXNzS2V5SWQgW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gICAqICAgQHBhcmFtIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gICAqICAgQHBhcmFtIHNlc3Npb25Ub2tlbiBbU3RyaW5nXSB0aGUgb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAgICogICBAZXhhbXBsZSBDcmVhdGUgYSBjcmVkZW50aWFscyBvYmplY3Qgd2l0aCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBjcmVkcyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMoJ2FraWQnLCAnc2VjcmV0JywgJ3Nlc3Npb24nKTtcbiAgICogQG92ZXJsb2FkIEFXUy5DcmVkZW50aWFscyhvcHRpb25zKVxuICAgKiAgIENyZWF0ZXMgYSBDcmVkZW50aWFscyBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFsIGluZm9ybWF0aW9uXG4gICAqICAgYXMgYW4gb3B0aW9ucyBoYXNoLlxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAgICogICBAb3B0aW9uIG9wdGlvbnMgc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAgICogICBAb3B0aW9uIG9wdGlvbnMgc2Vzc2lvblRva2VuIFtTdHJpbmddIHRoZSBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICAgKiAgIEBleGFtcGxlIENyZWF0ZSBhIGNyZWRlbnRpYWxzIG9iamVjdCB3aXRoIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGNyZWRzID0gbmV3IEFXUy5DcmVkZW50aWFscyh7XG4gICAqICAgICAgIGFjY2Vzc0tleUlkOiAnYWtpZCcsIHNlY3JldEFjY2Vzc0tleTogJ3NlY3JldCcsIHNlc3Npb25Ub2tlbjogJ3Nlc3Npb24nXG4gICAqICAgICB9KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDcmVkZW50aWFscygpIHtcbiAgICAvLyBoaWRlIHNlY3JldEFjY2Vzc0tleSBmcm9tIGJlaW5nIGRpc3BsYXllZCB3aXRoIHV0aWwuaW5zcGVjdFxuICAgIEFXUy51dGlsLmhpZGVQcm9wZXJ0aWVzKHRoaXMsIFsnc2VjcmV0QWNjZXNzS2V5J10pO1xuXG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgdGhpcy5leHBpcmVUaW1lID0gbnVsbDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNyZWRzID0gYXJndW1lbnRzWzBdLmNyZWRlbnRpYWxzIHx8IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuYWNjZXNzS2V5SWQgPSBjcmVkcy5hY2Nlc3NLZXlJZDtcbiAgICAgIHRoaXMuc2VjcmV0QWNjZXNzS2V5ID0gY3JlZHMuc2VjcmV0QWNjZXNzS2V5O1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBjcmVkcy5zZXNzaW9uVG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWNjZXNzS2V5SWQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSB7ZXhwaXJlVGltZX0gZHVyaW5nIHdoaWNoXG4gICAqICAgdGhlIGNyZWRlbnRpYWxzIHdpbGwgYmUgY29uc2lkZXJlZCBleHBpcmVkLlxuICAgKi9cbiAgZXhwaXJ5V2luZG93OiAxNSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHNob3VsZCBjYWxsIHtyZWZyZXNofVxuICAgKiBAbm90ZSBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGN1c3RvbSByZWZyZXNoXG4gICAqICAgbG9naWMuXG4gICAqL1xuICBuZWVkc1JlZnJlc2g6IGZ1bmN0aW9uIG5lZWRzUmVmcmVzaCgpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGFkanVzdGVkVGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lICsgdGhpcy5leHBpcnlXaW5kb3cgKiAxMDAwKTtcblxuICAgIGlmICh0aGlzLmV4cGlyZVRpbWUgJiYgYWRqdXN0ZWRUaW1lID4gdGhpcy5leHBpcmVUaW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXhwaXJlZCB8fCAhdGhpcy5hY2Nlc3NLZXlJZCB8fCAhdGhpcy5zZWNyZXRBY2Nlc3NLZXk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBleGlzdGluZyBjcmVkZW50aWFscywgcmVmcmVzaGluZyB0aGVtIGlmIHRoZXkgYXJlIG5vdCB5ZXQgbG9hZGVkXG4gICAqIG9yIGhhdmUgZXhwaXJlZC4gVXNlcnMgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIHtyZWZyZXNofSxcbiAgICogYXMgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBjcmVkZW50aWFscyB3aGVuIHRoZXkgYXJlIGFscmVhZHlcbiAgICogbG9hZGVkIGludG8gdGhlIG9iamVjdC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIGVpdGhlciBjcmVkZW50aWFsc1xuICAgKiAgIGRvIG5vdCBuZWVkIHRvIGJlIHJlZnJlc2hlZCBvciByZWZyZXNoZWQgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzXG4gICAqICAgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsXG4gICAqICAgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKCkpIHtcbiAgICAgIHRoaXMucmVmcmVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHNlbGYuZXhwaXJlZCA9IGZhbHNlOyAvLyByZXNldCBleHBpcmVkIGZsYWdcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBnZXRQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKiAgIEdldHMgdGhlIGV4aXN0aW5nIGNyZWRlbnRpYWxzLCByZWZyZXNoaW5nIHRoZW0gaWYgdGhleSBhcmUgbm90IHlldCBsb2FkZWRcbiAgICogICBvciBoYXZlIGV4cGlyZWQuIFVzZXJzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyB7cmVmcmVzaH0sXG4gICAqICAgYXMgdGhpcyB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBjcmVkZW50aWFscyB3aGVuIHRoZXkgYXJlIGFscmVhZHlcbiAgICogICBsb2FkZWQgaW50byB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKClcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQsIGl0XG4gICAqICAgICBtZWFucyBlaXRoZXIgY3JlZGVudGlhbHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmcmVzaGVkIG9yIHJlZnJlc2hlZFxuICAgKiAgICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlXG4gICAqICAgICBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgZ2V0YCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGBnZXRQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNyZWRQcm92aWRlci5nZXRQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQCFtZXRob2QgIHJlZnJlc2hQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKiAgIFJlZnJlc2hlcyB0aGUgY3JlZGVudGlhbHMuIFVzZXJzIHNob3VsZCBjYWxsIHtnZXR9IGJlZm9yZSBhdHRlbXB0aW5nXG4gICAqICAgdG8gZm9yY2libHkgcmVmcmVzaCBjcmVkZW50aWFscy5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbigpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLiBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkLCBpdFxuICAgKiAgICAgbWVhbnMgcmVmcmVzaGVkIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3RcbiAgICogICAgIChhcyB0aGUgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlZnJlc2hgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYHJlZnJlc2hQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNyZWRQcm92aWRlci5yZWZyZXNoUHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyB0aGUgY3JlZGVudGlhbHMuIFVzZXJzIHNob3VsZCBjYWxsIHtnZXR9IGJlZm9yZSBhdHRlbXB0aW5nXG4gICAqIHRvIGZvcmNpYmx5IHJlZnJlc2ggY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyByZWZyZXNoZWRcbiAgICogICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGVcbiAgICogICBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAbm90ZSBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIGNsYXNzIHRvIHJlc2V0IHRoZVxuICAgKiAgIHthY2Nlc3NLZXlJZH0sIHtzZWNyZXRBY2Nlc3NLZXl9IGFuZCBvcHRpb25hbCB7c2Vzc2lvblRva2VufVxuICAgKiAgIG9uIHRoZSBjcmVkZW50aWFscyBvYmplY3QgYW5kIHRoZW4gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aFxuICAgKiAgIGFueSBlcnJvciBpbmZvcm1hdGlvbi5cbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdnZXQnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG4gIHRoaXMucHJvdG90eXBlLnJlZnJlc2hQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdyZWZyZXNoJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlO1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucmVmcmVzaFByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuQ3JlZGVudGlhbHMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiB0aGF0IHNlYXJjaGVzIGZvciBBV1MgY3JlZGVudGlhbHNcbiAqIGluIGEgbGlzdCBvZiBjcmVkZW50aWFsIHByb3ZpZGVycyBzcGVjaWZpZWQgYnkgdGhlIHtwcm92aWRlcnN9IHByb3BlcnR5LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBjaGFpbiB3aWxsIHVzZSB0aGUge2RlZmF1bHRQcm92aWRlcnN9IHRvIHJlc29sdmUgY3JlZGVudGlhbHMuXG4gKiBUaGVzZSBwcm92aWRlcnMgd2lsbCBsb29rIGluIHRoZSBlbnZpcm9ubWVudCB1c2luZyB0aGVcbiAqIHtBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFsc30gY2xhc3Mgd2l0aCB0aGUgJ0FXUycgYW5kICdBTUFaT04nIHByZWZpeGVzLlxuICpcbiAqICMjIFNldHRpbmcgUHJvdmlkZXJzXG4gKlxuICogRWFjaCBwcm92aWRlciBpbiB0aGUge3Byb3ZpZGVyc30gbGlzdCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAqIGEge0FXUy5DcmVkZW50aWFsc30gb2JqZWN0LCBvciBhIGhhcmRjb2RlZCBjcmVkZW50aWFscyBvYmplY3QuIFRoZSBmdW5jdGlvblxuICogZm9ybSBhbGxvd3MgZm9yIGRlbGF5ZWQgZXhlY3V0aW9uIG9mIHRoZSBjcmVkZW50aWFsIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiAjIyBSZXNvbHZpbmcgQ3JlZGVudGlhbHMgZnJvbSBhIENoYWluXG4gKlxuICogQ2FsbCB7cmVzb2x2ZX0gdG8gcmV0dXJuIHRoZSBmaXJzdCB2YWxpZCBjcmVkZW50aWFsIG9iamVjdCB0aGF0IGNhbiBiZVxuICogbG9hZGVkIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gcmVzb2x2ZSBhIGNoYWluIHdpdGggYSBjdXN0b20gcHJvdmlkZXIgdGhhdCBjaGVja3MgYSBmaWxlXG4gKiBvbiBkaXNrIGFmdGVyIHRoZSBzZXQgb2Yge2RlZmF1bHRQcm92aWRlcnN9OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBkaXNrUHJvdmlkZXIgPSBuZXcgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscygnLi9jcmVkcy5qc29uJyk7XG4gKiB2YXIgY2hhaW4gPSBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKCk7XG4gKiBjaGFpbi5wcm92aWRlcnMucHVzaChkaXNrUHJvdmlkZXIpO1xuICogY2hhaW4ucmVzb2x2ZSgpO1xuICogYGBgXG4gKlxuICogVGhlIGFib3ZlIGNvZGUgd2lsbCByZXR1cm4gdGhlIGBkaXNrUHJvdmlkZXJgIG9iamVjdCBpZiB0aGVcbiAqIGZpbGUgY29udGFpbnMgY3JlZGVudGlhbHMgYW5kIHRoZSBgZGVmYXVsdFByb3ZpZGVyc2AgZG8gbm90IGNvbnRhaW5cbiAqIGFueSBjcmVkZW50aWFsIHNldHRpbmdzLlxuICpcbiAqIEAhYXR0cmlidXRlIHByb3ZpZGVyc1xuICogICBAcmV0dXJuIFtBcnJheTxBV1MuQ3JlZGVudGlhbHMsIEZ1bmN0aW9uPl1cbiAqICAgICBhIGxpc3Qgb2YgY3JlZGVudGlhbHMgb2JqZWN0cyBvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gY3JlZGVudGlhbHNcbiAqICAgICBvYmplY3RzLiBJZiB0aGUgcHJvdmlkZXIgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHdpbGwgYmVcbiAqICAgICBleGVjdXRlZCBsYXppbHkgd2hlbiB0aGUgcHJvdmlkZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCBmb3IgdmFsaWRcbiAqICAgICBjcmVkZW50aWFscy4gQnkgZGVmYXVsdCwgdGhpcyBvYmplY3Qgd2lsbCBiZSBzZXQgdG8gdGhlXG4gKiAgICAge2RlZmF1bHRQcm92aWRlcnN9LlxuICogICBAc2VlIGRlZmF1bHRQcm92aWRlcnNcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzXG4gICAqIHNwZWNpZmllZCBieSB7ZGVmYXVsdFByb3ZpZGVyc30uXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4ocHJvdmlkZXJzKSB7XG4gICAgaWYgKHByb3ZpZGVycykge1xuICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvdmlkZXJzID0gQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMuc2xpY2UoMCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcmVzb2x2ZVByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiAgIGNyZWRlbnRpYWxzIGluIHtwcm92aWRlcnN9LlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGNyZWRlbnRpYWxzKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBhbmQgdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpblxuICAgKiAgICAgdG8gYSBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHJlc29sdmVkXG4gICAqICAgICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnJvcilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZSBmb3VuZC5cbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlc29sdmVgIG1ldGhvZCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGByZXNvbHZlUHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjaGFpbi5yZXNvbHZlUHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiBjcmVkZW50aWFscyBpbiB7cHJvdmlkZXJzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgY3JlZGVudGlhbHMpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpbiB0byBhIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIG9yIG51bGwgaWYgbm8gY3JlZGVudGlhbHMgY2FuIGJlIGZvdW5kLlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZVxuICAgKiAgICAgZm91bmQuXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBjcmVkZW50aWFscyBvYmplY3QgcmVzb2x2ZWRcbiAgICogICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogQHJldHVybiBbQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXSB0aGUgcHJvdmlkZXIsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHByb3ZpZGVycycpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHByb3ZpZGVycyA9IHRoaXMucHJvdmlkZXJzLnNsaWNlKDApO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZU5leHQoZXJyLCBjcmVkcykge1xuICAgICAgaWYgKCghZXJyICYmIGNyZWRzKSB8fCBpbmRleCA9PT0gcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhlcnIsIGNyZWRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaW5kZXgrK107XG4gICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNyZWRzID0gcHJvdmlkZXIuY2FsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlZHMgPSBwcm92aWRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNyZWRzLmdldCkge1xuICAgICAgICBjcmVkcy5nZXQoZnVuY3Rpb24oZ2V0RXJyKSB7XG4gICAgICAgICAgcmVzb2x2ZU5leHQoZ2V0RXJyLCBnZXRFcnIgPyBudWxsIDogY3JlZHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmVOZXh0KG51bGwsIGNyZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNvbHZlTmV4dCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzIHVzZWQgYnkgYSB2YW5pbGxhIENyZWRlbnRpYWxQcm92aWRlckNoYWluLlxuICpcbiAqIEluIHRoZSBicm93c2VyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW11cbiAqIGBgYFxuICpcbiAqIEluIE5vZGUuanM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHtcbiAqICAgICAvLyBpZiBBV1NfQ09OVEFJTkVSX0NSRURFTlRJQUxTX1JFTEFUSVZFX1VSSSBpcyBzZXRcbiAqICAgICAgIHJldHVybiBuZXcgQVdTLkVDU0NyZWRlbnRpYWxzKCk7XG4gKiAgICAgLy8gZWxzZVxuICogICAgICAgcmV0dXJuIG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpO1xuICogICB9XG4gKiBdXG4gKiBgYGBcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5yZXNvbHZlUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgncmVzb2x2ZScsIFByb21pc2VEZXBlbmRlbmN5KTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucmVzb2x2ZVByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY3JlZGVudGlhbF9wcm92aWRlcl9jaGFpbi5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogVGhlIGVuZHBvaW50IHRoYXQgYSBzZXJ2aWNlIHdpbGwgdGFsayB0bywgZm9yIGV4YW1wbGUsXG4gKiBgJ2h0dHBzOi8vZWMyLmFwLXNvdXRoZWFzdC0xLmFtYXpvbmF3cy5jb20nYC4gSWZcbiAqIHlvdSBuZWVkIHRvIG92ZXJyaWRlIGFuIGVuZHBvaW50IGZvciBhIHNlcnZpY2UsIHlvdSBjYW5cbiAqIHNldCB0aGUgZW5kcG9pbnQgb24gYSBzZXJ2aWNlIGJ5IHBhc3NpbmcgdGhlIGVuZHBvaW50XG4gKiBvYmplY3Qgd2l0aCB0aGUgYGVuZHBvaW50YCBvcHRpb24ga2V5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBlcCA9IG5ldyBBV1MuRW5kcG9pbnQoJ2F3c3Byb3h5LmV4YW1wbGUuY29tJyk7XG4gKiB2YXIgczMgPSBuZXcgQVdTLlMzKHtlbmRwb2ludDogZXB9KTtcbiAqIHMzLnNlcnZpY2UuZW5kcG9pbnQuaG9zdG5hbWUgPT0gJ2F3c3Byb3h5LmV4YW1wbGUuY29tJ1xuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGlmIHlvdSBkbyBub3Qgc3BlY2lmeSBhIHByb3RvY29sLCB0aGUgcHJvdG9jb2wgd2lsbFxuICogYmUgc2VsZWN0ZWQgYmFzZWQgb24geW91ciBjdXJyZW50IHtBV1MuY29uZmlnfSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEAhYXR0cmlidXRlIHByb3RvY29sXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHByb3RvY29sIChodHRwIG9yIGh0dHBzKSBvZiB0aGUgZW5kcG9pbnRcbiAqICAgICBVUkxcbiAqIEAhYXR0cmlidXRlIGhvc3RuYW1lXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIGhvc3QgcG9ydGlvbiBvZiB0aGUgZW5kcG9pbnQsIGUuZy4sXG4gKiAgICAgZXhhbXBsZS5jb21cbiAqIEAhYXR0cmlidXRlIGhvc3RcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoZSBlbmRwb2ludCBpbmNsdWRpbmdcbiAqICAgICB0aGUgcG9ydCwgZS5nLiwgZXhhbXBsZS5jb206ODBcbiAqIEAhYXR0cmlidXRlIHBvcnRcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvcnQgb2YgdGhlIGVuZHBvaW50XG4gKiBAIWF0dHJpYnV0ZSBocmVmXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIGZ1bGwgVVJMIG9mIHRoZSBlbmRwb2ludFxuICovXG5BV1MuRW5kcG9pbnQgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQG92ZXJsb2FkIEVuZHBvaW50KGVuZHBvaW50KVxuICAgKiAgIENvbnN0cnVjdHMgYSBuZXcgZW5kcG9pbnQgZ2l2ZW4gYW4gZW5kcG9pbnQgVVJMLiBJZiB0aGVcbiAgICogICBVUkwgb21pdHMgYSBwcm90b2NvbCAoaHR0cCBvciBodHRwcyksIHRoZSBkZWZhdWx0IHByb3RvY29sXG4gICAqICAgc2V0IGluIHRoZSBnbG9iYWwge0FXUy5jb25maWd9IHdpbGwgYmUgdXNlZC5cbiAgICogICBAcGFyYW0gZW5kcG9pbnQgW1N0cmluZ10gdGhlIFVSTCB0byBjb25zdHJ1Y3QgYW4gZW5kcG9pbnQgZnJvbVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEVuZHBvaW50KGVuZHBvaW50LCBjb25maWcpIHtcbiAgICBBV1MudXRpbC5oaWRlUHJvcGVydGllcyh0aGlzLCBbJ3NsYXNoZXMnLCAnYXV0aCcsICdoYXNoJywgJ3NlYXJjaCcsICdxdWVyeSddKTtcblxuICAgIGlmICh0eXBlb2YgZW5kcG9pbnQgPT09ICd1bmRlZmluZWQnIHx8IGVuZHBvaW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5kcG9pbnQ6ICcgKyBlbmRwb2ludCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQVdTLnV0aWwuY29weShlbmRwb2ludCk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmRwb2ludC5tYXRjaCgvXmh0dHAvKSkge1xuICAgICAgdmFyIHVzZVNTTCA9IGNvbmZpZyAmJiBjb25maWcuc3NsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgY29uZmlnLnNzbEVuYWJsZWQgOiBBV1MuY29uZmlnLnNzbEVuYWJsZWQ7XG4gICAgICBlbmRwb2ludCA9ICh1c2VTU0wgPyAnaHR0cHMnIDogJ2h0dHAnKSArICc6Ly8nICsgZW5kcG9pbnQ7XG4gICAgfVxuXG4gICAgQVdTLnV0aWwudXBkYXRlKHRoaXMsIEFXUy51dGlsLnVybFBhcnNlKGVuZHBvaW50KSk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIHBvcnQgcHJvcGVydHkgaXMgc2V0IGFzIGFuIGludGVnZXJcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICB0aGlzLnBvcnQgPSBwYXJzZUludCh0aGlzLnBvcnQsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3J0ID0gdGhpcy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxufSk7XG5cbi8qKlxuICogVGhlIGxvdyBsZXZlbCBIVFRQIHJlcXVlc3Qgb2JqZWN0LCBlbmNhcHN1bGF0aW5nIGFsbCBIVFRQIGhlYWRlclxuICogYW5kIGJvZHkgZGF0YSBzZW50IGJ5IGEgc2VydmljZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIG1ldGhvZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBIVFRQIG1ldGhvZCBvZiB0aGUgcmVxdWVzdFxuICogQCFhdHRyaWJ1dGUgcGF0aFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIFVSSSwgZS5nLixcbiAqICAgICBcIi9saXN0Lz9zdGFydD01Jm51bT0xMFwiXG4gKiBAIWF0dHJpYnV0ZSBoZWFkZXJzXG4gKiAgIEByZXR1cm4gW21hcDxTdHJpbmcsU3RyaW5nPl1cbiAqICAgICBhIG1hcCBvZiBoZWFkZXIga2V5cyBhbmQgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZXNcbiAqIEAhYXR0cmlidXRlIGJvZHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVxdWVzdCBib2R5IHBheWxvYWRcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50XG4gKiAgIEByZXR1cm4gW0FXUy5FbmRwb2ludF0gdGhlIGVuZHBvaW50IGZvciB0aGUgcmVxdWVzdFxuICogQCFhdHRyaWJ1dGUgcmVnaW9uXG4gKiAgIEBhcGkgcHJpdmF0ZVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZWdpb24sIGZvciBzaWduaW5nIHB1cnBvc2VzIG9ubHkuXG4gKi9cbkFXUy5IdHRwUmVxdWVzdCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBIdHRwUmVxdWVzdChlbmRwb2ludCwgcmVnaW9uKSB7XG4gICAgZW5kcG9pbnQgPSBuZXcgQVdTLkVuZHBvaW50KGVuZHBvaW50KTtcbiAgICB0aGlzLm1ldGhvZCA9ICdQT1NUJztcbiAgICB0aGlzLnBhdGggPSBlbmRwb2ludC5wYXRoIHx8ICcvJztcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSAnJztcbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgdGhpcy5fdXNlckFnZW50ID0gJyc7XG4gICAgdGhpcy5zZXRVc2VyQWdlbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uIHNldFVzZXJBZ2VudCgpIHtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSB0aGlzLmhlYWRlcnNbdGhpcy5nZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCldID0gQVdTLnV0aWwudXNlckFnZW50KCk7XG4gIH0sXG5cbiAgZ2V0VXNlckFnZW50SGVhZGVyTmFtZTogZnVuY3Rpb24gZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpIHtcbiAgICB2YXIgcHJlZml4ID0gQVdTLnV0aWwuaXNCcm93c2VyKCkgPyAnWC1BbXotJyA6ICcnO1xuICAgIHJldHVybiBwcmVmaXggKyAnVXNlci1BZ2VudCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBwZW5kVG9Vc2VyQWdlbnQ6IGZ1bmN0aW9uIGFwcGVuZFRvVXNlckFnZW50KGFnZW50UGFydGlhbCkge1xuICAgIGlmICh0eXBlb2YgYWdlbnRQYXJ0aWFsID09PSAnc3RyaW5nJyAmJiBhZ2VudFBhcnRpYWwpIHtcbiAgICAgIHRoaXMuX3VzZXJBZ2VudCArPSAnICcgKyBhZ2VudFBhcnRpYWw7XG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1t0aGlzLmdldFVzZXJBZ2VudEhlYWRlck5hbWUoKV0gPSB0aGlzLl91c2VyQWdlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VXNlckFnZW50OiBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJBZ2VudDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgcGFydCBvZiB0aGUge3BhdGh9IGV4Y2x1ZGluZyB0aGVcbiAgICogICBxdWVyeSBzdHJpbmdcbiAgICovXG4gIHBhdGhuYW1lOiBmdW5jdGlvbiBwYXRobmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoLnNwbGl0KCc/JywgMSlbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSB7cGF0aH1cbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKCkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMucGF0aC5zcGxpdCgnPycsIDIpWzFdO1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgcXVlcnkgPSBBV1MudXRpbC5xdWVyeVN0cmluZ1BhcnNlKHF1ZXJ5KTtcbiAgICAgIHJldHVybiBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFRoZSBsb3cgbGV2ZWwgSFRUUCByZXNwb25zZSBvYmplY3QsIGVuY2Fwc3VsYXRpbmcgYWxsIEhUVFAgaGVhZGVyXG4gKiBhbmQgYm9keSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3RhdHVzQ29kZVxuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgSFRUUCBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIDIwMCwgNDA0KVxuICogQCFhdHRyaWJ1dGUgaGVhZGVyc1xuICogICBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dXG4gKiAgICAgIGEgbWFwIG9mIHJlc3BvbnNlIGhlYWRlciBrZXlzIGFuZCB0aGVpciByZXNwZWN0aXZlIHZhbHVlc1xuICogQCFhdHRyaWJ1dGUgYm9keVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBib2R5IHBheWxvYWRcbiAqIEAhYXR0cmlidXRlIFtyXSBzdHJlYW1pbmdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGlzIHJlc3BvbnNlIGlzIGJlaW5nIHN0cmVhbWVkIGF0IGEgbG93LWxldmVsLlxuICogICAgIERlZmF1bHRzIHRvIGBmYWxzZWAgKGJ1ZmZlcmVkIHJlYWRzKS4gRG8gbm90IG1vZGlmeSB0aGlzIG1hbnVhbGx5LCB1c2VcbiAqICAgICB7Y3JlYXRlVW5idWZmZXJlZFN0cmVhbX0gdG8gY29udmVydCB0aGUgc3RyZWFtIHRvIHVuYnVmZmVyZWQgbW9kZVxuICogICAgIGluc3RlYWQuXG4gKi9cbkFXUy5IdHRwUmVzcG9uc2UgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gSHR0cFJlc3BvbnNlKCkge1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGJ1ZmZlcmluZyBvbiB0aGUgSFRUUCByZXNwb25zZSBhbmQgcmV0dXJucyB0aGUgc3RyZWFtIGZvciByZWFkaW5nLlxuICAgKiBAcmV0dXJuIFtTdHJlYW0sIFhNTEh0dHBSZXF1ZXN0LCBudWxsXSB0aGUgdW5kZXJseWluZyBzdHJlYW0gb2JqZWN0LlxuICAgKiAgIFVzZSB0aGlzIG9iamVjdCB0byBkaXJlY3RseSByZWFkIGRhdGEgb2ZmIG9mIHRoZSBzdHJlYW0uXG4gICAqIEBub3RlIFRoaXMgb2JqZWN0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7QVdTLlJlcXVlc3R+aHR0cEhlYWRlcnN9XG4gICAqICAgZXZlbnQgaGFzIGZpcmVkLiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBwcmlvciB0b1xuICAgKiAgIHtBV1MuUmVxdWVzdH5odHRwRGF0YX0uXG4gICAqIEBleGFtcGxlIFRha2luZyBjb250cm9sIG9mIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5vbignaHR0cEhlYWRlcnMnLCBmdW5jdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKSB7XG4gICAqICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgKiAgICAgICBpZiAoaGVhZGVycy5ldGFnID09PSAneHl6Jykge1xuICAgKiAgICAgICAgIC8vIHBpcGUgdGhlIHN0cmVhbSwgZGlzYWJsaW5nIGJ1ZmZlcmluZ1xuICAgKiAgICAgICAgIHZhciBzdHJlYW0gPSB0aGlzLnJlc3BvbnNlLmh0dHBSZXNwb25zZS5jcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCk7XG4gICAqICAgICAgICAgc3RyZWFtLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgKiAgICAgICB9IGVsc2UgeyAvLyBhYm9ydCB0aGlzIHJlcXVlc3QgYW5kIHNldCBhIGJldHRlciBlcnJvciBtZXNzYWdlXG4gICAqICAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgKiAgICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBuZXcgRXJyb3IoJ0ludmFsaWQgRVRhZycpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9XG4gICAqICAgfSkuc2VuZChjb25zb2xlLmxvZyk7XG4gICAqL1xuICBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCkge1xuICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW07XG4gIH1cbn0pO1xuXG5cbkFXUy5IdHRwQ2xpZW50ID0gaW5oZXJpdCh7fSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5IdHRwQ2xpZW50LmdldEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0SW5zdGFuY2UoKSB7XG4gIGlmICh0aGlzLnNpbmdsZXRvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zaW5nbGV0b24gPSBuZXcgdGhpcygpO1xuICB9XG4gIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEAhbWV0aG9kIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spXG4gKiAgIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBjYWxsYmFjayBmb3IgdGhlIGV2ZW50IGdpdmVuIGJ5IGBldmVudE5hbWVgLlxuICogICBQYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZGVwZW5kIG9uIHRoZSBpbmRpdmlkdWFsIGV2ZW50XG4gKiAgIGJlaW5nIHRyaWdnZXJlZC4gU2VlIHRoZSBldmVudCBkb2N1bWVudGF0aW9uIGZvciB0aG9zZSBwYXJhbWV0ZXJzLlxuICpcbiAqICAgQHBhcmFtIGV2ZW50TmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZSB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgZm9yXG4gKiAgIEBwYXJhbSBjYWxsYmFjayBbRnVuY3Rpb25dIHRoZSBsaXN0ZW5lciBjYWxsYmFjayBmdW5jdGlvblxuICogICBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgc2FtZSBvYmplY3QgZm9yIGNoYWluaW5nXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VxdWVudGlhbEV4ZWN1dG9yKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA/IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnNsaWNlKDApIDogW107XG4gIH0sXG5cbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG9uQXN5bmM6IGZ1bmN0aW9uIG9uQXN5bmMoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfSxcblxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID4gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBldmVudEFyZ3MsIGRvbmVDYWxsYmFjaykge1xuICAgIGlmICghZG9uZUNhbGxiYWNrKSBkb25lQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICB2YXIgY291bnQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIHRoaXMuY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGV2ZW50QXJncywgZG9uZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gY291bnQgPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCBkb25lQ2FsbGJhY2ssIHByZXZFcnJvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXJyb3IgPSBwcmV2RXJyb3IgfHwgbnVsbDtcblxuICAgIGZ1bmN0aW9uIGNhbGxOZXh0TGlzdGVuZXIoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIGVycik7XG4gICAgICAgIGlmIChzZWxmLl9oYWx0SGFuZGxlcnNPbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5jYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgYXJncywgZG9uZUNhbGxiYWNrLCBlcnJvcik7XG4gICAgfVxuXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnMuc2hpZnQoKTtcbiAgICAgIGlmIChsaXN0ZW5lci5faXNBc3luYykgeyAvLyBhc3luY2hyb25vdXMgbGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoW2NhbGxOZXh0TGlzdGVuZXJdKSk7XG4gICAgICAgIHJldHVybjsgLy8gc3RvcCBoZXJlLCBjYWxsTmV4dExpc3RlbmVyIHdpbGwgY29udGludWVcbiAgICAgIH0gZWxzZSB7IC8vIHN5bmNocm9ub3VzIGxpc3RlbmVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmIHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IpIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2suY2FsbChzZWxmLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBvciBjb3BpZXMgYSBzZXQgb2YgbGlzdGVuZXJzIGZyb20gYW5vdGhlciBsaXN0IG9mXG4gICAqIGxpc3RlbmVycyBvciBTZXF1ZW50aWFsRXhlY3V0b3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXJzIFttYXA8U3RyaW5nLEFycmF5PEZ1bmN0aW9uPj4sIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3JdXG4gICAqICAgYSBsaXN0IG9mIGV2ZW50cyBhbmQgY2FsbGJhY2tzLCBvciBhbiBldmVudCBlbWl0dGVyIG9iamVjdFxuICAgKiAgIGNvbnRhaW5pbmcgbGlzdGVuZXJzIHRvIGFkZCB0byB0aGlzIGVtaXR0ZXIgb2JqZWN0LlxuICAgKiBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgZW1pdHRlciBvYmplY3QsIGZvciBjaGFpbmluZy5cbiAgICogQGV4YW1wbGUgQWRkaW5nIGxpc3RlbmVycyBmcm9tIGEgbWFwIG9mIGxpc3RlbmVyc1xuICAgKiAgIGVtaXR0ZXIuYWRkTGlzdGVuZXJzKHtcbiAgICogICAgIGV2ZW50MTogW2Z1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oKSB7IC4uLiB9XSxcbiAgICogICAgIGV2ZW50MjogW2Z1bmN0aW9uKCkgeyAuLi4gfV1cbiAgICogICB9KTtcbiAgICogICBlbWl0dGVyLmVtaXQoJ2V2ZW50MScpOyAvLyBlbWl0dGVyIGhhcyBldmVudDFcbiAgICogICBlbWl0dGVyLmVtaXQoJ2V2ZW50MicpOyAvLyBlbWl0dGVyIGhhcyBldmVudDJcbiAgICogQGV4YW1wbGUgQWRkaW5nIGxpc3RlbmVycyBmcm9tIGFub3RoZXIgZW1pdHRlciBvYmplY3RcbiAgICogICB2YXIgZW1pdHRlcjEgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuICAgKiAgIGVtaXR0ZXIxLm9uKCdldmVudDEnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgIGVtaXR0ZXIxLm9uKCdldmVudDInLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgIHZhciBlbWl0dGVyMiA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG4gICAqICAgZW1pdHRlcjIuYWRkTGlzdGVuZXJzKGVtaXR0ZXIxKTtcbiAgICogICBlbWl0dGVyMi5lbWl0KCdldmVudDEnKTsgLy8gZW1pdHRlcjIgaGFzIGV2ZW50MVxuICAgKiAgIGVtaXR0ZXIyLmVtaXQoJ2V2ZW50MicpOyAvLyBlbWl0dGVyMiBoYXMgZXZlbnQyXG4gICAqL1xuICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhsaXN0ZW5lcnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBpZiBwYXJhbWV0ZXIgaXMgYW4gU2VxdWVudGlhbEV4ZWN1dG9yIG9iamVjdFxuICAgIGlmIChsaXN0ZW5lcnMuX2V2ZW50cykgbGlzdGVuZXJzID0gbGlzdGVuZXJzLl9ldmVudHM7XG5cbiAgICBBV1MudXRpbC5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrcykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrcyA9IFtjYWxsYmFja3NdO1xuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKGNhbGxiYWNrcywgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgc2VsZi5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IHdpdGgge29ufSBhbmQgc2F2ZXMgdGhlIGNhbGxiYWNrIGhhbmRsZSBmdW5jdGlvblxuICAgKiBhcyBhIHByb3BlcnR5IG9uIHRoZSBlbWl0dGVyIG9iamVjdCB1c2luZyBhIGdpdmVuIGBuYW1lYC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0IG9uIHRoaXMgb2JqZWN0IGNvbnRhaW5pbmdcbiAgICogICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaGFuZGxlIHNvIHRoYXQgdGhlIGxpc3RlbmVyIGNhbiBiZSByZW1vdmVkIGluXG4gICAqICAgdGhlIGZ1dHVyZS5cbiAgICogQHBhcmFtIChzZWUgb24pXG4gICAqIEByZXR1cm4gKHNlZSBvbilcbiAgICogQGV4YW1wbGUgQWRkaW5nIGEgbmFtZWQgbGlzdGVuZXIgREFUQV9DQUxMQkFDS1xuICAgKiAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkgeyBkb1NvbWV0aGluZygpOyB9O1xuICAgKiAgIGVtaXR0ZXIuYWRkTmFtZWRMaXN0ZW5lcignREFUQV9DQUxMQkFDSycsICdkYXRhJywgbGlzdGVuZXIpO1xuICAgKlxuICAgKiAgIC8vIHRoZSBmb2xsb3dpbmcgcHJpbnRzOiB0cnVlXG4gICAqICAgY29uc29sZS5sb2coZW1pdHRlci5EQVRBX0NBTExCQUNLID09IGxpc3RlbmVyKTtcbiAgICovXG4gIGFkZE5hbWVkTGlzdGVuZXI6IGZ1bmN0aW9uIGFkZE5hbWVkTGlzdGVuZXIobmFtZSwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZE5hbWVkQXN5bmNMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRBc3luY0xpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjay5faXNBc3luYyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSBzZXQgb2YgbmFtZWQgbGlzdGVuZXJzIHVzaW5nXG4gICAqIHthZGROYW1lZExpc3RlbmVyfS4gVGhlIGNhbGxiYWNrIGNvbnRhaW5zIGEgcGFyYW1ldGVyXG4gICAqIHdpdGggYSBoYW5kbGUgdG8gdGhlIGBhZGROYW1lZExpc3RlbmVyYCBtZXRob2QuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihhZGQpXG4gICAqICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpbiBvcmRlciB0byBwcm92aWRlXG4gICAqICAgdGhlIGBhZGRgIGZ1bmN0aW9uIHRvIHRoZSBibG9jay4gVGhpcyBzaW1wbGlmaWVzIHRoZSBhZGRpdGlvbiBvZlxuICAgKiAgIGEgbGFyZ2UgZ3JvdXAgb2YgbmFtZWQgbGlzdGVuZXJzLlxuICAgKiAgIEBwYXJhbSBhZGQgW0Z1bmN0aW9uXSB0aGUge2FkZE5hbWVkTGlzdGVuZXJ9IGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogICAgIHdoZW4gcmVnaXN0ZXJpbmcgbGlzdGVuZXJzLlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgYSBzZXQgb2YgbmFtZWQgbGlzdGVuZXJzXG4gICAqICAgZW1pdHRlci5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICogICAgIGFkZCgnREFUQV9DQUxMQkFDSycsICdkYXRhJywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICAgIGFkZCgnT1RIRVInLCAnb3RoZXJFdmVudCcsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgICBhZGQoJ0xBU1QnLCAnbGFzdEV2ZW50JywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3cgc2V0OlxuICAgKiAgIGVtaXR0ZXIuREFUQV9DQUxMQkFDSztcbiAgICogICBlbWl0dGVyLk9USEVSO1xuICAgKiAgIGVtaXR0ZXIuTEFTVDtcbiAgICovXG4gIGFkZE5hbWVkTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGROYW1lZExpc3RlbmVycyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjYWxsYmFjayhcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmFkZE5hbWVkTGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGROYW1lZEFzeW5jTGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLyoqXG4gKiB7b259IGlzIHRoZSBwcmVmZXJlZCBtZXRob2QuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5vbjtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VxdWVudGlhbF9leGVjdXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WMyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG5cbiAgICB2YXIgZGF0ZXRpbWUgPSBBV1MudXRpbC5kYXRlLnJmYzgyMihkYXRlKTtcblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBkYXRldGltZTtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtem4tQXV0aG9yaXphdGlvbiddID1cbiAgICAgIHRoaXMuYXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuXG4gIH0sXG5cbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25lZEhlYWRlcnM9JyArIHRoaXMuc2lnbmVkSGVhZGVycygpICsgJywnICtcbiAgICAgICdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcbiAgfSxcblxuICBzaWduZWRIZWFkZXJzOiBmdW5jdGlvbiBzaWduZWRIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoKHRoaXMuaGVhZGVyc1RvU2lnbigpLCBmdW5jdGlvbiBpdGVyYXRvcihoKSB7XG4gICAgICBoZWFkZXJzLnB1c2goaC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycy5zb3J0KCkuam9pbignOycpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlcXVlc3QuaGVhZGVycztcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2godGhpcy5oZWFkZXJzVG9TaWduKCksIGZ1bmN0aW9uIGl0ZXJhdG9yKGgpIHtcbiAgICAgIHBhcnRzLnB1c2goaC50b0xvd2VyQ2FzZSgpLnRyaW0oKSArICc6JyArIFN0cmluZyhoZWFkZXJzW2hdKS50cmltKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5zb3J0KCkuam9pbignXFxuJykgKyAnXFxuJztcbiAgfSxcblxuICBoZWFkZXJzVG9TaWduOiBmdW5jdGlvbiBoZWFkZXJzVG9TaWduKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaCh0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gaXRlcmF0b3Ioaykge1xuICAgICAgaWYgKGsgPT09ICdIb3N0JyB8fCBrID09PSAnQ29udGVudC1FbmNvZGluZycgfHwgay5tYXRjaCgvXlgtQW16L2kpKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCksICdiYXNlNjQnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2goJy8nKTtcbiAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5ib2R5KTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLnNoYTI1NihwYXJ0cy5qb2luKCdcXG4nKSk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3YzLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBjYWNoZWRTZWNyZXQgPSB7fTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGNhY2hlUXVldWUgPSBbXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIG1heENhY2hlRW50cmllcyA9IDUwO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgdjRJZGVudGlmaWVyID0gJ2F3czRfcmVxdWVzdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFtTdHJpbmddXG4gICAqIEBwYXJhbSByZWdpb24gW1N0cmluZ11cbiAgICogQHBhcmFtIHNlcnZpY2VOYW1lIFtTdHJpbmddXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIGNyZWF0ZVNjb3BlOiBmdW5jdGlvbiBjcmVhdGVTY29wZShkYXRlLCByZWdpb24sIHNlcnZpY2VOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGRhdGUuc3Vic3RyKDAsIDgpLFxuICAgICAgcmVnaW9uLFxuICAgICAgc2VydmljZU5hbWUsXG4gICAgICB2NElkZW50aWZpZXJcbiAgICBdLmpvaW4oJy8nKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBbQ3JlZGVudGlhbHNdXG4gICAqIEBwYXJhbSBkYXRlIFtTdHJpbmddXG4gICAqIEBwYXJhbSByZWdpb24gW1N0cmluZ11cbiAgICogQHBhcmFtIHNlcnZpY2UgW1N0cmluZ11cbiAgICogQHBhcmFtIHNob3VsZENhY2hlIFtCb29sZWFuXVxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBnZXRTaWduaW5nS2V5OiBmdW5jdGlvbiBnZXRTaWduaW5nS2V5KFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGRhdGUsXG4gICAgcmVnaW9uLFxuICAgIHNlcnZpY2UsXG4gICAgc2hvdWxkQ2FjaGVcbiAgKSB7XG4gICAgdmFyIGNyZWRzSWRlbnRpZmllciA9IEFXUy51dGlsLmNyeXB0b1xuICAgICAgLmhtYWMoY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCwgJ2Jhc2U2NCcpO1xuICAgIHZhciBjYWNoZUtleSA9IFtjcmVkc0lkZW50aWZpZXIsIGRhdGUsIHJlZ2lvbiwgc2VydmljZV0uam9pbignXycpO1xuICAgIHNob3VsZENhY2hlID0gc2hvdWxkQ2FjaGUgIT09IGZhbHNlO1xuICAgIGlmIChzaG91bGRDYWNoZSAmJiAoY2FjaGVLZXkgaW4gY2FjaGVkU2VjcmV0KSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFNlY3JldFtjYWNoZUtleV07XG4gICAgfVxuXG4gICAgdmFyIGtEYXRlID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoXG4gICAgICAnQVdTNCcgKyBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksXG4gICAgICBkYXRlLFxuICAgICAgJ2J1ZmZlcidcbiAgICApO1xuICAgIHZhciBrUmVnaW9uID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa0RhdGUsIHJlZ2lvbiwgJ2J1ZmZlcicpO1xuICAgIHZhciBrU2VydmljZSA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtSZWdpb24sIHNlcnZpY2UsICdidWZmZXInKTtcblxuICAgIHZhciBzaWduaW5nS2V5ID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa1NlcnZpY2UsIHY0SWRlbnRpZmllciwgJ2J1ZmZlcicpO1xuICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgY2FjaGVkU2VjcmV0W2NhY2hlS2V5XSA9IHNpZ25pbmdLZXk7XG4gICAgICBjYWNoZVF1ZXVlLnB1c2goY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlUXVldWUubGVuZ3RoID4gbWF4Q2FjaGVFbnRyaWVzKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgb2xkZXN0IGVudHJ5IChub3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQpXG4gICAgICAgIGRlbGV0ZSBjYWNoZWRTZWNyZXRbY2FjaGVRdWV1ZS5zaGlmdCgpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbmluZ0tleTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEVtcHRpZXMgdGhlIGRlcml2ZWQgc2lnbmluZyBrZXkgY2FjaGUuIE1hZGUgYXZhaWxhYmxlIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAqIG9ubHkuXG4gICAqL1xuICBlbXB0eUNhY2hlOiBmdW5jdGlvbiBlbXB0eUNhY2hlKCkge1xuICAgIGNhY2hlZFNlY3JldCA9IHt9O1xuICAgIGNhY2hlUXVldWUgPSBbXTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjRfY3JlZGVudGlhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cbnZhciBybmc7XG5cbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bzsgLy8gZm9yIElFIDExXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn1cblxuaWYgKCFybmcpIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICBybmcgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICByZXR1cm4gIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEBmbG93XG4ndXNlIHN0cmljdCdcblxuY29uc3QgcHJpdmF0ZVZhcnMgPSBuZXcgV2Vha01hcCgpXG5cbmZ1bmN0aW9uIEJsb2JVcGxvYWRlciAoYXBpVXJsIC8qIDpzdHJpbmcgKi8pIHtcbiAgaWYgKCFhcGlVcmwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCbG9iVXBsb2FkZXIgZXhwZWN0cyBhIGFwaSBVUkwgZHVyaW5nIGluc3RhbnRpYXRpb24nKVxuICB9XG4gIHByaXZhdGVWYXJzLnNldCh0aGlzLCB7XG4gICAgdXJpOiBhcGlVcmxcbiAgfSlcbn1cblxuQmxvYlVwbG9hZGVyLnByb3RvdHlwZS5yZXRyaWV2ZUJsb2JVcmwgPSBmdW5jdGlvbiAoXG4gIHV1aWQgLyogOnN0cmluZyAqL1xuKSAvKiA6UHJvbWlzZTxzdHJpbmc+ICovIHtcbiAgaWYgKCF1dWlkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigndXVpZCBhcmd1bWVudCBub3QgcHJvdmlkZWQnKSlcbiAgfVxuXG4gIGlmICghcHJpdmF0ZVZhcnMgfHwgIXByaXZhdGVWYXJzLmdldCh0aGlzKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Jsb2JVcGxvYWRlciB1cmkgbm90IGNvbmZpZ3VyZWQnKSlcbiAgfVxuICBjb25zdCB2YXJzID0gcHJpdmF0ZVZhcnMuZ2V0KHRoaXMpXG4gIGlmICghdmFycyB8fCAhdmFycy5oYXNPd25Qcm9wZXJ0eSgndXJpJykpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdCbG9iVXBsb2FkZXIgdXJpIG5vdCBjb25maWd1cmVkJykpXG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodmFycy51cmkgKyAndjEvc2lnbmVkVVJMLycgKyB1dWlkLCB7XG4gICAgbWV0aG9kOiAnUFVUJyxcbiAgICBtb2RlOiAnY29ycydcbiAgfSlcblxuICByZXR1cm4gZmV0Y2gocmVxdWVzdClcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyAnICcgKyByZXNwb25zZS5zdGF0dXNUZXh0KSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9KVxuICAgIC50aGVuKChhcGlSZXNwb25zZSkgPT4gYXBpUmVzcG9uc2UuZ2V0VXJsKVxuICAgIC5jYXRjaCgoZXJyKSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgYmxvYiB1cmw6ICcgKyBlcnIpKSlcbn1cblxuQmxvYlVwbG9hZGVyLnByb3RvdHlwZS51cGxvYWRCbG9iID0gZnVuY3Rpb24gKFxuICBibG9iIC8qOiBCbG9iICovLFxuICBwcm9ncmVzc0ZuIC8qID86RnVuY3Rpb24gKi9cbikgLyogOlByb21pc2U8T2JqZWN0PiAqLyB7XG4gIGlmICghYmxvYikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Jsb2IgYXJndW1lbnQgbm90IHByb3ZpZGVkJykpXG4gIH1cblxuICBjb25zdCB2YXJzID0gcHJpdmF0ZVZhcnMuZ2V0KHRoaXMpXG4gIGlmICghdmFycyB8fCAhdmFycy5oYXNPd25Qcm9wZXJ0eSgndXJpJykpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdCbG9iVXBsb2FkZXIgdXJpIG5vdCBjb25maWd1cmVkJykpXG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodmFycy51cmkgKyAndjEvdGVtcG9yYXJ5Q3JlZGVudGlhbHMnLCB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBtb2RlOiAnY29ycydcbiAgfSlcblxuICByZXR1cm4gZmV0Y2gocmVxdWVzdClcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXMgKyAnICcgKyByZXNwb25zZS5zdGF0dXNUZXh0KSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICB9KVxuICAgIC50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgUzMgPSByZXF1aXJlKCdhd3Mtc2RrL2NsaWVudHMvczMnKVxuICAgICAgY29uc3QgczMgPSBuZXcgUzMoe1xuICAgICAgICBhY2Nlc3NLZXlJZDogYXBpUmVzcG9uc2UuY3JlZGVudGlhbHMuQWNjZXNzS2V5SWQsXG4gICAgICAgIHNlY3JldEFjY2Vzc0tleTogYXBpUmVzcG9uc2UuY3JlZGVudGlhbHMuU2VjcmV0QWNjZXNzS2V5LFxuICAgICAgICBzZXNzaW9uVG9rZW46IGFwaVJlc3BvbnNlLmNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbixcbiAgICAgICAgcmVnaW9uOiBhcGlSZXNwb25zZS5yZWdpb25cbiAgICAgIH0pXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIEJ1Y2tldDogYXBpUmVzcG9uc2UuYnVja2V0LFxuICAgICAgICBLZXk6IGFwaVJlc3BvbnNlLmlkLFxuICAgICAgICBCb2R5OiBibG9iXG4gICAgICB9XG4gICAgICBjb25zdCBtYW5hZ2VkVXBsb2FkID0gczMudXBsb2FkKHBhcmFtcylcbiAgICAgIGlmIChwcm9ncmVzc0ZuKSB7XG4gICAgICAgIG1hbmFnZWRVcGxvYWQub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIChldnQpID0+IHtcbiAgICAgICAgICBwcm9ncmVzc0ZuKGV2dC5sb2FkZWQsIGV2dC50b3RhbClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwbG9hZDogKCkgPT4gbWFuYWdlZFVwbG9hZC5wcm9taXNlKCksXG4gICAgICAgIGNhbmNlbDogKCkgPT4gbWFuYWdlZFVwbG9hZC5hYm9ydCgpLFxuICAgICAgICBpZDogYXBpUmVzcG9uc2UuaWRcbiAgICAgIH1cbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHVwbG9hZGluZyB0byBTMzogJyArIGVycikpKVxufVxuXG5CbG9iVXBsb2FkZXIucHJvdG90eXBlLnVwbG9hZEltYWdlID0gZnVuY3Rpb24gKFxuICBpbWFnZSAvKjogSW1hZ2UgKi8sXG4gIHByb2dyZXNzRm4gLyogPzpGdW5jdGlvbiAqL1xuKSAvKiA6UHJvbWlzZTxPYmplY3Q+ICovIHtcbiAgaWYgKCFpbWFnZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2ltYWdlIGFyZ3VtZW50IG5vdCBwcm92aWRlZCcpKVxuICB9XG5cbiAgY29uc3QgdmFycyA9IHByaXZhdGVWYXJzLmdldCh0aGlzKVxuICBpZiAoIXZhcnMgfHwgIXZhcnMuaGFzT3duUHJvcGVydHkoJ3VyaScpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignYmxvYlVwbG9hZGVyIHVyaSBub3QgY29uZmlndXJlZCcpKVxuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGVtcHR5IGNhbnZhcyBlbGVtZW50XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoXG4gIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHRcblxuICAvLyBDb3B5IHRoZSBpbWFnZSBjb250ZW50cyB0byB0aGUgY2FudmFzXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApXG4gIGNvbnN0IF90aGlzID0gdGhpc1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgcmVzb2x2ZShfdGhpcy51cGxvYWRCbG9iKGJsb2IsIHByb2dyZXNzRm4pKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvYlVwbG9hZGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYmxvYi11cGxvYWRlci5qcyIsInJlcXVpcmUoJy4uL2xpYi9ub2RlX2xvYWRlcicpO1xudmFyIEFXUyA9IHJlcXVpcmUoJy4uL2xpYi9jb3JlJyk7XG52YXIgU2VydmljZSA9IEFXUy5TZXJ2aWNlO1xudmFyIGFwaUxvYWRlciA9IEFXUy5hcGlMb2FkZXI7XG5cbmFwaUxvYWRlci5zZXJ2aWNlc1snczMnXSA9IHt9O1xuQVdTLlMzID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdzMycsIFsnMjAwNi0wMy0wMSddKTtcbnJlcXVpcmUoJy4uL2xpYi9zZXJ2aWNlcy9zMycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snczMnXSwgJzIwMDYtMDMtMDEnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvczMtMjAwNi0wMy0wMS5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL3MzLTIwMDYtMDMtMDEucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICBtb2RlbC53YWl0ZXJzID0gcmVxdWlyZSgnLi4vYXBpcy9zMy0yMDA2LTAzLTAxLndhaXRlcnMyLmpzb24nKS53YWl0ZXJzO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuUzM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvczMuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCkge1xufVxuXG5RdWVyeVBhcmFtU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgZm4pIHtcbiAgc2VyaWFsaXplU3RydWN0dXJlKCcnLCBwYXJhbXMsIHNoYXBlLCBmbik7XG59O1xuXG5mdW5jdGlvbiB1Y2ZpcnN0KHNoYXBlKSB7XG4gIGlmIChzaGFwZS5pc1F1ZXJ5TmFtZSB8fCBzaGFwZS5hcGkucHJvdG9jb2wgIT09ICdlYzInKSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYXBlLm5hbWVbMF0udG9VcHBlckNhc2UoKSArIHNoYXBlLm5hbWUuc3Vic3RyKDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdHVyZShwcmVmaXgsIHN0cnVjdCwgcnVsZXMsIGZuKSB7XG4gIHV0aWwuZWFjaChydWxlcy5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHJ1Y3RbbmFtZV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBtZW1iZXJOYW1lID0gdWNmaXJzdChtZW1iZXIpO1xuICAgIG1lbWJlck5hbWUgPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBtZW1iZXJOYW1lIDogbWVtYmVyTmFtZTtcbiAgICBzZXJpYWxpemVNZW1iZXIobWVtYmVyTmFtZSwgdmFsdWUsIG1lbWJlciwgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwKG5hbWUsIG1hcCwgcnVsZXMsIGZuKSB7XG4gIHZhciBpID0gMTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcHJlZml4ID0gcnVsZXMuZmxhdHRlbmVkID8gJy4nIDogJy5lbnRyeS4nO1xuICAgIHZhciBwb3NpdGlvbiA9IHByZWZpeCArIChpKyspICsgJy4nO1xuICAgIHZhciBrZXlOYW1lID0gcG9zaXRpb24gKyAocnVsZXMua2V5Lm5hbWUgfHwgJ2tleScpO1xuICAgIHZhciB2YWx1ZU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy52YWx1ZS5uYW1lIHx8ICd2YWx1ZScpO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsga2V5TmFtZSwga2V5LCBydWxlcy5rZXksIGZuKTtcbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHZhbHVlTmFtZSwgdmFsdWUsIHJ1bGVzLnZhbHVlLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KG5hbWUsIGxpc3QsIHJ1bGVzLCBmbikge1xuICB2YXIgbWVtYmVyUnVsZXMgPSBydWxlcy5tZW1iZXIgfHwge307XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgZm4uY2FsbCh0aGlzLCBuYW1lLCBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbiAodiwgbikge1xuICAgIHZhciBzdWZmaXggPSAnLicgKyAobiArIDEpO1xuICAgIGlmIChydWxlcy5hcGkucHJvdG9jb2wgPT09ICdlYzInKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGZvciBFQzJcbiAgICAgIHN1ZmZpeCA9IHN1ZmZpeCArICcnOyAvLyBtYWtlIGxpbnRlciBoYXBweVxuICAgIH0gZWxzZSBpZiAocnVsZXMuZmxhdHRlbmVkKSB7XG4gICAgICBpZiAobWVtYmVyUnVsZXMubmFtZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXJ0cy5wdXNoKHVjZmlyc3QobWVtYmVyUnVsZXMpKTtcbiAgICAgICAgbmFtZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VmZml4ID0gJy4nICsgKG1lbWJlclJ1bGVzLm5hbWUgPyBtZW1iZXJSdWxlcy5uYW1lIDogJ21lbWJlcicpICsgc3VmZml4O1xuICAgIH1cbiAgICBzZXJpYWxpemVNZW1iZXIobmFtZSArIHN1ZmZpeCwgdiwgbWVtYmVyUnVsZXMsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1lbWJlcihuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIGlmIChydWxlcy50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgIHNlcmlhbGl6ZVN0cnVjdHVyZShuYW1lLCB2YWx1ZSwgcnVsZXMsIGZuKTtcbiAgfSBlbHNlIGlmIChydWxlcy50eXBlID09PSAnbGlzdCcpIHtcbiAgICBzZXJpYWxpemVMaXN0KG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgc2VyaWFsaXplTWFwKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2Uge1xuICAgIGZuKG5hbWUsIHJ1bGVzLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVBhcmFtU2VyaWFsaXplcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgYnVpbGRlciA9IHJlcXVpcmUoJ3htbGJ1aWxkZXInKTtcblxuZnVuY3Rpb24gWG1sQnVpbGRlcigpIHsgfVxuXG5YbWxCdWlsZGVyLnByb3RvdHlwZS50b1hNTCA9IGZ1bmN0aW9uKHBhcmFtcywgc2hhcGUsIHJvb3RFbGVtZW50LCBub0VtcHR5KSB7XG4gIHZhciB4bWwgPSBidWlsZGVyLmNyZWF0ZShyb290RWxlbWVudCk7XG4gIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlKTtcbiAgc2VyaWFsaXplKHhtbCwgcGFyYW1zLCBzaGFwZSk7XG4gIHJldHVybiB4bWwuY2hpbGRyZW4ubGVuZ3RoID4gMCB8fCBub0VtcHR5ID8geG1sLnJvb3QoKS50b1N0cmluZygpIDogJyc7XG59O1xuXG5mdW5jdGlvbiBzZXJpYWxpemUoeG1sLCB2YWx1ZSwgc2hhcGUpIHtcbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHNlcmlhbGl6ZVN0cnVjdHVyZSh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHNlcmlhbGl6ZU1hcCh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiBzZXJpYWxpemVMaXN0KHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gc2VyaWFsaXplU2NhbGFyKHhtbCwgdmFsdWUsIHNoYXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3R1cmUoeG1sLCBwYXJhbXMsIHNoYXBlKSB7XG4gIHV0aWwuYXJyYXlFYWNoKHNoYXBlLm1lbWJlck5hbWVzLCBmdW5jdGlvbihtZW1iZXJOYW1lKSB7XG4gICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1ttZW1iZXJOYW1lXTtcbiAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW21lbWJlck5hbWVdO1xuICAgIHZhciBuYW1lID0gbWVtYmVyU2hhcGUubmFtZTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG1lbWJlclNoYXBlLmlzWG1sQXR0cmlidXRlKSB7XG4gICAgICAgIHhtbC5hdHQobmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXJTaGFwZS5mbGF0dGVuZWQpIHtcbiAgICAgICAgc2VyaWFsaXplKHhtbCwgdmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0geG1sLmVsZShuYW1lKTtcbiAgICAgICAgYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnQsIG1lbWJlclNoYXBlKTtcbiAgICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWFwKHhtbCwgbWFwLCBzaGFwZSkge1xuICB2YXIgeG1sS2V5ID0gc2hhcGUua2V5Lm5hbWUgfHwgJ2tleSc7XG4gIHZhciB4bWxWYWx1ZSA9IHNoYXBlLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJztcblxuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0geG1sLmVsZShzaGFwZS5mbGF0dGVuZWQgPyBzaGFwZS5uYW1lIDogJ2VudHJ5Jyk7XG4gICAgc2VyaWFsaXplKGVudHJ5LmVsZSh4bWxLZXkpLCBrZXksIHNoYXBlLmtleSk7XG4gICAgc2VyaWFsaXplKGVudHJ5LmVsZSh4bWxWYWx1ZSksIHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KHhtbCwgbGlzdCwgc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNoYXBlLm1lbWJlci5uYW1lIHx8IHNoYXBlLm5hbWU7XG4gICAgICB2YXIgZWxlbWVudCA9IHhtbC5lbGUobmFtZSk7XG4gICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBuYW1lID0gc2hhcGUubWVtYmVyLm5hbWUgfHwgJ21lbWJlcic7XG4gICAgICB2YXIgZWxlbWVudCA9IHhtbC5lbGUobmFtZSk7XG4gICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU2NhbGFyKHhtbCwgdmFsdWUsIHNoYXBlKSB7XG4gIHhtbC50eHQoc2hhcGUudG9XaXJlRm9ybWF0KHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlKSB7XG4gIHZhciB1cmksIHByZWZpeCA9ICd4bWxucyc7XG4gIGlmIChzaGFwZS54bWxOYW1lc3BhY2VVcmkpIHtcbiAgICB1cmkgPSBzaGFwZS54bWxOYW1lc3BhY2VVcmk7XG4gICAgaWYgKHNoYXBlLnhtbE5hbWVzcGFjZVByZWZpeCkgcHJlZml4ICs9ICc6JyArIHNoYXBlLnhtbE5hbWVzcGFjZVByZWZpeDtcbiAgfSBlbHNlIGlmICh4bWwuaXNSb290ICYmIHNoYXBlLmFwaS54bWxOYW1lc3BhY2VVcmkpIHtcbiAgICB1cmkgPSBzaGFwZS5hcGkueG1sTmFtZXNwYWNlVXJpO1xuICB9XG5cbiAgaWYgKHVyaSkgeG1sLmF0dChwcmVmaXgsIHVyaSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sQnVpbGRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9idWlsZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEJ1aWxkZXIsIGFzc2lnbjtcblxuICBhc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2gvYXNzaWduJyk7XG5cbiAgWE1MQnVpbGRlciA9IHJlcXVpcmUoJy4vWE1MQnVpbGRlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHhtbGRlYywgZG9jdHlwZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIHhtbGRlYywgZG9jdHlwZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBYTUxCdWlsZGVyKG5hbWUsIG9wdGlvbnMpLnJvb3QoKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduSW5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxCdWlsZGVyLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRWxlbWVudCwgWE1MU3RyaW5naWZpZXI7XG5cbiAgWE1MU3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL1hNTFN0cmluZ2lmaWVyJyk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTEVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTEVsZW1lbnQnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTEJ1aWxkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MQnVpbGRlcihuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcm9vdCwgdGVtcDtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBlbGVtZW50IG5lZWRzIGEgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gbmV3IFhNTFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICAgICAgdGVtcCA9IG5ldyBYTUxFbGVtZW50KHRoaXMsICdkb2MnKTtcbiAgICAgIHJvb3QgPSB0ZW1wLmVsZW1lbnQobmFtZSk7XG4gICAgICByb290LmlzUm9vdCA9IHRydWU7XG4gICAgICByb290LmRvY3VtZW50T2JqZWN0ID0gdGhpcztcbiAgICAgIHRoaXMucm9vdE9iamVjdCA9IHJvb3Q7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGxlc3MpIHtcbiAgICAgICAgcm9vdC5kZWNsYXJhdGlvbihvcHRpb25zKTtcbiAgICAgICAgaWYgKChvcHRpb25zLnB1YklEICE9IG51bGwpIHx8IChvcHRpb25zLnN5c0lEICE9IG51bGwpKSB7XG4gICAgICAgICAgcm9vdC5kb2N0eXBlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MQnVpbGRlci5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdE9iamVjdDtcbiAgICB9O1xuXG4gICAgWE1MQnVpbGRlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFhNTEJ1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMjtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHRoaXMueG1sZGVjICE9IG51bGwpIHtcbiAgICAgICAgciArPSB0aGlzLnhtbGRlYy50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRvY3R5cGUgIT0gbnVsbCkge1xuICAgICAgICByICs9IHRoaXMuZG9jdHlwZS50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy5yb290T2JqZWN0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgaWYgKHByZXR0eSAmJiByLnNsaWNlKC1uZXdsaW5lLmxlbmd0aCkgPT09IG5ld2xpbmUpIHtcbiAgICAgICAgciA9IHIuc2xpY2UoMCwgLW5ld2xpbmUubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQnVpbGRlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MU3RyaW5naWZpZXIsXG4gICAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MU3RyaW5naWZpZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MU3RyaW5naWZpZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5hc3NlcnRMZWdhbENoYXIgPSBiaW5kKHRoaXMuYXNzZXJ0TGVnYWxDaGFyLCB0aGlzKTtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICB0aGlzLmFsbG93U3Vycm9nYXRlQ2hhcnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmFsbG93U3Vycm9nYXRlQ2hhcnMgOiB2b2lkIDA7XG4gICAgICB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5vRG91YmxlRW5jb2RpbmcgOiB2b2lkIDA7XG4gICAgICByZWYgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5zdHJpbmdpZnkgOiB2b2lkIDApIHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5lbGVOYW1lID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih2YWwpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZWxlVGV4dCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodGhpcy5lbEVzY2FwZSh2YWwpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goL11dPi8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQ0RBVEEgdGV4dDogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goLy0tLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudCB0ZXh0IGNhbm5vdCBjb250YWluIGRvdWJsZS1oeXBlbjogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dE5hbWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmF0dEVzY2FwZSh2YWwpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuaW5zVGFyZ2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5pbnNWYWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAodmFsLm1hdGNoKC9cXD8+LykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9jZXNzaW5nIGluc3RydWN0aW9uIHZhbHVlOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUueG1sVmVyc2lvbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvMVxcLlswLTldKy8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbiBudW1iZXI6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxFbmNvZGluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICBpZiAoIXZhbC5tYXRjaCgvXltBLVphLXpdKD86W0EtWmEtejAtOS5fLV18LSkqJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW5jb2Rpbmc6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxTdGFuZGFsb25lID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHJldHVybiBcInllc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwibm9cIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZFB1YklEID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRTeXNJRCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkRWxlbWVudFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRBdHRUeXBlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRBdHREZWZhdWx0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEVudGl0eVZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRORGF0YSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydEF0dEtleSA9ICdAJztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0UElLZXkgPSAnPyc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFRleHRLZXkgPSAnI3RleHQnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRDRGF0YUtleSA9ICcjY2RhdGEnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRDb21tZW50S2V5ID0gJyNjb21tZW50JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0UmF3S2V5ID0gJyNyYXcnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmFzc2VydExlZ2FsQ2hhciA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGNoYXJzLCBjaHI7XG4gICAgICBpZiAodGhpcy5hbGxvd1N1cnJvZ2F0ZUNoYXJzKSB7XG4gICAgICAgIGNoYXJzID0gL1tcXHUwMDAwLVxcdTAwMDhcXHUwMDBCLVxcdTAwMENcXHUwMDBFLVxcdTAwMUZcXHVGRkZFLVxcdUZGRkZdLztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzID0gL1tcXHUwMDAwLVxcdTAwMDhcXHUwMDBCLVxcdTAwMENcXHUwMDBFLVxcdTAwMUZcXHVEODAwLVxcdURGRkZcXHVGRkZFLVxcdUZGRkZdLztcbiAgICAgIH1cbiAgICAgIGNociA9IHN0ci5tYXRjaChjaGFycyk7XG4gICAgICBpZiAoY2hyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyIChcIiArIGNociArIFwiKSBpbiBzdHJpbmc6IFwiICsgc3RyICsgXCIgYXQgaW5kZXggXCIgKyBjaHIuaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmVsRXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYW1wcmVnZXg7XG4gICAgICBhbXByZWdleCA9IHRoaXMubm9Eb3VibGVFbmNvZGluZyA/IC8oPyEmXFxTKzspJi9nIDogLyYvZztcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShhbXByZWdleCwgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cXHIvZywgJyYjeEQ7Jyk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5hdHRFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBhbXByZWdleDtcbiAgICAgIGFtcHJlZ2V4ID0gdGhpcy5ub0RvdWJsZUVuY29kaW5nID8gLyg/ISZcXFMrOykmL2cgOiAvJi9nO1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGFtcHJlZ2V4LCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MU3RyaW5naWZpZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFN0cmluZ2lmaWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VtcHR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlFdmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5RXZlcnknKSxcbiAgICBiYXNlRXZlcnkgPSByZXF1aXJlKCcuL19iYXNlRXZlcnknKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RXZlcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RXZlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWBcbiAqL1xuZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRXZlcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFdmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlLCBjcmVhdGU7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTEF0dHJpYnV0ZShwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlIG5hbWUgb2YgZWxlbWVudCBcIiArIHBhcmVudC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlIHZhbHVlIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lICsgXCIgb2YgZWxlbWVudCBcIiArIHBhcmVudC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmF0dE5hbWUobmFtZSk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuYXR0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoWE1MQXR0cmlidXRlLnByb3RvdHlwZSwgdGhpcyk7XG4gICAgfTtcblxuICAgIFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgcmV0dXJuICcgJyArIHRoaXMubmFtZSArICc9XCInICsgdGhpcy52YWx1ZSArICdcIic7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxBdHRyaWJ1dGU7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEF0dHJpYnV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFREQXR0TGlzdCwgY3JlYXRlO1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREF0dExpc3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFREQXR0TGlzdChwYXJlbnQsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmIChlbGVtZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgYXR0cmlidXRlIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZmF1bHRWYWx1ZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgYXR0cmlidXRlIGRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZS5pbmRleE9mKCcjJykgIT09IDApIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlVHlwZSA9ICcjJyArIGRlZmF1bHRWYWx1ZVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZmF1bHRWYWx1ZVR5cGUubWF0Y2goL14oI1JFUVVJUkVEfCNJTVBMSUVEfCNGSVhFRHwjREVGQVVMVCkkLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkZWZhdWx0IHZhbHVlIHR5cGU7IGV4cGVjdGVkOiAjUkVRVUlSRUQsICNJTVBMSUVELCAjRklYRUQgb3IgI0RFRkFVTFRcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICYmICFkZWZhdWx0VmFsdWVUeXBlLm1hdGNoKC9eKCNGSVhFRHwjREVGQVVMVCkkLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSBvbmx5IGFwcGxpZXMgdG8gI0ZJWEVEIG9yICNERUZBVUxUXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtZW50TmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUoZWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gdGhpcy5zdHJpbmdpZnkuYXR0TmFtZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlVHlwZSA9IHRoaXMuc3RyaW5naWZ5LmR0ZEF0dFR5cGUoYXR0cmlidXRlVHlwZSk7XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmR0ZEF0dERlZmF1bHQoZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlVHlwZSA9IGRlZmF1bHRWYWx1ZVR5cGU7XG4gICAgfVxuXG4gICAgWE1MRFREQXR0TGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8IUFUVExJU1QgJyArIHRoaXMuZWxlbWVudE5hbWUgKyAnICcgKyB0aGlzLmF0dHJpYnV0ZU5hbWUgKyAnICcgKyB0aGlzLmF0dHJpYnV0ZVR5cGU7XG4gICAgICBpZiAodGhpcy5kZWZhdWx0VmFsdWVUeXBlICE9PSAnI0RFRkFVTFQnKSB7XG4gICAgICAgIHIgKz0gJyAnICsgdGhpcy5kZWZhdWx0VmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyBcIicgKyB0aGlzLmRlZmF1bHRWYWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgICByICs9ICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERBdHRMaXN0O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVERBdHRMaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbnRpdHksIGNyZWF0ZSwgaXNPYmplY3Q7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbnRpdHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFRERW50aXR5KHBhcmVudCwgcGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW50aXR5IG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVudGl0eSB2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGUgPSAhIXBlO1xuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRFbnRpdHlWYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBhbmQvb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gaWRlbnRpZmllciBpcyByZXF1aXJlZCBmb3IgYSBwdWJsaWMgZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wdWJJRCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5wdWJJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFB1YklEKHZhbHVlLnB1YklEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc3lzSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRTeXNJRCh2YWx1ZS5zeXNJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLm5EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm5EYXRhID0gdGhpcy5zdHJpbmdpZnkuZHRkTkRhdGEodmFsdWUubkRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlICYmIHRoaXMubkRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RhdGlvbiBkZWNsYXJhdGlvbiBpcyBub3QgYWxsb3dlZCBpbiBhIHBhcmFtZXRlciBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEVERFbnRpdHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPCFFTlRJVFknO1xuICAgICAgaWYgKHRoaXMucGUpIHtcbiAgICAgICAgciArPSAnICUnO1xuICAgICAgfVxuICAgICAgciArPSAnICcgKyB0aGlzLm5hbWU7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICByICs9ICcgXCInICsgdGhpcy52YWx1ZSArICdcIic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5wdWJJRCAmJiB0aGlzLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyB0aGlzLnB1YklEICsgJ1wiIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5EYXRhKSB7XG4gICAgICAgICAgciArPSAnIE5EQVRBICcgKyB0aGlzLm5EYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByICs9ICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbnRpdHk7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVudGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFRERWxlbWVudCwgY3JlYXRlO1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREVsZW1lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFRERWxlbWVudChwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSAnKCNQQ0RBVEEpJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBYTUxEVERFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwhRUxFTUVOVCAnICsgdGhpcy5uYW1lICsgJyAnICsgdGhpcy52YWx1ZSArICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbGVtZW50O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVERFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVEROb3RhdGlvbiwgY3JlYXRlO1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERURE5vdGF0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTERURE5vdGF0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBub3RhdGlvbiBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGljIG9yIHN5c3RlbSBpZGVudGlmaWVycyBhcmUgcmVxdWlyZWQgZm9yIGFuIGV4dGVybmFsIGVudGl0eVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICBpZiAodmFsdWUucHViSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQodmFsdWUucHViSUQpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLnN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHZhbHVlLnN5c0lEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEVEROb3RhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8IU5PVEFUSU9OICcgKyB0aGlzLm5hbWU7XG4gICAgICBpZiAodGhpcy5wdWJJRCAmJiB0aGlzLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgdGhpcy5wdWJJRCArICdcIiBcIicgKyB0aGlzLnN5c0lEICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wdWJJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIHRoaXMucHViSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgdGhpcy5zeXNJRCArICdcIic7XG4gICAgICB9XG4gICAgICByICs9ICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVEROb3RhdGlvbjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRETm90YXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFJhdywgY3JlYXRlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFJhdyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFJhdywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxSYXcocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxSYXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByYXcgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5yYXcodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MUmF3LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZShYTUxSYXcucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MUmF3LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy52YWx1ZTtcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxSYXc7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxSYXcuanNcbi8vIG1vZHVsZSBpZCA9IDE5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFRleHQsIGNyZWF0ZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxUZXh0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MVGV4dCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxUZXh0KHBhcmVudCwgdGV4dCkge1xuICAgICAgWE1MVGV4dC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVUZXh0KHRleHQpO1xuICAgIH1cblxuICAgIFhNTFRleHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKFhNTFRleHQucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MVGV4dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9IHRoaXMudmFsdWU7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MVGV4dDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImZ1bmN0aW9uIGFwaUxvYWRlcihzdmMsIHZlcnNpb24pIHtcbiAgaWYgKCFhcGlMb2FkZXIuc2VydmljZXMuaGFzT3duUHJvcGVydHkoc3ZjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFNlcnZpY2U6IEZhaWxlZCB0byBsb2FkIGFwaSBmb3IgJyArIHN2Yyk7XG4gIH1cbiAgcmV0dXJuIGFwaUxvYWRlci5zZXJ2aWNlc1tzdmNdW3ZlcnNpb25dO1xufVxuXG4vKipcbiAqIFRoaXMgbWVtYmVyIG9mIEFXUy5hcGlMb2FkZXIgaXMgcHJpdmF0ZSwgYnV0IGNoYW5naW5nIGl0IHdpbGwgbmVjZXNzaXRhdGUgYVxuICogY2hhbmdlIHRvIC4uL3NjcmlwdHMvc2VydmljZXMtdGFibGUtZ2VuZXJhdG9yLnRzXG4gKi9cbmFwaUxvYWRlci5zZXJ2aWNlcyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGlMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9hcGlfbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQXBpID0gcmVxdWlyZSgnLi9tb2RlbC9hcGknKTtcbnZhciByZWdpb25Db25maWcgPSByZXF1aXJlKCcuL3JlZ2lvbl9jb25maWcnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBjbGllbnRDb3VudCA9IDA7XG5cbi8qKlxuICogVGhlIHNlcnZpY2UgY2xhc3MgcmVwcmVzZW50aW5nIGFuIEFXUyBzZXJ2aWNlLlxuICpcbiAqIEBhYnN0cmFjdFxuICpcbiAqIEAhYXR0cmlidXRlIGFwaVZlcnNpb25zXG4gKiAgIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIHRoZSBsaXN0IG9mIEFQSSB2ZXJzaW9ucyBzdXBwb3J0ZWQgYnkgdGhpcyBzZXJ2aWNlLlxuICogICBAcmVhZG9ubHlcbiAqL1xuQVdTLlNlcnZpY2UgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJ2aWNlIG9iamVjdCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTZXJ2aWNlKGNvbmZpZykge1xuICAgIGlmICghdGhpcy5sb2FkU2VydmljZUNsYXNzKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgJ1NlcnZpY2UgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGBuZXdcXCcgb3BlcmF0b3InKTtcbiAgICB9XG4gICAgdmFyIFNlcnZpY2VDbGFzcyA9IHRoaXMubG9hZFNlcnZpY2VDbGFzcyhjb25maWcgfHwge30pO1xuICAgIGlmIChTZXJ2aWNlQ2xhc3MpIHtcbiAgICAgIHZhciBvcmlnaW5hbENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY29uZmlnKTtcbiAgICAgIHZhciBzdmMgPSBuZXcgU2VydmljZUNsYXNzKGNvbmZpZyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ZjLCAnX29yaWdpbmFsQ29uZmlnJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3JpZ2luYWxDb25maWc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc3ZjLl9jbGllbnRJZCA9ICsrY2xpZW50Q291bnQ7XG4gICAgICByZXR1cm4gc3ZjO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemUoY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGNvbmZpZykge1xuICAgIHZhciBzdmNDb25maWcgPSBBV1MuY29uZmlnW3RoaXMuc2VydmljZUlkZW50aWZpZXJdO1xuXG4gICAgdGhpcy5jb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICBpZiAoc3ZjQ29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoc3ZjQ29uZmlnLCB0cnVlKTtcbiAgICBpZiAoY29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoY29uZmlnLCB0cnVlKTtcblxuICAgIHRoaXMudmFsaWRhdGVTZXJ2aWNlKCk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmRwb2ludCkgcmVnaW9uQ29uZmlnKHRoaXMpO1xuXG4gICAgdGhpcy5jb25maWcuZW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50RnJvbVRlbXBsYXRlKHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgICB0aGlzLnNldEVuZHBvaW50KHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZVNlcnZpY2U6IGZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZSgpIHtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkU2VydmljZUNsYXNzOiBmdW5jdGlvbiBsb2FkU2VydmljZUNsYXNzKHNlcnZpY2VDb25maWcpIHtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICBpZiAoIUFXUy51dGlsLmlzRW1wdHkodGhpcy5hcGkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hcGlDb25maWcpIHtcbiAgICAgIHJldHVybiBBV1MuU2VydmljZS5kZWZpbmVTZXJ2aWNlQXBpKHRoaXMuY29uc3RydWN0b3IsIGNvbmZpZy5hcGlDb25maWcpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICAgIGNvbmZpZy51cGRhdGUoc2VydmljZUNvbmZpZywgdHJ1ZSk7XG4gICAgICB2YXIgdmVyc2lvbiA9IGNvbmZpZy5hcGlWZXJzaW9uc1t0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyXTtcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uIHx8IGNvbmZpZy5hcGlWZXJzaW9uO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0U2VydmljZUNsYXNzKHZlcnNpb24pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRMYXRlc3RTZXJ2aWNlQ2xhc3M6IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VDbGFzcyh2ZXJzaW9uKSB7XG4gICAgdmVyc2lvbiA9IHRoaXMuZ2V0TGF0ZXN0U2VydmljZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl0gPT09IG51bGwpIHtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZVNlcnZpY2VBcGkodGhpcy5jb25zdHJ1Y3RvciwgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGF0ZXN0U2VydmljZVZlcnNpb246IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMgfHwgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VydmljZXMgZGVmaW5lZCBvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSAnbGF0ZXN0JztcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzVHlwZSh2ZXJzaW9uLCBEYXRlKSkge1xuICAgICAgdmVyc2lvbiA9IEFXUy51dGlsLmRhdGUuaXNvODYwMSh2ZXJzaW9uKS5zcGxpdCgnVCcpWzBdO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkodGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcywgdmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcykuc29ydCgpO1xuICAgIHZhciBzZWxlY3RlZFZlcnNpb24gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyB2ZXJzaW9ucyB0aGF0IGVuZCBpbiBcIipcIiBhcmUgbm90IGF2YWlsYWJsZSBvbiBkaXNrIGFuZCBjYW4gYmVcbiAgICAgIC8vIHNraXBwZWQsIHNvIGRvIG5vdCBjaG9vc2UgdGhlc2UgYXMgc2VsZWN0ZWRWZXJzaW9uc1xuICAgICAgaWYgKGtleXNbaV1ba2V5c1tpXS5sZW5ndGggLSAxXSAhPT0gJyonKSB7XG4gICAgICAgIHNlbGVjdGVkVmVyc2lvbiA9IGtleXNbaV07XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1tpXS5zdWJzdHIoMCwgMTApIDw9IHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kICcgKyB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBBUEkgdG8gc2F0aXNmeSB2ZXJzaW9uIGNvbnN0cmFpbnQgYCcgKyB2ZXJzaW9uICsgJ1xcJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaToge30sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFJldHJ5Q291bnQ6IDMsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3VzdG9taXplUmVxdWVzdHM6IGZ1bmN0aW9uIGN1c3RvbWl6ZVJlcXVlc3RzKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNhbGxiYWNrIHR5cGUgXFwnJyArIHR5cGVvZiBjYWxsYmFjayArICdcXCcgcHJvdmlkZWQgaW4gY3VzdG9taXplUmVxdWVzdHMnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxzIGFuIG9wZXJhdGlvbiBvbiBhIHNlcnZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGNhbGwgb24gdGhlIHNlcnZpY2UuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgaW5wdXQgb3B0aW9ucyBmb3IgdGhlIG9wZXJhdGlvblxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgbWFrZVJlcXVlc3Q6IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGlmICh0aGlzLmNvbmZpZy5wYXJhbXMpIHsgLy8gY29weSBvbmx5IHRvcGxldmVsIGJvdW5kIHBhcmFtc1xuICAgICAgdmFyIHJ1bGVzID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dO1xuICAgICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgICAgQVdTLnV0aWwuZWFjaCh0aGlzLmNvbmZpZy5wYXJhbXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAocnVsZXMuaW5wdXQubWVtYmVyc1trZXldKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZCB8fCBwYXJhbXNba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgQVdTLlJlcXVlc3QodGhpcywgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICAgIHRoaXMuYWRkQWxsUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KTtcblxuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbHMgYW4gb3BlcmF0aW9uIG9uIGEgc2VydmljZSB3aXRoIHRoZSBnaXZlbiBpbnB1dCBwYXJhbWV0ZXJzLCB3aXRob3V0XG4gICAqIGFueSBhdXRoZW50aWNhdGlvbiBkYXRhLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIFwicHVibGljXCIgQVBJIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsIG9uIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIGlucHV0IG9wdGlvbnMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIG1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0OiBmdW5jdGlvbiBtYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMpLnRvVW5hdXRoZW50aWNhdGVkKCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrID8gcmVxdWVzdC5zZW5kKGNhbGxiYWNrKSA6IHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgb24gdGhlIHNlcnZpY2UgdG8gd2FpdCBmb3JcbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3Mgd2l0aCBlYWNoIHJlcXVlc3RcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlciBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSB3YWl0ZXJcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5kZWxheSBbTnVtYmVyXSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHNcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5tYXhBdHRlbXB0cyBbTnVtYmVyXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVxdWVzdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzZW5kIHdoaWxlIHdhaXRpbmdcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIHdhaXRGb3I6IGZ1bmN0aW9uIHdhaXRGb3Ioc3RhdGUsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgd2FpdGVyID0gbmV3IEFXUy5SZXNvdXJjZVdhaXRlcih0aGlzLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHdhaXRlci53YWl0KHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHZhciBsaXN0ID0gW0FXUy5ldmVudHMsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLCB0aGlzLnNlcnZpY2VJbnRlcmZhY2UoKSxcbiAgICAgICAgICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZVBvc3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0pIHJlcXVlc3QuYWRkTGlzdGVuZXJzKGxpc3RbaV0pO1xuICAgIH1cblxuICAgIC8vIGRpc2FibGUgcGFyYW1ldGVyIHZhbGlkYXRpb25cbiAgICBpZiAoIXRoaXMuY29uZmlnLnBhcmFtVmFsaWRhdGlvbikge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcubG9nZ2VyKSB7IC8vIGFkZCBsb2dnaW5nIGV2ZW50c1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcnMoQVdTLkV2ZW50TGlzdGVuZXJzLkxvZ2dlcik7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCk7XG4gICAgLy8gY2FsbCBwcm90b3R5cGUncyBjdXN0b21SZXF1ZXN0SGFuZGxlclxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgICAvLyBjYWxsIGluc3RhbmNlJ3MgY3VzdG9tUmVxdWVzdEhhbmRsZXJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdjdXN0b21SZXF1ZXN0SGFuZGxlcicpICYmIHR5cGVvZiB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gc2V0dXAgYW55IGN1c3RvbSByZXF1ZXN0IGxpc3RlbmVycyBmb3IgZWFjaFxuICAgKiBuZXcgcmVxdWVzdCB0byB0aGUgc2VydmljZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycygpIHtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2lnbmVyIGNsYXNzIGZvciBhIGdpdmVuIHJlcXVlc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduZXJDbGFzczogZnVuY3Rpb24gZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCkge1xuICAgIHZhciB2ZXJzaW9uO1xuICAgIC8vIGdldCBvcGVyYXRpb24gYXV0aHR5cGUgaWYgcHJlc2VudFxuICAgIHZhciBvcGVyYXRpb24gPSBudWxsO1xuICAgIHZhciBhdXRodHlwZSA9ICcnO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9ucyB8fCB7fTtcbiAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIHx8IG51bGw7XG4gICAgICBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb247XG4gICAgfSBlbHNlIGlmIChhdXRodHlwZSA9PT0gJ3Y0JyB8fCBhdXRodHlwZSA9PT0gJ3Y0LXVuc2lnbmVkLWJvZHknKSB7XG4gICAgICB2ZXJzaW9uID0gJ3Y0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdmVyc2lvbiA9IHRoaXMuYXBpLnNpZ25hdHVyZVZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24odmVyc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2VydmljZUludGVyZmFjZTogZnVuY3Rpb24gc2VydmljZUludGVyZmFjZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdlYzInOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlF1ZXJ5O1xuICAgICAgY2FzZSAncXVlcnknOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlF1ZXJ5O1xuICAgICAgY2FzZSAnanNvbic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuSnNvbjtcbiAgICAgIGNhc2UgJ3Jlc3QtanNvbic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUmVzdEpzb247XG4gICAgICBjYXNlICdyZXN0LXhtbCc6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUmVzdFhtbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBgcHJvdG9jb2xcXCcgJyArXG4gICAgICAgIHRoaXMuYXBpLnByb3RvY29sICsgJyBpbiBBUEkgY29uZmlnJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZTogZnVuY3Rpb24gc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApIHtcbiAgICByZXR1cm4gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDMwMDtcbiAgfSxcblxuICAvKipcbiAgICogSG93IG1hbnkgdGltZXMgYSBmYWlsZWQgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZCBiZWZvcmUgZ2l2aW5nIHVwLlxuICAgKiB0aGUgZGVmYXVsdFJldHJ5Q291bnQgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXJ2aWNlIGNsYXNzZXMuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbnVtUmV0cmllczogZnVuY3Rpb24gbnVtUmV0cmllcygpIHtcbiAgICBpZiAodGhpcy5jb25maWcubWF4UmV0cmllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4UmV0cmllcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJldHJ5Q291bnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5RGVsYXlzOiBmdW5jdGlvbiByZXRyeURlbGF5cyhyZXRyeUNvdW50KSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNhbGN1bGF0ZVJldHJ5RGVsYXkocmV0cnlDb3VudCwgdGhpcy5jb25maWcucmV0cnlEZWxheU9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5YWJsZUVycm9yOiBmdW5jdGlvbiByZXRyeWFibGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnRpbWVvdXRFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLm5ldHdvcmtpbmdFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmV4cGlyZWRDcmVkZW50aWFsc0Vycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMudGhyb3R0bGVkRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA+PSA1MDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBuZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIG5ldHdvcmtpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0aW1lb3V0RXJyb3I6IGZ1bmN0aW9uIHRpbWVvdXRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnVGltZW91dEVycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHBpcmVkQ3JlZGVudGlhbHNFcnJvcjogZnVuY3Rpb24gZXhwaXJlZENyZWRlbnRpYWxzRXJyb3IoZXJyb3IpIHtcbiAgICAvLyBUT0RPIDogdGhpcyBvbmx5IGhhbmRsZXMgKm9uZSogb2YgdGhlIGV4cGlyZWQgY3JlZGVudGlhbCBjb2Rlc1xuICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsb2NrU2tld0Vycm9yOiBmdW5jdGlvbiBjbG9ja1NrZXdFcnJvcihlcnJvcikge1xuICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgY2FzZSAnUmVxdWVzdFRpbWVUb29Ta2V3ZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdEV4cGlyZWQnOlxuICAgICAgY2FzZSAnSW52YWxpZFNpZ25hdHVyZUV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdTaWduYXR1cmVEb2VzTm90TWF0Y2gnOlxuICAgICAgY2FzZSAnQXV0aEZhaWx1cmUnOlxuICAgICAgY2FzZSAnUmVxdWVzdEluVGhlRnV0dXJlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRocm90dGxlZEVycm9yOiBmdW5jdGlvbiB0aHJvdHRsZWRFcnJvcihlcnJvcikge1xuICAgIC8vIHRoaXMgbG9naWMgdmFyaWVzIGJldHdlZW4gc2VydmljZXNcbiAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgIGNhc2UgJ1Byb3Zpc2lvbmVkVGhyb3VnaHB1dEV4Y2VlZGVkRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1Rocm90dGxpbmcnOlxuICAgICAgY2FzZSAnVGhyb3R0bGluZ0V4Y2VwdGlvbic6XG4gICAgICBjYXNlICdSZXF1ZXN0TGltaXRFeGNlZWRlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0VGhyb3R0bGVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVuZHBvaW50RnJvbVRlbXBsYXRlOiBmdW5jdGlvbiBlbmRwb2ludEZyb21UZW1wbGF0ZShlbmRwb2ludCkge1xuICAgIGlmICh0eXBlb2YgZW5kcG9pbnQgIT09ICdzdHJpbmcnKSByZXR1cm4gZW5kcG9pbnQ7XG5cbiAgICB2YXIgZSA9IGVuZHBvaW50O1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NlcnZpY2VcXH0vZywgdGhpcy5hcGkuZW5kcG9pbnRQcmVmaXgpO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3JlZ2lvblxcfS9nLCB0aGlzLmNvbmZpZy5yZWdpb24pO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NjaGVtZVxcfS9nLCB0aGlzLmNvbmZpZy5zc2xFbmFibGVkID8gJ2h0dHBzJyA6ICdodHRwJyk7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0RW5kcG9pbnQ6IGZ1bmN0aW9uIHNldEVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgdGhpcy5lbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQsIHRoaXMuY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYWdpbmF0aW9uQ29uZmlnOiBmdW5jdGlvbiBwYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdGhyb3dFeGNlcHRpb24pIHtcbiAgICB2YXIgcGFnaW5hdG9yID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dLnBhZ2luYXRvcjtcbiAgICBpZiAoIXBhZ2luYXRvcikge1xuICAgICAgaWYgKHRocm93RXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKGUsICdObyBwYWdpbmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yICcgKyBvcGVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2luYXRvcjtcbiAgfVxufSk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU2VydmljZSwge1xuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBtZXRob2QgZm9yIGVhY2ggb3BlcmF0aW9uIGRlc2NyaWJlZCBpbiB0aGUgYXBpIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZpbmVNZXRob2RzOiBmdW5jdGlvbiBkZWZpbmVNZXRob2RzKHN2Yykge1xuICAgIEFXUy51dGlsLmVhY2goc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9ucywgZnVuY3Rpb24gaXRlcmF0b3IobWV0aG9kKSB7XG4gICAgICBpZiAoc3ZjLnByb3RvdHlwZVttZXRob2RdKSByZXR1cm47XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9uc1ttZXRob2RdO1xuICAgICAgaWYgKG9wZXJhdGlvbi5hdXRodHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5ldyBTZXJ2aWNlIGNsYXNzIHVzaW5nIGEgc2VydmljZSBpZGVudGlmaWVyIGFuZCBsaXN0IG9mIHZlcnNpb25zXG4gICAqIGluY2x1ZGluZyBhbiBvcHRpb25hbCBzZXQgb2YgZmVhdHVyZXMgKGZ1bmN0aW9ucykgdG8gYXBwbHkgdG8gdGhlIGNsYXNzXG4gICAqIHByb3RvdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2VJZGVudGlmaWVyIFtTdHJpbmddIHRoZSBpZGVudGlmaWVyIGZvciB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gdmVyc2lvbnMgW0FycmF5PFN0cmluZz5dIGEgbGlzdCBvZiB2ZXJzaW9ucyB0aGF0IHdvcmsgd2l0aCB0aGlzXG4gICAqICAgc2VydmljZVxuICAgKiBAcGFyYW0gZmVhdHVyZXMgW09iamVjdF0gYW4gb2JqZWN0IHRvIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlXG4gICAqIEByZXR1cm4gW0NsYXNzPFNlcnZpY2U+XSB0aGUgc2VydmljZSBjbGFzcyBkZWZpbmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAqL1xuICBkZWZpbmVTZXJ2aWNlOiBmdW5jdGlvbiBkZWZpbmVTZXJ2aWNlKHNlcnZpY2VJZGVudGlmaWVyLCB2ZXJzaW9ucywgZmVhdHVyZXMpIHtcbiAgICBBV1MuU2VydmljZS5fc2VydmljZU1hcFtzZXJ2aWNlSWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHtcbiAgICAgIGZlYXR1cmVzID0gdmVyc2lvbnM7XG4gICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBzdmMgPSBpbmhlcml0KEFXUy5TZXJ2aWNlLCBmZWF0dXJlcyB8fCB7fSk7XG5cbiAgICBpZiAodHlwZW9mIHNlcnZpY2VJZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgQVdTLlNlcnZpY2UuYWRkVmVyc2lvbnMoc3ZjLCB2ZXJzaW9ucyk7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gc3ZjLnNlcnZpY2VJZGVudGlmaWVyIHx8IHNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgc3ZjLnNlcnZpY2VJZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9IGVsc2UgeyAvLyBkZWZpbmVTZXJ2aWNlIGNhbGxlZCB3aXRoIGFuIEFQSVxuICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZU1ldGhvZHMoc3ZjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ZjO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZFZlcnNpb25zOiBmdW5jdGlvbiBhZGRWZXJzaW9ucyhzdmMsIHZlcnNpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnNpb25zKSkgdmVyc2lvbnMgPSBbdmVyc2lvbnNdO1xuXG4gICAgc3ZjLnNlcnZpY2VzID0gc3ZjLnNlcnZpY2VzIHx8IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdmMuc2VydmljZXNbdmVyc2lvbnNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ZjLnNlcnZpY2VzW3ZlcnNpb25zW2ldXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3ZjLmFwaVZlcnNpb25zID0gT2JqZWN0LmtleXMoc3ZjLnNlcnZpY2VzKS5zb3J0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmaW5lU2VydmljZUFwaTogZnVuY3Rpb24gZGVmaW5lU2VydmljZUFwaShzdXBlcmNsYXNzLCB2ZXJzaW9uLCBhcGlDb25maWcpIHtcbiAgICB2YXIgc3ZjID0gaW5oZXJpdChzdXBlcmNsYXNzLCB7XG4gICAgICBzZXJ2aWNlSWRlbnRpZmllcjogc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0QXBpKGFwaSkge1xuICAgICAgaWYgKGFwaS5pc0FwaSkge1xuICAgICAgICBzdmMucHJvdG90eXBlLmFwaSA9IGFwaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gbmV3IEFwaShhcGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChhcGlDb25maWcpIHtcbiAgICAgICAgc2V0QXBpKGFwaUNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEFwaShBV1MuYXBpTG9hZGVyKHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIsIHZlcnNpb24pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoZXJyLCB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGZpbmQgQVBJIGNvbmZpZ3VyYXRpb24gJyArXG4gICAgICAgICAgICAgIHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXIgKyAnLScgKyB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1cGVyY2xhc3Muc2VydmljZXMsIHZlcnNpb24pKSB7XG4gICAgICAgIHN1cGVyY2xhc3MuYXBpVmVyc2lvbnMgPSBzdXBlcmNsYXNzLmFwaVZlcnNpb25zLmNvbmNhdCh2ZXJzaW9uKS5zb3J0KCk7XG4gICAgICB9XG4gICAgICBzdXBlcmNsYXNzLnNlcnZpY2VzW3ZlcnNpb25dID0gc3ZjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRBcGkodmVyc2lvbik7XG4gICAgfVxuXG4gICAgQVdTLlNlcnZpY2UuZGVmaW5lTWV0aG9kcyhzdmMpO1xuICAgIHJldHVybiBzdmM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFzU2VydmljZTogZnVuY3Rpb24oaWRlbnRpZmllcikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQVdTLlNlcnZpY2UuX3NlcnZpY2VNYXAsIGlkZW50aWZpZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9zZXJ2aWNlTWFwOiB7fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNlcnZpY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZ19kYXRhLmpzb24nKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKSB7XG4gIGlmICghcmVnaW9uKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcGFydHMgPSByZWdpb24uc3BsaXQoJy0nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xuICByZXR1cm4gcGFydHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoIC0gMikuam9pbignLScpICsgJy0qJztcbn1cblxuZnVuY3Rpb24gZGVyaXZlZEtleXMoc2VydmljZSkge1xuICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICB2YXIgcmVnaW9uUHJlZml4ID0gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKTtcbiAgdmFyIGVuZHBvaW50UHJlZml4ID0gc2VydmljZS5hcGkuZW5kcG9pbnRQcmVmaXg7XG5cbiAgcmV0dXJuIFtcbiAgICBbcmVnaW9uLCBlbmRwb2ludFByZWZpeF0sXG4gICAgW3JlZ2lvblByZWZpeCwgZW5kcG9pbnRQcmVmaXhdLFxuICAgIFtyZWdpb24sICcqJ10sXG4gICAgW3JlZ2lvblByZWZpeCwgJyonXSxcbiAgICBbJyonLCBlbmRwb2ludFByZWZpeF0sXG4gICAgWycqJywgJyonXVxuICBdLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF0gJiYgaXRlbVsxXSA/IGl0ZW0uam9pbignLycpIDogbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29uZmlnKHNlcnZpY2UsIGNvbmZpZykge1xuICB1dGlsLmVhY2goY29uZmlnLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2dsb2JhbEVuZHBvaW50JykgcmV0dXJuO1xuICAgIGlmIChzZXJ2aWNlLmNvbmZpZ1trZXldID09PSB1bmRlZmluZWQgfHwgc2VydmljZS5jb25maWdba2V5XSA9PT0gbnVsbCkge1xuICAgICAgc2VydmljZS5jb25maWdba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUVuZHBvaW50KHNlcnZpY2UpIHtcbiAgdmFyIGtleXMgPSBkZXJpdmVkS2V5cyhzZXJ2aWNlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFrZXkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWdpb25Db25maWcucnVsZXMsIGtleSkpIHtcbiAgICAgIHZhciBjb25maWcgPSByZWdpb25Db25maWcucnVsZXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcgPSByZWdpb25Db25maWcucGF0dGVybnNbY29uZmlnXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGR1YWxzdGFjayBlbmRwb2ludFxuICAgICAgaWYgKHNlcnZpY2UuY29uZmlnLnVzZUR1YWxzdGFjayAmJiB1dGlsLmlzRHVhbHN0YWNrQXZhaWxhYmxlKHNlcnZpY2UpKSB7XG4gICAgICAgIGNvbmZpZyA9IHV0aWwuY29weShjb25maWcpO1xuICAgICAgICBjb25maWcuZW5kcG9pbnQgPSAne3NlcnZpY2V9LmR1YWxzdGFjay57cmVnaW9ufS5hbWF6b25hd3MuY29tJztcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGdsb2JhbCBlbmRwb2ludFxuICAgICAgc2VydmljZS5pc0dsb2JhbEVuZHBvaW50ID0gISFjb25maWcuZ2xvYmFsRW5kcG9pbnQ7XG5cbiAgICAgIC8vIHNpZ25hdHVyZSB2ZXJzaW9uXG4gICAgICBpZiAoIWNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9ICd2NCc7XG5cbiAgICAgIC8vIG1lcmdlIGNvbmZpZ1xuICAgICAgYXBwbHlDb25maWcoc2VydmljZSwgY29uZmlnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWd1cmVFbmRwb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbl9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wicnVsZXNcIjp7XCIqLypcIjp7XCJlbmRwb2ludFwiOlwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIn0sXCJjbi0qLypcIjp7XCJlbmRwb2ludFwiOlwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb20uY25cIn0sXCIqL2J1ZGdldHNcIjpcImdsb2JhbFNTTFwiLFwiKi9jbG91ZGZyb250XCI6XCJnbG9iYWxTU0xcIixcIiovaWFtXCI6XCJnbG9iYWxTU0xcIixcIiovc3RzXCI6XCJnbG9iYWxTU0xcIixcIiovaW1wb3J0ZXhwb3J0XCI6e1wiZW5kcG9pbnRcIjpcIntzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXCJzaWduYXR1cmVWZXJzaW9uXCI6XCJ2MlwiLFwiZ2xvYmFsRW5kcG9pbnRcIjp0cnVlfSxcIiovcm91dGU1M1wiOntcImVuZHBvaW50XCI6XCJodHRwczovL3tzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXCJzaWduYXR1cmVWZXJzaW9uXCI6XCJ2M2h0dHBzXCIsXCJnbG9iYWxFbmRwb2ludFwiOnRydWV9LFwiKi93YWZcIjpcImdsb2JhbFNTTFwiLFwidXMtZ292LSovaWFtXCI6XCJnbG9iYWxHb3ZDbG91ZFwiLFwidXMtZ292LSovc3RzXCI6e1wiZW5kcG9pbnRcIjpcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJ9LFwidXMtZ292LXdlc3QtMS9zM1wiOlwiczNkYXNoXCIsXCJ1cy13ZXN0LTEvczNcIjpcInMzZGFzaFwiLFwidXMtd2VzdC0yL3MzXCI6XCJzM2Rhc2hcIixcImV1LXdlc3QtMS9zM1wiOlwiczNkYXNoXCIsXCJhcC1zb3V0aGVhc3QtMS9zM1wiOlwiczNkYXNoXCIsXCJhcC1zb3V0aGVhc3QtMi9zM1wiOlwiczNkYXNoXCIsXCJhcC1ub3J0aGVhc3QtMS9zM1wiOlwiczNkYXNoXCIsXCJzYS1lYXN0LTEvczNcIjpcInMzZGFzaFwiLFwidXMtZWFzdC0xL3MzXCI6e1wiZW5kcG9pbnRcIjpcIntzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXCJzaWduYXR1cmVWZXJzaW9uXCI6XCJzM1wifSxcInVzLWVhc3QtMS9zZGJcIjp7XCJlbmRwb2ludFwiOlwie3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcInNpZ25hdHVyZVZlcnNpb25cIjpcInYyXCJ9LFwiKi9zZGJcIjp7XCJlbmRwb2ludFwiOlwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIixcInNpZ25hdHVyZVZlcnNpb25cIjpcInYyXCJ9fSxcInBhdHRlcm5zXCI6e1wiZ2xvYmFsU1NMXCI6e1wiZW5kcG9pbnRcIjpcImh0dHBzOi8ve3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcImdsb2JhbEVuZHBvaW50XCI6dHJ1ZX0sXCJnbG9iYWxHb3ZDbG91ZFwiOntcImVuZHBvaW50XCI6XCJ7c2VydmljZX0udXMtZ292LmFtYXpvbmF3cy5jb21cIn0sXCJzM2Rhc2hcIjp7XCJlbmRwb2ludFwiOlwie3NlcnZpY2V9LXtyZWdpb259LmFtYXpvbmF3cy5jb21cIixcInNpZ25hdHVyZVZlcnNpb25cIjpcInMzXCJ9fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnX2RhdGEuanNvblxuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluJyk7XG52YXIgUHJvbWlzZXNEZXBlbmRlbmN5O1xuXG4vKipcbiAqIFRoZSBtYWluIGNvbmZpZ3VyYXRpb24gY2xhc3MgdXNlZCBieSBhbGwgc2VydmljZSBvYmplY3RzIHRvIHNldFxuICogdGhlIHJlZ2lvbiwgY3JlZGVudGlhbHMsIGFuZCBvdGhlciBvcHRpb25zIGZvciByZXF1ZXN0cy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBjcmVkZW50aWFscyBhbmQgcmVnaW9uIHNldHRpbmdzIGFyZSBsZWZ0IHVuY29uZmlndXJlZC5cbiAqIFRoaXMgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGJlZm9yZSB1c2luZyBhbnlcbiAqIEFXUyBzZXJ2aWNlIEFQSXMuXG4gKlxuICogSW4gb3JkZXIgdG8gc2V0IGdsb2JhbCBjb25maWd1cmF0aW9uIG9wdGlvbnMsIHByb3BlcnRpZXMgc2hvdWxkXG4gKiBiZSBhc3NpZ25lZCB0byB0aGUgZ2xvYmFsIHtBV1MuY29uZmlnfSBvYmplY3QuXG4gKlxuICogQHNlZSBBV1MuY29uZmlnXG4gKlxuICogQCFncm91cCBHZW5lcmFsIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xuICpcbiAqIEAhYXR0cmlidXRlIGNyZWRlbnRpYWxzXG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gdGhlIEFXUyBjcmVkZW50aWFscyB0byBzaWduIHJlcXVlc3RzIHdpdGguXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVnaW9uXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgZ2xvYmFsIHJlZ2lvbiBzZXR0aW5nIHRvIHVzLXdlc3QtMlxuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZWdpb246ICd1cy13ZXN0LTInfSk7XG4gKiAgIEByZXR1cm4gW0FXUy5DcmVkZW50aWFsc10gVGhlIHJlZ2lvbiB0byBzZW5kIHNlcnZpY2UgcmVxdWVzdHMgdG8uXG4gKiAgIEBzZWUgaHR0cDovL2RvY3MuYW1hem9ud2Vic2VydmljZXMuY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3JhbmRlLmh0bWxcbiAqICAgICBBIGxpc3Qgb2YgYXZhaWxhYmxlIGVuZHBvaW50cyBmb3IgZWFjaCBBV1Mgc2VydmljZVxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJldHJpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJldHJpZXMgdG8gcGVyZm9ybSBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gQnkgZGVmYXVsdCB0aGlzIHZhbHVlIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIHNwZWNpZmljXG4gKiAgICAgc2VydmljZSBvYmplY3QgdGhhdCB0aGUgcmVxdWVzdCBpcyBiZWluZyBtYWRlIHRvLlxuICpcbiAqIEAhYXR0cmlidXRlIG1heFJlZGlyZWN0c1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmVkaXJlY3RzIHRvIGZvbGxvdyBmb3IgYVxuICogICAgIHNlcnZpY2UgcmVxdWVzdC4gRGVmYXVsdHMgdG8gMTAuXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1WYWxpZGF0aW9uXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlIHZhbGlkYXRlZCBhZ2FpbnN0XG4gKiAgICAgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZyB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBzcGVjaWZpYyB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICpcbiAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gKiAgICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAqICAgICAgIHRvIGB0cnVlYC5cbiAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gKiAgICAgICBjb25zdHJhaW50LlxuICogICAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiAgICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICogICAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBjb21wdXRlQ2hlY2tzdW1zXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29tcHV0ZSBjaGVja3N1bXMgZm9yIHBheWxvYWQgYm9kaWVzIHdoZW5cbiAqICAgICB0aGUgc2VydmljZSBhY2NlcHRzIGl0IChjdXJyZW50bHkgc3VwcG9ydGVkIGluIFMzIG9ubHkpLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvbnZlcnRSZXNwb25zZVR5cGVzXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdHlwZXMgYXJlIGNvbnZlcnRlZCB3aGVuIHBhcnNpbmcgcmVzcG9uc2UgZGF0YS5cbiAqICAgICBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgZm9yIEpTT04gYmFzZWQgc2VydmljZXMuIFR1cm5pbmcgdGhpcyBvZmYgbWF5XG4gKiAgICAgaW1wcm92ZSBwZXJmb3JtYW5jZSBvbiBsYXJnZSByZXNwb25zZSBwYXlsb2Fkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvcnJlY3RDbG9ja1NrZXdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBhcHBseSBhIGNsb2NrIHNrZXcgY29ycmVjdGlvbiBhbmQgcmV0cnlcbiAqICAgICByZXF1ZXN0cyB0aGF0IGZhaWwgYmVjYXVzZSBvZiBhbiBza2V3ZWQgY2xpZW50IGNsb2NrLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgc3NsRW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIFNTTCBpcyBlbmFibGVkIGZvciByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHMzRm9yY2VQYXRoU3R5bGVcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBmb3JjZSBwYXRoIHN0eWxlIFVSTHMgZm9yIFMzIG9iamVjdHNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM0J1Y2tldEVuZHBvaW50XG4gKiAgIEBub3RlIFNldHRpbmcgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiByZXF1aXJlcyBhbiBgZW5kcG9pbnRgIHRvIGJlXG4gKiAgICAgcHJvdmlkZWQgZXhwbGljaXRseSB0byB0aGUgc2VydmljZSBjb25zdHJ1Y3Rvci5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgcHJvdmlkZWQgZW5kcG9pbnQgYWRkcmVzc2VzIGFuIGluZGl2aWR1YWxcbiAqICAgICBidWNrZXQgKGZhbHNlIGlmIGl0IGFkZHJlc3NlcyB0aGUgcm9vdCBBUEkgZW5kcG9pbnQpLlxuICpcbiAqIEAhYXR0cmlidXRlIHMzRGlzYWJsZUJvZHlTaWduaW5nXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZGlzYWJsZSBTMyBib2R5IHNpZ25pbmcgd2hlbiB1c2luZyBzaWduYXR1cmUgdmVyc2lvbiBgdjRgLlxuICogICAgIEJvZHkgc2lnbmluZyBjYW4gb25seSBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIGh0dHBzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgdXNlQWNjZWxlcmF0ZUVuZHBvaW50XG4gKiAgIEBub3RlIFRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gaXMgb25seSBjb21wYXRpYmxlIHdpdGggUzMgd2hpbGUgYWNjZXNzaW5nXG4gKiAgICAgZG5zLWNvbXBhdGlibGUgYnVja2V0cy5cbiAqICAgQHJldHVybiBbQm9vbGVhbl0gV2hldGhlciB0byB1c2UgdGhlIEFjY2VsZXJhdGUgZW5kcG9pbnQgd2l0aCB0aGUgUzMgc2VydmljZS5cbiAqICAgICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICpcbiAqIEAhYXR0cmlidXRlIHJldHJ5RGVsYXlPcHRpb25zXG4gKiAgIEBleGFtcGxlIFNldCB0aGUgYmFzZSByZXRyeSBkZWxheSBmb3IgYWxsIHNlcnZpY2VzIHRvIDMwMCBtc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2Jhc2U6IDMwMH19KTtcbiAqICAgICAvLyBEZWxheXMgd2l0aCBtYXhSZXRyaWVzID0gMzogMzAwLCA2MDAsIDEyMDBcbiAqICAgQGV4YW1wbGUgU2V0IGEgY3VzdG9tIGJhY2tvZmYgZnVuY3Rpb24gdG8gcHJvdmlkZSBkZWxheSB2YWx1ZXMgb24gcmV0cmllc1xuICogICAgIEFXUy5jb25maWcudXBkYXRlKHtyZXRyeURlbGF5T3B0aW9uczoge2N1c3RvbUJhY2tvZmY6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICAgIC8vIHJldHVybnMgZGVsYXkgaW4gbXNcbiAqICAgICB9fX0pO1xuICogICBAcmV0dXJuIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLlxuICogICAgIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogICAgICogKipiYXNlKiogW0ludGVnZXJdICZtZGFzaDsgVGhlIGJhc2UgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW4gdGhlXG4gKiAgICAgICBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdHMgdG8gMTAwIG1zIGZvciBhbGwgc2VydmljZXMgZXhjZXB0XG4gKiAgICAgICBEeW5hbW9EQiwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gNTBtcy5cbiAqICAgICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcmV0cnkgY291bnRcbiAqICAgICAgIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpbiBtaWxsaXNlY29uZHMuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmVcbiAqICAgICAgIGlnbm9yZWQgaWYgdGhpcyBvcHRpb24gaXMgc3VwcGxpZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cE9wdGlvbnNcbiAqICAgQHJldHVybiBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbCBIVFRQIHJlcXVlc3QuXG4gKiAgICAgQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAgICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAqICAgICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gKiAgICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICogICAgICAgYWdlbnQgKGBodHRwLmdsb2JhbEFnZW50YCkgZm9yIG5vbi1TU0wgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBmb3JcbiAqICAgICAgIFNTTCBjb25uZWN0aW9ucywgYSBzcGVjaWFsIEFnZW50IG9iamVjdCBpcyB1c2VkIGluIG9yZGVyIHRvIGVuYWJsZVxuICogICAgICAgcGVlciBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24uIFRoaXMgZmVhdHVyZSBpcyBvbmx5IHN1cHBvcnRlZCBpbiB0aGVcbiAqICAgICAgIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKiAgICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuICogICAgICAgZ2l2aW5nIHVwIG9uIGEgY29ubmVjdGlvbiBhdHRlbXB0LiBEZWZhdWx0cyB0byB0d28gbWludXRlcyAoMTIwMDAwKS5cbiAqICAgICAqICoqeGhyQXN5bmMqKiBbQm9vbGVhbl0gJm1kYXNoOyBXaGV0aGVyIHRoZSBTREsgd2lsbCBzZW5kIGFzeW5jaHJvbm91c1xuICogICAgICAgSFRUUCByZXF1ZXN0cy4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvbmx5LiBTZXQgdG8gZmFsc2UgdG9cbiAqICAgICAgIHNlbmQgcmVxdWVzdHMgc3luY2hyb25vdXNseS4gRGVmYXVsdHMgdG8gdHJ1ZSAoYXN5bmMgb24pLlxuICogICAgICogKip4aHJXaXRoQ3JlZGVudGlhbHMqKiBbQm9vbGVhbl0gJm1kYXNoOyBTZXRzIHRoZSBcIndpdGhDcmVkZW50aWFsc1wiXG4gKiAgICAgICBwcm9wZXJ0eSBvZiBhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqICAgICAgIG9ubHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQCFhdHRyaWJ1dGUgbG9nZ2VyXG4gKiAgIEByZXR1cm4gWyN3cml0ZSwjbG9nXSBhbiBvYmplY3QgdGhhdCByZXNwb25kcyB0byAud3JpdGUoKSAobGlrZSBhIHN0cmVhbSlcbiAqICAgICBvciAubG9nKCkgKGxpa2UgdGhlIGNvbnNvbGUgb2JqZWN0KSBpbiBvcmRlciB0byBsb2cgaW5mb3JtYXRpb24gYWJvdXRcbiAqICAgICByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHN5c3RlbUNsb2NrT2Zmc2V0XG4gKiAgIEByZXR1cm4gW051bWJlcl0gYW4gb2Zmc2V0IHZhbHVlIGluIG1pbGxpc2Vjb25kcyB0byBhcHBseSB0byBhbGwgc2lnbmluZ1xuICogICAgIHRpbWVzLiBVc2UgdGhpcyB0byBjb21wZW5zYXRlIGZvciBjbG9jayBza2V3IHdoZW4geW91ciBzeXN0ZW0gbWF5IGJlXG4gKiAgICAgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmljZSB0aW1lLiBOb3RlIHRoYXQgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvblxuICogICAgIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGdsb2JhbCBgQVdTLmNvbmZpZ2Agb2JqZWN0IGFuZCBjYW5ub3QgYmVcbiAqICAgICBvdmVycmlkZGVuIGluIHNlcnZpY2Utc3BlY2lmaWMgY29uZmlndXJhdGlvbi4gRGVmYXVsdHMgdG8gMCBtaWxsaXNlY29uZHMuXG4gKlxuICogQCFhdHRyaWJ1dGUgc2lnbmF0dXJlVmVyc2lvblxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBzaWduYXR1cmUgdmVyc2lvbiB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiAndjInLCAndjMnLCAndjQnLlxuICpcbiAqIEAhYXR0cmlidXRlIHNpZ25hdHVyZUNhY2hlXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzIHRvIHRoZSBzaWduYXR1cmUgdmVyc2lvbiAndjQnLlxuICogICAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqL1xuQVdTLkNvbmZpZyA9IEFXUy51dGlsLmluaGVyaXQoe1xuICAvKipcbiAgICogQCFlbmRncm91cFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyB0aGUgb2JqZWN0IHRoYXQgcGFzc2VzXG4gICAqIG9wdGlvbiBkYXRhIGFsb25nIHRvIHNlcnZpY2UgcmVxdWVzdHMsIGluY2x1ZGluZyBjcmVkZW50aWFscywgc2VjdXJpdHksXG4gICAqIHJlZ2lvbiBpbmZvcm1hdGlvbiwgYW5kIHNvbWUgc2VydmljZSBzcGVjaWZpYyBzZXR0aW5ncy5cbiAgICpcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBjcmVkZW50aWFscyBhbmQgcmVnaW9uXG4gICAqICAgdmFyIGNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKHtcbiAgICogICAgIGFjY2Vzc0tleUlkOiAnQUtJRCcsIHNlY3JldEFjY2Vzc0tleTogJ1NFQ1JFVCcsIHJlZ2lvbjogJ3VzLXdlc3QtMidcbiAgICogICB9KTtcbiAgICogQG9wdGlvbiBvcHRpb25zIGFjY2Vzc0tleUlkIFtTdHJpbmddIHlvdXIgQVdTIGFjY2VzcyBrZXkgSUQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10geW91ciBBV1Mgc2VjcmV0IGFjY2VzcyBrZXkuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzZXNzaW9uVG9rZW4gW0FXUy5DcmVkZW50aWFsc10gdGhlIG9wdGlvbmFsIEFXU1xuICAgKiAgIHNlc3Npb24gdG9rZW4gdG8gc2lnbiByZXF1ZXN0cyB3aXRoLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC4gWW91IGNhbiBlaXRoZXIgc3BlY2lmeSB0aGlzIG9iamVjdCwgb3JcbiAgICogICBzcGVjaWZ5IHRoZSBhY2Nlc3NLZXlJZCBhbmQgc2VjcmV0QWNjZXNzS2V5IG9wdGlvbnMgZGlyZWN0bHkuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjcmVkZW50aWFsUHJvdmlkZXIgW0FXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbl0gdGhlXG4gICAqICAgcHJvdmlkZXIgY2hhaW4gdXNlZCB0byByZXNvbHZlIGNyZWRlbnRpYWxzIGlmIG5vIHN0YXRpYyBgY3JlZGVudGlhbHNgXG4gICAqICAgcHJvcGVydHkgaXMgc2V0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcmVnaW9uIFtTdHJpbmddIHRoZSByZWdpb24gdG8gc2VuZCBzZXJ2aWNlIHJlcXVlc3RzIHRvLlxuICAgKiAgIFNlZSB7cmVnaW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIG1heFJldHJpZXMgW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZXRyaWVzIHRvXG4gICAqICAgYXR0ZW1wdCB3aXRoIGEgcmVxdWVzdC4gU2VlIHttYXhSZXRyaWVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIG1heFJlZGlyZWN0cyBbSW50ZWdlcl0gdGhlIG1heGltdW0gYW1vdW50IG9mIHJlZGlyZWN0cyB0b1xuICAgKiAgIGZvbGxvdyB3aXRoIGEgcmVxdWVzdC4gU2VlIHttYXhSZWRpcmVjdHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc3NsRW5hYmxlZCBbQm9vbGVhbl0gd2hldGhlciB0byBlbmFibGUgU1NMIGZvclxuICAgKiAgIHJlcXVlc3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFyYW1WYWxpZGF0aW9uIFtCb29sZWFufG1hcF0gd2hldGhlciBpbnB1dCBwYXJhbWV0ZXJzXG4gICAqICAgc2hvdWxkIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvcGVyYXRpb24gZGVzY3JpcHRpb24gYmVmb3JlIHNlbmRpbmdcbiAgICogICB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gdHJ1ZS4gUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZVxuICAgKiAgIGZvbGxvd2luZyBzcGVjaWZpYyB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICAgKlxuICAgKiAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAgICogICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICAgKiAgICAgdG8gYHRydWVgLlxuICAgKiAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAgICogICAgIGNvbnN0cmFpbnQuXG4gICAqICAgKiAqKnBhdHRlcm4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGFcbiAgICogICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICogICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gICAqICAgICBvZiB0aGUgYWxsb3dhYmxlIGVudW0gdmFsdWVzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29tcHV0ZUNoZWNrc3VtcyBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3Vtc1xuICAgKiAgIGZvciBwYXlsb2FkIGJvZGllcyB3aGVuIHRoZSBzZXJ2aWNlIGFjY2VwdHMgaXQgKGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgICogICBpbiBTMyBvbmx5KVxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29udmVydFJlc3BvbnNlVHlwZXMgW0Jvb2xlYW5dIHdoZXRoZXIgdHlwZXMgYXJlIGNvbnZlcnRlZFxuICAgKiAgICAgd2hlbiBwYXJzaW5nIHJlc3BvbnNlIGRhdGEuIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBmb3IgSlNPTiBiYXNlZFxuICAgKiAgICAgc2VydmljZXMuIFR1cm5pbmcgdGhpcyBvZmYgbWF5IGltcHJvdmUgcGVyZm9ybWFuY2Ugb24gbGFyZ2UgcmVzcG9uc2VcbiAgICogICAgIHBheWxvYWRzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBjb3JyZWN0Q2xvY2tTa2V3IFtCb29sZWFuXSB3aGV0aGVyIHRvIGFwcGx5IGEgY2xvY2sgc2tld1xuICAgKiAgICAgY29ycmVjdGlvbiBhbmQgcmV0cnkgcmVxdWVzdHMgdGhhdCBmYWlsIGJlY2F1c2Ugb2YgYW4gc2tld2VkIGNsaWVudFxuICAgKiAgICAgY2xvY2suIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0ZvcmNlUGF0aFN0eWxlIFtCb29sZWFuXSB3aGV0aGVyIHRvIGZvcmNlIHBhdGhcbiAgICogICBzdHlsZSBVUkxzIGZvciBTMyBvYmplY3RzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNCdWNrZXRFbmRwb2ludCBbQm9vbGVhbl0gd2hldGhlciB0aGUgcHJvdmlkZWQgZW5kcG9pbnRcbiAgICogICBhZGRyZXNzZXMgYW4gaW5kaXZpZHVhbCBidWNrZXQgKGZhbHNlIGlmIGl0IGFkZHJlc3NlcyB0aGUgcm9vdCBBUElcbiAgICogICBlbmRwb2ludCkuIE5vdGUgdGhhdCBzZXR0aW5nIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gcmVxdWlyZXMgYW5cbiAgICogICBgZW5kcG9pbnRgIHRvIGJlIHByb3ZpZGVkIGV4cGxpY2l0bHkgdG8gdGhlIHNlcnZpY2UgY29uc3RydWN0b3IuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzM0Rpc2FibGVCb2R5U2lnbmluZyBbQm9vbGVhbl0gd2hldGhlciBTMyBib2R5IHNpZ25pbmdcbiAgICogICBzaG91bGQgYmUgZGlzYWJsZWQgd2hlbiB1c2luZyBzaWduYXR1cmUgdmVyc2lvbiBgdjRgLiBCb2R5IHNpZ25pbmdcbiAgICogICBjYW4gb25seSBiZSBkaXNhYmxlZCB3aGVuIHVzaW5nIGh0dHBzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqXG4gICAqIEBvcHRpb24gb3B0aW9ucyByZXRyeURlbGF5T3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZVxuICAgKiAgIHRoZSByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgICogKipiYXNlKiogW0ludGVnZXJdICZtZGFzaDsgVGhlIGJhc2UgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW4gdGhlXG4gICAqICAgICBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdHMgdG8gMTAwIG1zIGZvciBhbGxcbiAgICogICAgIHNlcnZpY2VzIGV4Y2VwdCBEeW5hbW9EQiwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gNTBtcy5cbiAgICogICAqICoqY3VzdG9tQmFja29mZiAqKiBbZnVuY3Rpb25dICZtZGFzaDsgQSBjdXN0b20gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcmV0cnkgY291bnRcbiAgICogICAgIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpbiBtaWxsaXNlY29uZHMuIFRoZSBgYmFzZWAgb3B0aW9uIHdpbGwgYmVcbiAgICogICAgIGlnbm9yZWQgaWYgdGhpcyBvcHRpb24gaXMgc3VwcGxpZWQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBodHRwT3B0aW9ucyBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbFxuICAgKiAgIEhUVFAgcmVxdWVzdC4gQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICAqICoqcHJveHkqKiBbU3RyaW5nXSAmbWRhc2g7IHRoZSBVUkwgdG8gcHJveHkgcmVxdWVzdHMgdGhyb3VnaFxuICAgKiAgICogKiphZ2VudCoqIFtodHRwLkFnZW50LCBodHRwcy5BZ2VudF0gJm1kYXNoOyB0aGUgQWdlbnQgb2JqZWN0IHRvIHBlcmZvcm1cbiAgICogICAgIEhUVFAgcmVxdWVzdHMgd2l0aC4gVXNlZCBmb3IgY29ubmVjdGlvbiBwb29saW5nLiBEZWZhdWx0cyB0byB0aGUgZ2xvYmFsXG4gICAqICAgICBhZ2VudCAoYGh0dHAuZ2xvYmFsQWdlbnRgKSBmb3Igbm9uLVNTTCBjb25uZWN0aW9ucy4gTm90ZSB0aGF0IGZvclxuICAgKiAgICAgU1NMIGNvbm5lY3Rpb25zLCBhIHNwZWNpYWwgQWdlbnQgb2JqZWN0IGlzIHVzZWQgaW4gb3JkZXIgdG8gZW5hYmxlXG4gICAqICAgICBwZWVyIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBmZWF0dXJlIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZVxuICAgKiAgICAgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAgICogICAqICoqY29ubmVjdFRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlclxuICAgKiAgICAgZmFpbGluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlciBhZnRlclxuICAgKiAgICAgYGNvbm5lY3RUaW1lb3V0YCBtaWxsaXNlY29uZHMuIFRoaXMgdGltZW91dCBoYXMgbm8gZWZmZWN0IG9uY2UgYSBzb2NrZXRcbiAgICogICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gICAqICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0XG4gICAqICAgICBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LiBEZWZhdWx0cyB0byB0d28gbWludXRlc1xuICAgKiAgICAgKDEyMDAwMCkuXG4gICAqICAgKiAqKnhockFzeW5jKiogW0Jvb2xlYW5dICZtZGFzaDsgV2hldGhlciB0aGUgU0RLIHdpbGwgc2VuZCBhc3luY2hyb25vdXNcbiAgICogICAgIEhUVFAgcmVxdWVzdHMuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb25seS4gU2V0IHRvIGZhbHNlIHRvXG4gICAqICAgICBzZW5kIHJlcXVlc3RzIHN5bmNocm9ub3VzbHkuIERlZmF1bHRzIHRvIHRydWUgKGFzeW5jIG9uKS5cbiAgICogICAqICoqeGhyV2l0aENyZWRlbnRpYWxzKiogW0Jvb2xlYW5dICZtZGFzaDsgU2V0cyB0aGUgXCJ3aXRoQ3JlZGVudGlhbHNcIlxuICAgKiAgICAgcHJvcGVydHkgb2YgYW4gWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50XG4gICAqICAgICBvbmx5LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGFwaVZlcnNpb24gW1N0cmluZywgRGF0ZV0gYSBTdHJpbmcgaW4gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICogICAob3IgYSBkYXRlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGxhdGVzdCBwb3NzaWJsZSBBUEkgdmVyc2lvbiB0aGF0IGNhbiBiZVxuICAgKiAgIHVzZWQgaW4gYWxsIHNlcnZpY2VzICh1bmxlc3Mgb3ZlcnJpZGRlbiBieSBgYXBpVmVyc2lvbnNgKS4gU3BlY2lmeVxuICAgKiAgICdsYXRlc3QnIHRvIHVzZSB0aGUgbGF0ZXN0IHBvc3NpYmxlIHZlcnNpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBhcGlWZXJzaW9ucyBbbWFwPFN0cmluZywgU3RyaW5nfERhdGU+XSBhIG1hcCBvZiBzZXJ2aWNlXG4gICAqICAgaWRlbnRpZmllcnMgKHRoZSBsb3dlcmNhc2Ugc2VydmljZSBjbGFzcyBuYW1lKSB3aXRoIHRoZSBBUEkgdmVyc2lvbiB0b1xuICAgKiAgIHVzZSB3aGVuIGluc3RhbnRpYXRpbmcgYSBzZXJ2aWNlLiBTcGVjaWZ5ICdsYXRlc3QnIGZvciBlYWNoIGluZGl2aWR1YWxcbiAgICogICB0aGF0IGNhbiB1c2UgdGhlIGxhdGVzdCBhdmFpbGFibGUgdmVyc2lvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIGxvZ2dlciBbI3dyaXRlLCNsb2ddIGFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC53cml0ZSgpXG4gICAqICAgKGxpa2UgYSBzdHJlYW0pIG9yIC5sb2coKSAobGlrZSB0aGUgY29uc29sZSBvYmplY3QpIGluIG9yZGVyIHRvIGxvZ1xuICAgKiAgIGluZm9ybWF0aW9uIGFib3V0IHJlcXVlc3RzXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzeXN0ZW1DbG9ja09mZnNldCBbTnVtYmVyXSBhbiBvZmZzZXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqICAgdG8gYXBwbHkgdG8gYWxsIHNpZ25pbmcgdGltZXMuIFVzZSB0aGlzIHRvIGNvbXBlbnNhdGUgZm9yIGNsb2NrIHNrZXdcbiAgICogICB3aGVuIHlvdXIgc3lzdGVtIG1heSBiZSBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2aWNlIHRpbWUuIE5vdGUgdGhhdFxuICAgKiAgIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZ2xvYmFsIGBBV1MuY29uZmlnYFxuICAgKiAgIG9iamVjdCBhbmQgY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gc2VydmljZS1zcGVjaWZpYyBjb25maWd1cmF0aW9uLlxuICAgKiAgIERlZmF1bHRzIHRvIDAgbWlsbGlzZWNvbmRzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlVmVyc2lvbiBbU3RyaW5nXSB0aGUgc2lnbmF0dXJlIHZlcnNpb24gdG8gc2lnblxuICAgKiAgIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmcgdGhlIEFQSSBjb25maWd1cmF0aW9uKS4gUG9zc2libGUgdmFsdWVzIGFyZTpcbiAgICogICAndjInLCAndjMnLCAndjQnLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2lnbmF0dXJlQ2FjaGUgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduXG4gICAqICAgcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzXG4gICAqICAgdG8gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uICd2NCcuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGR5bmFtb0RiQ3JjMzIgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIENSQzMyXG4gICAqICAgY2hlY2tzdW0gb2YgSFRUUCByZXNwb25zZSBib2RpZXMgcmV0dXJuZWQgYnkgRHluYW1vREIuIERlZmF1bHQ6IGB0cnVlYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDb25maWcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcbiAgICBvcHRpb25zID0gdGhpcy5leHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucyk7XG5cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBvcHRpb25zW2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBNYW5hZ2luZyBDcmVkZW50aWFsc1xuICAgKi9cblxuICAvKipcbiAgICogTG9hZHMgY3JlZGVudGlhbHMgZnJvbSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5XG4gICAqIGJ5IHRoZSBTREsgdG8gZW5zdXJlIHRoYXQgcmVmcmVzaGFibGUge0NyZWRlbnRpYWxzfSBvYmplY3RzIGFyZSBwcm9wZXJseVxuICAgKiByZWZyZXNoZWQgYW5kIGxvYWRlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJZiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdFxuICAgKiB5b3VyIGNyZWRlbnRpYWxzIGFyZSBsb2FkZWQgcHJpb3IgdG8gYSByZXF1ZXN0LCB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZFxuICAgKiBkaXJlY3RseSB0byBwcm92aWRlIGFjY3VyYXRlIGNyZWRlbnRpYWwgZGF0YSBzdG9yZWQgaW4gdGhlIG9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgSWYgeW91IGNvbmZpZ3VyZSB0aGUgU0RLIHdpdGggc3RhdGljIG9yIGVudmlyb25tZW50IGNyZWRlbnRpYWxzLFxuICAgKiAgIHRoZSBjcmVkZW50aWFsIGRhdGEgc2hvdWxkIGFscmVhZHkgYmUgcHJlc2VudCBpbiB7Y3JlZGVudGlhbHN9IGF0dHJpYnV0ZS5cbiAgICogICBUaGlzIG1ldGhvZCBpcyBwcmltYXJpbHkgbmVjZXNzYXJ5IHRvIGxvYWQgY3JlZGVudGlhbHMgZnJvbSBhc3luY2hyb25vdXNcbiAgICogICBzb3VyY2VzLCBvciBzb3VyY2VzIHRoYXQgY2FuIHJlZnJlc2ggY3JlZGVudGlhbHMgcGVyaW9kaWNhbGx5LlxuICAgKiBAZXhhbXBsZSBHZXR0aW5nIHlvdXIgYWNjZXNzIGtleVxuICAgKiAgIEFXUy5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhlcnIuc3RhY2spOyAvLyBjcmVkZW50aWFscyBub3QgbG9hZGVkXG4gICAqICAgICBlbHNlIGNvbnNvbGUubG9nKFwiQWNjZXNzIEtleTpcIiwgQVdTLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCk7XG4gICAqICAgfSlcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUge2NyZWRlbnRpYWxzfSBoYXZlIGJlZW4gcHJvcGVybHkgc2V0IG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAqICAgb2JqZWN0LlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiB0aGlzIGlzIHNldCwgY3JlZGVudGlhbHMgd2VyZSBub3Qgc3VjY2Vzc2Z1bGx5XG4gICAqICAgICBsb2FkZWQgYW5kIHRoaXMgZXJyb3IgcHJvdmlkZXMgaW5mb3JtYXRpb24gd2h5LlxuICAgKiBAc2VlIGNyZWRlbnRpYWxzXG4gICAqIEBzZWUgQ3JlZGVudGlhbHNcbiAgICovXG4gIGdldENyZWRlbnRpYWxzOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFscyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgZXJyID8gbnVsbCA6IHNlbGYuY3JlZGVudGlhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWRFcnJvcihtc2csIGVycikge1xuICAgICAgcmV0dXJuIG5ldyBBV1MudXRpbC5lcnJvcihlcnIgfHwgbmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0NyZWRlbnRpYWxzRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG5hbWU6ICdDcmVkZW50aWFsc0Vycm9yJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXN5bmNDcmVkZW50aWFscygpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbHMuZ2V0KGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tICcgK1xuICAgICAgICAgICAgc2VsZi5jcmVkZW50aWFscy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgIGVyciA9IGNyZWRFcnJvcihtc2csIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNDcmVkZW50aWFscygpIHtcbiAgICAgIHZhciBlcnIgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkIHx8ICFzZWxmLmNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgICBlcnIgPSBjcmVkRXJyb3IoJ01pc3NpbmcgY3JlZGVudGlhbHMnKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaChlcnIpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmNyZWRlbnRpYWxzKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3JlZGVudGlhbHMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdldEFzeW5jQ3JlZGVudGlhbHMoKTtcbiAgICAgIH0gZWxzZSB7IC8vIHN0YXRpYyBjcmVkZW50aWFsc1xuICAgICAgICBnZXRTdGF0aWNDcmVkZW50aWFscygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZi5jcmVkZW50aWFsUHJvdmlkZXIpIHtcbiAgICAgIHNlbGYuY3JlZGVudGlhbFByb3ZpZGVyLnJlc29sdmUoZnVuY3Rpb24oZXJyLCBjcmVkcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyID0gY3JlZEVycm9yKCdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tIGFueSBwcm92aWRlcnMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKGNyZWRFcnJvcignTm8gY3JlZGVudGlhbHMgdG8gbG9hZCcpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgTG9hZGluZyBhbmQgU2V0dGluZyBDb25maWd1cmF0aW9uIE9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCB1cGRhdGUob3B0aW9ucywgYWxsb3dVbmtub3duS2V5cyA9IGZhbHNlKVxuICAgKiAgIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICpcbiAgICogICBAZXhhbXBsZSBVcGRhdGUgbWF4UmV0cmllcyBwcm9wZXJ0eSBvZiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqICAgICBjb25maWcudXBkYXRlKHttYXhSZXRyaWVzOiAxMH0pO1xuICAgKiAgIEBwYXJhbSBbT2JqZWN0XSBvcHRpb25zIGEgbWFwIG9mIG9wdGlvbiBrZXlzIGFuZCB2YWx1ZXMuXG4gICAqICAgQHBhcmFtIFtCb29sZWFuXSBhbGxvd1Vua25vd25LZXlzIHdoZXRoZXIgdW5rbm93biBrZXlzIGNhbiBiZSBzZXQgb25cbiAgICogICAgIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogICBAc2VlIGNvbnN0cnVjdG9yXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvcHRpb25zLCBhbGxvd1Vua25vd25LZXlzKSB7XG4gICAgYWxsb3dVbmtub3duS2V5cyA9IGFsbG93VW5rbm93bktleXMgfHwgZmFsc2U7XG4gICAgb3B0aW9ucyA9IHRoaXMuZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGFsbG93VW5rbm93bktleXMgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMua2V5cywga2V5KSB8fFxuICAgICAgICAgIEFXUy5TZXJ2aWNlLmhhc1NlcnZpY2Uoa2V5KSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTG9hZHMgY29uZmlndXJhdGlvbiBkYXRhIGZyb20gYSBKU09OIGZpbGUgaW50byB0aGlzIGNvbmZpZyBvYmplY3QuXG4gICAqIEBub3RlIExvYWRpbmcgY29uZmlndXJhdGlvbiB3aWxsIHJlc2V0IGFsbCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqICAgb24gdGhlIG9iamVjdC5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICogQHBhcmFtIHBhdGggW1N0cmluZ10gdGhlIHBhdGggcmVsYXRpdmUgdG8geW91ciBwcm9jZXNzJ3MgY3VycmVudFxuICAgKiAgICB3b3JraW5nIGRpcmVjdG9yeSB0byBsb2FkIGNvbmZpZ3VyYXRpb24gZnJvbS5cbiAgICogQHJldHVybiBbQVdTLkNvbmZpZ10gdGhlIHNhbWUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGxvYWRGcm9tUGF0aDogZnVuY3Rpb24gbG9hZEZyb21QYXRoKHBhdGgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IEpTT04ucGFyc2UoQVdTLnV0aWwucmVhZEZpbGVTeW5jKHBhdGgpKTtcbiAgICB2YXIgZmlsZVN5c3RlbUNyZWRzID0gbmV3IEFXUy5GaWxlU3lzdGVtQ3JlZGVudGlhbHMocGF0aCk7XG4gICAgdmFyIGNoYWluID0gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbigpO1xuICAgIGNoYWluLnByb3ZpZGVycy51bnNoaWZ0KGZpbGVTeXN0ZW1DcmVkcyk7XG4gICAgY2hhaW4ucmVzb2x2ZShmdW5jdGlvbiAoZXJyLCBjcmVkcykge1xuICAgICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICAgICAgZWxzZSBvcHRpb25zLmNyZWRlbnRpYWxzID0gY3JlZHM7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBjb25maWd1cmF0aW9uIGRhdGEgb24gdGhpcyBvYmplY3RcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5rZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH0pO1xuXG4gICAgLy8gcmVzZXQgY3JlZGVudGlhbCBwcm92aWRlclxuICAgIHRoaXMuc2V0KCdjcmVkZW50aWFscycsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zZXQoJ2NyZWRlbnRpYWxQcm92aWRlcicsIHVuZGVmaW5lZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9wZXJ0eSBvbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QsIGFsbG93aW5nIGZvciBhXG4gICAqIGRlZmF1bHQgdmFsdWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIHNldChwcm9wZXJ0eSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpcy5rZXlzW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnaHR0cE9wdGlvbnMnICYmIHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAvLyBkZWVwIG1lcmdlIGh0dHBPcHRpb25zXG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IEFXUy51dGlsLm1lcmdlKHRoaXNbcHJvcGVydHldLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGtleXMgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQGNvbnN0YW50XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAga2V5czoge1xuICAgIGNyZWRlbnRpYWxzOiBudWxsLFxuICAgIGNyZWRlbnRpYWxQcm92aWRlcjogbnVsbCxcbiAgICByZWdpb246IG51bGwsXG4gICAgbG9nZ2VyOiBudWxsLFxuICAgIGFwaVZlcnNpb25zOiB7fSxcbiAgICBhcGlWZXJzaW9uOiBudWxsLFxuICAgIGVuZHBvaW50OiB1bmRlZmluZWQsXG4gICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgIHRpbWVvdXQ6IDEyMDAwMFxuICAgIH0sXG4gICAgbWF4UmV0cmllczogdW5kZWZpbmVkLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgcGFyYW1WYWxpZGF0aW9uOiB0cnVlLFxuICAgIHNzbEVuYWJsZWQ6IHRydWUsXG4gICAgczNGb3JjZVBhdGhTdHlsZTogZmFsc2UsXG4gICAgczNCdWNrZXRFbmRwb2ludDogZmFsc2UsXG4gICAgczNEaXNhYmxlQm9keVNpZ25pbmc6IHRydWUsXG4gICAgY29tcHV0ZUNoZWNrc3VtczogdHJ1ZSxcbiAgICBjb252ZXJ0UmVzcG9uc2VUeXBlczogdHJ1ZSxcbiAgICBjb3JyZWN0Q2xvY2tTa2V3OiBmYWxzZSxcbiAgICBjdXN0b21Vc2VyQWdlbnQ6IG51bGwsXG4gICAgZHluYW1vRGJDcmMzMjogdHJ1ZSxcbiAgICBzeXN0ZW1DbG9ja09mZnNldDogMCxcbiAgICBzaWduYXR1cmVWZXJzaW9uOiBudWxsLFxuICAgIHNpZ25hdHVyZUNhY2hlOiB0cnVlLFxuICAgIHJldHJ5RGVsYXlPcHRpb25zOiB7fSxcbiAgICB1c2VBY2NlbGVyYXRlRW5kcG9pbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXkgYW5kIHNlc3Npb25Ub2tlblxuICAgKiBmcm9tIGEgY29uZmlndXJhdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RDcmVkZW50aWFsczogZnVuY3Rpb24gZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NLZXlJZCAmJiBvcHRpb25zLnNlY3JldEFjY2Vzc0tleSkge1xuICAgICAgb3B0aW9ucyA9IEFXUy51dGlsLmNvcHkob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DcmVkZW50aWFscyhvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb21pc2UgZGVwZW5kZW5jeSB0aGUgU0RLIHdpbGwgdXNlIHdoZXJldmVyIFByb21pc2VzIGFyZSByZXR1cm5lZC5cbiAgICogUGFzc2luZyBgbnVsbGAgd2lsbCBmb3JjZSB0aGUgU0RLIHRvIHVzZSBuYXRpdmUgUHJvbWlzZXMgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxuICAgKiBJZiBuYXRpdmUgUHJvbWlzZXMgYXJlIG5vdCBhdmFpbGFibGUsIHBhc3NpbmcgYG51bGxgIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqIEBwYXJhbSBbQ29uc3RydWN0b3JdIGRlcCBBIHJlZmVyZW5jZSB0byBhIFByb21pc2UgY29uc3RydWN0b3JcbiAgICovXG4gIHNldFByb21pc2VzRGVwZW5kZW5jeTogZnVuY3Rpb24gc2V0UHJvbWlzZXNEZXBlbmRlbmN5KGRlcCkge1xuICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IGRlcDtcbiAgICAvLyBpZiBudWxsIHdhcyBwYXNzZWQgaW4sIHdlIHNob3VsZCB0cnkgdG8gdXNlIG5hdGl2ZSBwcm9taXNlc1xuICAgIGlmIChkZXAgPT09IG51bGwgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFByb21pc2VzRGVwZW5kZW5jeSA9IFByb21pc2U7XG4gICAgfVxuICAgIHZhciBjb25zdHJ1Y3RvcnMgPSBbQVdTLlJlcXVlc3QsIEFXUy5DcmVkZW50aWFscywgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXTtcbiAgICBpZiAoQVdTLlMzICYmIEFXUy5TMy5NYW5hZ2VkVXBsb2FkKSBjb25zdHJ1Y3RvcnMucHVzaChBV1MuUzMuTWFuYWdlZFVwbG9hZCk7XG4gICAgQVdTLnV0aWwuYWRkUHJvbWlzZXMoY29uc3RydWN0b3JzLCBQcm9taXNlc0RlcGVuZGVuY3kpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgc2V0IGJ5IGBBV1MuY29uZmlnLnNldFByb21pc2VzRGVwZW5kZW5jeWAuXG4gICAqL1xuICBnZXRQcm9taXNlc0RlcGVuZGVuY3k6IGZ1bmN0aW9uIGdldFByb21pc2VzRGVwZW5kZW5jeSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZXNEZXBlbmRlbmN5O1xuICB9XG59KTtcblxuLyoqXG4gKiBAcmV0dXJuIFtBV1MuQ29uZmlnXSBUaGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHNpbmdsZXRvbiBpbnN0YW5jZVxuICogQHJlYWRvbmx5XG4gKiBAc2VlIEFXUy5Db25maWdcbiAqL1xuQVdTLmNvbmZpZyA9IG5ldyBBV1MuQ29uZmlnKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBTZXF1ZW50aWFsRXhlY3V0b3IgPSByZXF1aXJlKCcuL3NlcXVlbnRpYWxfZXhlY3V0b3InKTtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSB1c2VkIHRvIHJlZ2lzdGVyIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgZm9yIHJlcXVlc3QgYnVpbGRpbmdcbiAqIGFuZCBzZW5kaW5nLlxuICovXG5BV1MuRXZlbnRMaXN0ZW5lcnMgPSB7XG4gIC8qKlxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9DUkVERU5USUFMU1xuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIGJlaW5nXG4gICAqICAgc2VudCB3aXRoIGNyZWRlbnRpYWxzLlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMUztcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9SRUdJT05cbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgd2hldGhlciB0aGUgcmVnaW9uIGlzIHNldFxuICAgKiAgIGZvciBhIHJlcXVlc3QuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgcmVnaW9uIGNvbmZpZ3VyYXRpb25cbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTjtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9QQVJBTUVURVJTXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIGlucHV0IHBhcmFtZXRlcnMgaW4gYSByZXF1ZXN0LlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIHBhcmFtZXRlcnNcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1BBUkFNRVRFUlM7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAZXhhbXBsZSBEaXNhYmxlIHBhcmFtZXRlciB2YWxpZGF0aW9uIGdsb2JhbGx5XG4gICAqICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgKiAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT04pO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBTRU5EXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgaW5pdGlhdGVzIHRoZSBIVFRQIGNvbm5lY3Rpb24gZm9yIGFcbiAgICogICByZXF1ZXN0IGJlaW5nIHNlbnQuIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH5zZW5kICdzZW5kJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFJlcGxhY2luZyB0aGUgSFRUUCBoYW5kbGVyXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRU5EO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignc2VuZCcsIGxpc3RlbmVyKTtcbiAgICogICAgIHJlcXVlc3Qub24oJ3NlbmQnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgKiAgICAgICBjdXN0b21IYW5kbGVyLnNlbmQocmVzcG9uc2UpO1xuICAgKiAgICAgfSk7XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqICAgQHJlYWRvbmx5XG4gICAqIEAhYXR0cmlidXRlIEhUVFBfREFUQVxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHJlYWRzIGRhdGEgZnJvbSB0aGUgSFRUUCBjb25uZWN0aW9uIGluIG9yZGVyXG4gICAqICAgdG8gYnVpbGQgdGhlIHJlc3BvbnNlIGRhdGEuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fmh0dHBEYXRhICdodHRwRGF0YScgUmVxdWVzdCBldmVudH0uXG4gICAqICAgUmVtb3ZlIHRoaXMgaGFuZGxlciBpZiB5b3UgYXJlIG92ZXJyaWRpbmcgdGhlICdodHRwRGF0YScgZXZlbnQgYW5kXG4gICAqICAgZG8gbm90IHdhbnQgZXh0cmEgZGF0YSBwcm9jZXNzaW5nIGFuZCBidWZmZXJpbmcgb3ZlcmhlYWQuXG4gICAqICAgQGV4YW1wbGUgRGlzYWJsaW5nIGRlZmF1bHQgZGF0YSBwcm9jZXNzaW5nXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0RBVEE7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdodHRwRGF0YScsIGxpc3RlbmVyKTtcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogICBAcmVhZG9ubHlcbiAgICovXG4gIENvcmU6IHt9IC8qIGRvYyBoYWNrICovXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRPcGVyYXRpb25BdXRodHlwZShyZXEpIHtcbiAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHJldHVybiBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbn1cblxuQVdTLkV2ZW50TGlzdGVuZXJzID0ge1xuICBDb3JlOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkLCBhZGRBc3luYykge1xuICAgIGFkZEFzeW5jKCdWQUxJREFURV9DUkVERU5USUFMUycsICd2YWxpZGF0ZScsXG4gICAgICAgIGZ1bmN0aW9uIFZBTElEQVRFX0NSRURFTlRJQUxTKHJlcSwgZG9uZSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgcmVxLnNlcnZpY2UuY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IoZXJyLFxuICAgICAgICAgICAge2NvZGU6ICdDcmVkZW50aWFsc0Vycm9yJywgbWVzc2FnZTogJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnJ30pO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWRkKCdWQUxJREFURV9SRUdJT04nLCAndmFsaWRhdGUnLCBmdW5jdGlvbiBWQUxJREFURV9SRUdJT04ocmVxKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb24gJiYgIXJlcS5zZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnQpIHtcbiAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6ICdNaXNzaW5nIHJlZ2lvbiBpbiBjb25maWcnfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0JVSUxEX0lERU1QT1RFTkNZX1RPS0VOUycsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIEJVSUxEX0lERU1QT1RFTkNZX1RPS0VOUyhyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICAgICAgaWYgKCFvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlkZW1wb3RlbnRNZW1iZXJzID0gb3BlcmF0aW9uLmlkZW1wb3RlbnRNZW1iZXJzO1xuICAgICAgaWYgKCFpZGVtcG90ZW50TWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlcyBhIGNvcHkgb2YgcGFyYW1zIHNvIHVzZXIncyBwYXJhbSBvYmplY3QgaXNuJ3QgbXV0YXRlZFxuICAgICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocmVxLnBhcmFtcyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGlkZW1wb3RlbnRNZW1iZXJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICBpZiAoIXBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0pIHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG1lbWJlclxuICAgICAgICAgIHBhcmFtc1tpZGVtcG90ZW50TWVtYmVyc1tpXV0gPSBBV1MudXRpbC51dWlkLnY0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ1ZBTElEQVRFX1BBUkFNRVRFUlMnLCAndmFsaWRhdGUnLCBmdW5jdGlvbiBWQUxJREFURV9QQVJBTUVURVJTKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gcmVxLnNlcnZpY2UuY29uZmlnLnBhcmFtVmFsaWRhdGlvbjtcbiAgICAgIG5ldyBBV1MuUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikudmFsaWRhdGUocnVsZXMsIHJlcS5wYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ0NPTVBVVEVfU0hBMjU2JywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBDT01QVVRFX1NIQTI1NihyZXEsIGRvbmUpIHtcbiAgICAgIHJlcS5oYWx0SGFuZGxlcnNPbkVycm9yKCk7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIHZhciBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbiAmJiAhYXV0aHR5cGUpIHJldHVybiBkb25lKCk7IC8vIG5vbmVcbiAgICAgIGlmIChyZXEuc2VydmljZS5nZXRTaWduZXJDbGFzcyhyZXEpID09PSBBV1MuU2lnbmVycy5WNCkge1xuICAgICAgICB2YXIgYm9keSA9IHJlcS5odHRwUmVxdWVzdC5ib2R5IHx8ICcnO1xuICAgICAgICBpZiAoYXV0aHR5cGUuaW5kZXhPZigndW5zaWduZWQtYm9keScpID49IDApIHtcbiAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9ICdVTlNJR05FRC1QQVlMT0FEJztcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIEFXUy51dGlsLmNvbXB1dGVTaGEyNTYoYm9keSwgZnVuY3Rpb24oZXJyLCBzaGEpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gPSBzaGE7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnU0VUX0NPTlRFTlRfTEVOR1RIJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBTRVRfQ09OVEVOVF9MRU5HVEgocmVxKSB7XG4gICAgICB2YXIgYXV0aHR5cGUgPSBnZXRPcGVyYXRpb25BdXRodHlwZShyZXEpO1xuICAgICAgaWYgKHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID09PSB1bmRlZmluZWRcbiAgICAgICAgICAmJiBhdXRodHlwZS5pbmRleE9mKCd1bnNpZ25lZC1ib2R5JykgPT09IC0xKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aChyZXEuaHR0cFJlcXVlc3QuYm9keSk7XG4gICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gbGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfSFRUUF9IT1NUJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBTRVRfSFRUUF9IT1NUKHJlcSkge1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuICAgIH0pO1xuXG4gICAgYWRkKCdSRVNUQVJUJywgJ3Jlc3RhcnQnLCBmdW5jdGlvbiBSRVNUQVJUKCkge1xuICAgICAgdmFyIGVyciA9IHRoaXMucmVzcG9uc2UuZXJyb3I7XG4gICAgICBpZiAoIWVyciB8fCAhZXJyLnJldHJ5YWJsZSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gbmV3IEFXUy5IdHRwUmVxdWVzdChcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmVuZHBvaW50LFxuICAgICAgICB0aGlzLnNlcnZpY2UucmVnaW9uXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5yZXNwb25zZS5yZXRyeUNvdW50IDwgdGhpcy5zZXJ2aWNlLmNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UucmV0cnlDb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZS5lcnJvciA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnU0lHTicsICdzaWduJywgZnVuY3Rpb24gU0lHTihyZXEsIGRvbmUpIHtcbiAgICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zIHx8IHt9O1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICB2YXIgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICAgIGlmICghc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbiAmJiAhYXV0aHR5cGUpIHJldHVybiBkb25lKCk7IC8vIG5vbmVcblxuICAgICAgc2VydmljZS5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24gKGVyciwgY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IGVycjtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIHZhciBTaWduZXJDbGFzcyA9IHNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKTtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCxcbiAgICAgICAgICAgIHNlcnZpY2UuYXBpLnNpZ25pbmdOYW1lIHx8IHNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzaWduYXR1cmVDYWNoZTogc2VydmljZS5jb25maWcuc2lnbmF0dXJlQ2FjaGUsXG4gICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBzaWduZXIuc2V0U2VydmljZUNsaWVudElkKHNlcnZpY2UuX2NsaWVudElkKTtcblxuICAgICAgICAgIC8vIGNsZWFyIG9sZCBhdXRob3JpemF0aW9uIGhlYWRlcnNcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXTtcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0RhdGUnXTtcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXTtcblxuICAgICAgICAgIC8vIGFkZCBuZXcgYXV0aG9yaXphdGlvblxuICAgICAgICAgIHNpZ25lci5hZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKTtcbiAgICAgICAgICByZXEuc2lnbmVkQXQgPSBkYXRlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUkVTUE9OU0UnLCAndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uIFZBTElEQVRFX1JFU1BPTlNFKHJlc3ApIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2Uuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3AsIHRoaXMpKSB7XG4gICAgICAgIHJlc3AuZGF0YSA9IHt9O1xuICAgICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7Y29kZTogJ1Vua25vd25FcnJvcicsIG1lc3NhZ2U6ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLid9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdTRU5EJywgJ3NlbmQnLCBmdW5jdGlvbiBTRU5EKHJlc3AsIGRvbmUpIHtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLl9hYm9ydENhbGxiYWNrID0gZG9uZTtcbiAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgcmVzcC5kYXRhID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soaHR0cFJlc3ApIHtcbiAgICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtID0gaHR0cFJlc3A7XG4gICAgICAgIHZhciBzdHJlYW0gPSByZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3Quc3RyZWFtO1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdoZWFkZXJzJywgZnVuY3Rpb24gb25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdChcbiAgICAgICAgICAgICdodHRwSGVhZGVycycsXG4gICAgICAgICAgICBbc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCwgc3RhdHVzTWVzc2FnZV1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFyZXNwLmh0dHBSZXNwb25zZS5zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMikgeyAvLyBzdHJlYW1zMiBBUEkgY2hlY2tcbiAgICAgICAgICAgICAgaHR0cFJlc3Aub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gb25SZWFkYWJsZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGh0dHBSZXNwLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEYXRhJywgW2RhdGEsIHJlc3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGVnYWN5IHN0cmVhbXMgQVBJXG4gICAgICAgICAgICAgIGh0dHBSZXNwLm9uKCdkYXRhJywgZnVuY3Rpb24gb25EYXRhKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERhdGEnLCBbZGF0YSwgcmVzcF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdlbmQnLCBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbSB8fCAhc3RyZWFtLmRpZENhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvbmUnKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9ncmVzcyhodHRwUmVzcCkge1xuICAgICAgICBodHRwUmVzcC5vbignc2VuZFByb2dyZXNzJywgZnVuY3Rpb24gb25TZW5kUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cFVwbG9hZFByb2dyZXNzJywgW3ZhbHVlLCByZXNwXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdyZWNlaXZlUHJvZ3Jlc3MnLCBmdW5jdGlvbiBvblJlY2VpdmVQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG93bmxvYWRQcm9ncmVzcycsIFt2YWx1ZSwgcmVzcF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ1JlcXVlc3RBYm9ydGVkRXJyb3InKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBlcnIuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcicgPyBlcnIuY29kZSA6ICdOZXR3b3JraW5nRXJyb3InO1xuICAgICAgICAgIGVyciA9IEFXUy51dGlsLmVycm9yKGVyciwge1xuICAgICAgICAgICAgY29kZTogZXJyQ29kZSxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbixcbiAgICAgICAgICAgIGhvc3RuYW1lOiByZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNwLmVycm9yID0gZXJyO1xuICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cEVycm9yJywgW3Jlc3AuZXJyb3IsIHJlc3BdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlU2VuZCgpIHtcbiAgICAgICAgdmFyIGh0dHAgPSBBV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgaHR0cE9wdGlvbnMgPSByZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuaHR0cE9wdGlvbnMgfHwge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IGh0dHAuaGFuZGxlUmVxdWVzdChyZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssIGVycm9yKTtcbiAgICAgICAgICBwcm9ncmVzcyhzdHJlYW0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lRGlmZiA9IChBV1MudXRpbC5kYXRlLmdldERhdGUoKSAtIHRoaXMuc2lnbmVkQXQpIC8gMTAwMDtcbiAgICAgIGlmICh0aW1lRGlmZiA+PSA2MCAqIDEwKSB7IC8vIGlmIHdlIHNpZ25lZCAxMG1pbiBhZ28sIHJlLXNpZ25cbiAgICAgICAgdGhpcy5lbWl0KCdzaWduJywgW3RoaXNdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgZWxzZSBleGVjdXRlU2VuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4ZWN1dGVTZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfSEVBREVSUycsICdodHRwSGVhZGVycycsXG4gICAgICAgIGZ1bmN0aW9uIEhUVFBfSEVBREVSUyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5ib2R5ID0gbmV3IEFXUy51dGlsLkJ1ZmZlcignJyk7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzID0gW107XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcyA9IDA7XG4gICAgICB2YXIgZGF0ZUhlYWRlciA9IGhlYWRlcnMuZGF0ZSB8fCBoZWFkZXJzLkRhdGU7XG4gICAgICBpZiAoZGF0ZUhlYWRlcikge1xuICAgICAgICB2YXIgc2VydmVyVGltZSA9IERhdGUucGFyc2UoZGF0ZUhlYWRlcik7XG4gICAgICAgIGlmIChyZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY29ycmVjdENsb2NrU2tld1xuICAgICAgICAgICAgJiYgQVdTLnV0aWwuaXNDbG9ja1NrZXdlZChzZXJ2ZXJUaW1lKSkge1xuICAgICAgICAgIEFXUy51dGlsLmFwcGx5Q2xvY2tPZmZzZXQoc2VydmVyVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9EQVRBJywgJ2h0dHBEYXRhJywgZnVuY3Rpb24gSFRUUF9EQVRBKGNodW5rLCByZXNwKSB7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7XG4gICAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIHRvdGFsID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7IGxvYWRlZDogcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXMsIHRvdGFsOiB0b3RhbCB9O1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG93bmxvYWRQcm9ncmVzcycsIFtwcm9ncmVzcywgcmVzcF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycy5wdXNoKG5ldyBBV1MudXRpbC5CdWZmZXIoY2h1bmspKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9ET05FJywgJ2h0dHBEb25lJywgZnVuY3Rpb24gSFRUUF9ET05FKHJlc3ApIHtcbiAgICAgIC8vIGNvbnZlcnQgYnVmZmVycyBhcnJheSBpbnRvIHNpbmdsZSBidWZmZXJcbiAgICAgIGlmIChyZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzICYmIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYm9keSA9IEFXUy51dGlsLmJ1ZmZlci5jb25jYXQocmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyk7XG4gICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzO1xuICAgICAgZGVsZXRlIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnM7XG4gICAgfSk7XG5cbiAgICBhZGQoJ0ZJTkFMSVpFX0VSUk9SJywgJ3JldHJ5JywgZnVuY3Rpb24gRklOQUxJWkVfRVJST1IocmVzcCkge1xuICAgICAgaWYgKHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgcmVzcC5lcnJvci5zdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmV0cnlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRoaXMuc2VydmljZS5yZXRyeWFibGVFcnJvcihyZXNwLmVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdJTlZBTElEQVRFX0NSRURFTlRJQUxTJywgJ3JldHJ5JywgZnVuY3Rpb24gSU5WQUxJREFURV9DUkVERU5USUFMUyhyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIHN3aXRjaCAocmVzcC5lcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgJ1JlcXVlc3RFeHBpcmVkJzogLy8gRUMyIG9ubHlcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJzpcbiAgICAgICAgY2FzZSAnRXhwaXJlZFRva2VuJzpcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmV4cGlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdFWFBJUkVEX1NJR05BVFVSRScsICdyZXRyeScsIGZ1bmN0aW9uIEVYUElSRURfU0lHTkFUVVJFKHJlc3ApIHtcbiAgICAgIHZhciBlcnIgPSByZXNwLmVycm9yO1xuICAgICAgaWYgKCFlcnIpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgZXJyLmNvZGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlLm1hdGNoKC9TaWduYXR1cmUvKSAmJiBlcnIubWVzc2FnZS5tYXRjaCgvZXhwaXJlZC8pKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NMT0NLX1NLRVdFRCcsICdyZXRyeScsIGZ1bmN0aW9uIENMT0NLX1NLRVdFRChyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AuZXJyb3IpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY2xvY2tTa2V3RXJyb3IocmVzcC5lcnJvcilcbiAgICAgICAgICAmJiB0aGlzLnNlcnZpY2UuY29uZmlnLmNvcnJlY3RDbG9ja1NrZXdcbiAgICAgICAgICAmJiBBV1MuY29uZmlnLmlzQ2xvY2tTa2V3ZWQpIHtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRURJUkVDVCcsICdyZXRyeScsIGZ1bmN0aW9uIFJFRElSRUNUKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmVycm9yICYmIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA+PSAzMDAgJiZcbiAgICAgICAgICByZXNwLmVycm9yLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSkge1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmVuZHBvaW50ID1cbiAgICAgICAgICBuZXcgQVdTLkVuZHBvaW50KHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pO1xuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHRoaXMuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICAgICAgcmVzcC5lcnJvci5yZWRpcmVjdCA9IHRydWU7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbiBSRVRSWV9DSEVDSyhyZXNwKSB7XG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZWRpcmVjdCAmJiByZXNwLnJlZGlyZWN0Q291bnQgPCByZXNwLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gdGhpcy5zZXJ2aWNlLnJldHJ5RGVsYXlzKHJlc3AucmV0cnlDb3VudCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ1JFU0VUX1JFVFJZX1NUQVRFJywgJ2FmdGVyUmV0cnknLCBmdW5jdGlvbiBSRVNFVF9SRVRSWV9TVEFURShyZXNwLCBkb25lKSB7XG4gICAgICB2YXIgZGVsYXksIHdpbGxSZXRyeSA9IGZhbHNlO1xuXG4gICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICBkZWxheSA9IHJlc3AuZXJyb3IucmV0cnlEZWxheSB8fCAwO1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZXRyeWFibGUgJiYgcmVzcC5yZXRyeUNvdW50IDwgcmVzcC5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgcmVzcC5yZXRyeUNvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLmVycm9yLnJlZGlyZWN0ICYmIHJlc3AucmVkaXJlY3RDb3VudCA8IHJlc3AubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgcmVzcC5yZWRpcmVjdENvdW50Kys7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgQ29yZVBvc3Q6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0VYVFJBQ1RfUkVRVUVTVF9JRCcsICdleHRyYWN0RGF0YScsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuICAgIGFkZCgnRVhUUkFDVF9SRVFVRVNUX0lEJywgJ2V4dHJhY3RFcnJvcicsIEFXUy51dGlsLmV4dHJhY3RSZXF1ZXN0SWQpO1xuXG4gICAgYWRkKCdFTk9URk9VTkRfRVJST1InLCAnaHR0cEVycm9yJywgZnVuY3Rpb24gRU5PVEZPVU5EX0VSUk9SKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJyAmJiBlcnIuZXJybm8gPT09ICdFTk9URk9VTkQnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0luYWNjZXNzaWJsZSBob3N0OiBgJyArIGVyci5ob3N0bmFtZSArXG4gICAgICAgICAgJ1xcJy4gVGhpcyBzZXJ2aWNlIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBgJyArIGVyci5yZWdpb24gK1xuICAgICAgICAgICdcXCcgcmVnaW9uLic7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnVW5rbm93bkVuZHBvaW50JyxcbiAgICAgICAgICByZWdpb246IGVyci5yZWdpb24sXG4gICAgICAgICAgaG9zdG5hbWU6IGVyci5ob3N0bmFtZSxcbiAgICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBMb2dnZXI6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICBhZGQoJ0xPR19SRVFVRVNUJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gTE9HX1JFUVVFU1QocmVzcCkge1xuICAgICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICAgIHZhciBsb2dnZXIgPSByZXEuc2VydmljZS5jb25maWcubG9nZ2VyO1xuICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcblxuICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKCkge1xuICAgICAgICB2YXIgdGltZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gKHRpbWUgLSByZXEuc3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgICB2YXIgYW5zaSA9IGxvZ2dlci5pc1RUWSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBwYXJhbXMgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdChyZXEucGFyYW1zLCB0cnVlLCBudWxsKTtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMzNtJztcbiAgICAgICAgbWVzc2FnZSArPSAnW0FXUyAnICsgcmVxLnNlcnZpY2Uuc2VydmljZUlkZW50aWZpZXIgKyAnICcgKyBzdGF0dXM7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgZGVsdGEudG9TdHJpbmcoKSArICdzICcgKyByZXNwLnJldHJ5Q291bnQgKyAnIHJldHJpZXNdJztcbiAgICAgICAgaWYgKGFuc2kpIG1lc3NhZ2UgKz0gJ1xceDFCWzA7MW0nO1xuICAgICAgICBtZXNzYWdlICs9ICcgJyArIEFXUy51dGlsLnN0cmluZy5sb3dlckZpcnN0KHJlcS5vcGVyYXRpb24pO1xuICAgICAgICBtZXNzYWdlICs9ICcoJyArIHBhcmFtcyArICcpJztcbiAgICAgICAgaWYgKGFuc2kpIG1lc3NhZ2UgKz0gJ1xceDFCWzBtJztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gYnVpbGRNZXNzYWdlKCk7XG4gICAgICBpZiAodHlwZW9mIGxvZ2dlci5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2dlci53cml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIud3JpdGUobGluZSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgSnNvbjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL2pzb24nKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdDogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3QnKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdEpzb246IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X2pzb24nKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdFhtbDogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfeG1sJyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pLFxuXG4gIFF1ZXJ5OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcXVlcnknKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSlcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudF9saXN0ZW5lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFjY2VwdG9yU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZV9tYWNoaW5lJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgZG9tYWluID0gQVdTLnV0aWwuZG9tYWluO1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGhhcmRFcnJvclN0YXRlcyA9IHtzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDF9O1xuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsU3RhdGUobWFjaGluZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhcmRFcnJvclN0YXRlcywgbWFjaGluZS5fYXNtLmN1cnJlbnRTdGF0ZSk7XG59XG5cbnZhciBmc20gPSBuZXcgQWNjZXB0b3JTdGF0ZU1hY2hpbmUoKTtcbmZzbS5zZXR1cFN0YXRlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhbnNpdGlvbiA9IGZ1bmN0aW9uKF8sIGRvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvciA9IGZhbHNlO1xuXG4gICAgc2VsZi5lbWl0KHNlbGYuX2FzbS5jdXJyZW50U3RhdGUsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoaXNUZXJtaW5hbFN0YXRlKHNlbGYpKSB7XG4gICAgICAgICAgaWYgKGRvbWFpbiAmJiBzZWxmLmRvbWFpbiBpbnN0YW5jZW9mIGRvbWFpbi5Eb21haW4pIHtcbiAgICAgICAgICAgIGVyci5kb21haW5FbWl0dGVyID0gc2VsZjtcbiAgICAgICAgICAgIGVyci5kb21haW4gPSBzZWxmLmRvbWFpbjtcbiAgICAgICAgICAgIGVyci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuZG9tYWluLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZShzZWxmLnJlc3BvbnNlLmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIHRoaXMuYWRkU3RhdGUoJ3ZhbGlkYXRlJywgJ2J1aWxkJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2J1aWxkJywgJ2FmdGVyQnVpbGQnLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdhZnRlckJ1aWxkJywgJ3NpZ24nLCAncmVzdGFydCcsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzaWduJywgJ3NlbmQnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmV0cnknLCAnYWZ0ZXJSZXRyeScsICdhZnRlclJldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2FmdGVyUmV0cnknLCAnc2lnbicsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzZW5kJywgJ3ZhbGlkYXRlUmVzcG9uc2UnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgndmFsaWRhdGVSZXNwb25zZScsICdleHRyYWN0RGF0YScsICdleHRyYWN0RXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXh0cmFjdEVycm9yJywgJ2V4dHJhY3REYXRhJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2V4dHJhY3REYXRhJywgJ3N1Y2Nlc3MnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgncmVzdGFydCcsICdidWlsZCcsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdzdWNjZXNzJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2Vycm9yJywgJ2NvbXBsZXRlJywgJ2NvbXBsZXRlJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2NvbXBsZXRlJywgbnVsbCwgbnVsbCwgdHJhbnNpdGlvbik7XG59O1xuZnNtLnNldHVwU3RhdGVzKCk7XG5cbi8qKlxuICogIyMgQXN5bmNocm9ub3VzIFJlcXVlc3RzXG4gKlxuICogQWxsIHJlcXVlc3RzIG1hZGUgdGhyb3VnaCB0aGUgU0RLIGFyZSBhc3luY2hyb25vdXMgYW5kIHVzZSBhXG4gKiBjYWxsYmFjayBpbnRlcmZhY2UuIEVhY2ggc2VydmljZSBtZXRob2QgdGhhdCBraWNrcyBvZmYgYSByZXF1ZXN0XG4gKiByZXR1cm5zIGFuIGBBV1MuUmVxdWVzdGAgb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gcmVnaXN0ZXJcbiAqIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBzZXJ2aWNlIG1ldGhvZCByZXR1cm5zIHRoZSByZXF1ZXN0XG4gKiBvYmplY3QgYXMgXCJyZXF1ZXN0XCIsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGNhbGxiYWNrczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyByZXF1ZXN0IGlzIGFuIEFXUy5SZXF1ZXN0IG9iamVjdFxuICogdmFyIHJlcXVlc3QgPSBlYzIuZGVzY3JpYmVJbnN0YW5jZXMoKTtcbiAqXG4gKiAvLyByZWdpc3RlciBjYWxsYmFja3Mgb24gcmVxdWVzdCB0byByZXRyaWV2ZSByZXNwb25zZSBkYXRhXG4gKiByZXF1ZXN0Lm9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFdoZW4gYSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQsIHRoZSB7c2VuZH0gbWV0aG9kIHNob3VsZFxuICogYmUgY2FsbGVkOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHJlcXVlc3Quc2VuZCgpO1xuICogYGBgXG4gKlxuICogU2luY2UgcmVnaXN0ZXJlZCBjYWxsYmFja3MgbWF5IG9yIG1heSBub3QgYmUgaWRlbXBvdGVudCwgcmVxdWVzdHMgc2hvdWxkIG9ubHlcbiAqIGJlIHNlbnQgb25jZS4gVG8gcGVyZm9ybSB0aGUgc2FtZSBvcGVyYXRpb24gbXVsdGlwbGUgdGltZXMsIHlvdSB3aWxsIG5lZWQgdG9cbiAqIGNyZWF0ZSBtdWx0aXBsZSByZXF1ZXN0IG9iamVjdHMsIGVhY2ggd2l0aCBpdHMgb3duIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqICMjIFJlbW92aW5nIERlZmF1bHQgTGlzdGVuZXJzIGZvciBFdmVudHNcbiAqXG4gKiBSZXF1ZXN0IG9iamVjdHMgYXJlIGJ1aWx0IHdpdGggZGVmYXVsdCBsaXN0ZW5lcnMgZm9yIHRoZSB2YXJpb3VzIGV2ZW50cyxcbiAqIGRlcGVuZGluZyBvbiB0aGUgc2VydmljZSB0eXBlLiBJbiBzb21lIGNhc2VzLCB5b3UgbWF5IHdhbnQgdG8gcmVtb3ZlXG4gKiBzb21lIGJ1aWx0LWluIGxpc3RlbmVycyB0byBjdXN0b21pemUgYmVoYXZpb3VyLiBEb2luZyB0aGlzIHJlcXVpcmVzXG4gKiBhY2Nlc3MgdG8gdGhlIGJ1aWx0LWluIGxpc3RlbmVyIGZ1bmN0aW9ucywgd2hpY2ggYXJlIGV4cG9zZWQgdGhyb3VnaFxuICogdGhlIHtBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZX0gbmFtZXNwYWNlLiBGb3IgaW5zdGFuY2UsIHlvdSBtYXlcbiAqIHdhbnQgdG8gY3VzdG9taXplIHRoZSBIVFRQIGhhbmRsZXIgdXNlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0LiBJbiB0aGlzXG4gKiBjYXNlLCB5b3UgY2FuIHJlbW92ZSB0aGUgYnVpbHQtaW4gbGlzdGVuZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSAnc2VuZCdcbiAqIGV2ZW50LCB0aGUge0FXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFTkR9IGxpc3RlbmVyIGFuZCBhZGQgeW91ciBvd24uXG4gKlxuICogIyMgTXVsdGlwbGUgQ2FsbGJhY2tzIGFuZCBDaGFpbmluZ1xuICpcbiAqIFlvdSBjYW4gcmVnaXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2tzIG9uIGFueSByZXF1ZXN0IG9iamVjdC4gVGhlXG4gKiBjYWxsYmFja3MgY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGRpZmZlcmVudCBldmVudHMsIG9yIGFsbCBmb3IgdGhlXG4gKiBzYW1lIGV2ZW50LiBJbiBhZGRpdGlvbiwgeW91IGNhbiBjaGFpbiBjYWxsYmFjayByZWdpc3RyYXRpb24sIGZvclxuICogZXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiByZXF1ZXN0LlxuICogICBvbignc3VjY2VzcycsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzIVwiKTtcbiAqICAgfSkuXG4gKiAgIG9uKCdlcnJvcicsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciFcIik7XG4gKiAgIH0pLlxuICogICBvbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiQWx3YXlzIVwiKTtcbiAqICAgfSkuXG4gKiAgIHNlbmQoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBleGFtcGxlIHdpbGwgcHJpbnQgZWl0aGVyIFwiU3VjY2VzcyEgQWx3YXlzIVwiLCBvciBcIkVycm9yISBBbHdheXMhXCIsXG4gKiBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkZWQgb3Igbm90LlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBSZXF1ZXN0XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIEhUVFAgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtBV1MuSHR0cFJlcXVlc3RdIHRoZSByYXcgSFRUUCByZXF1ZXN0IG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcmVxdWVzdCBoZWFkZXJzIGFuZCBib2R5IGluZm9ybWF0aW9uXG4gKiAgICAgc2VudCBieSB0aGUgc2VydmljZS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdGFydFRpbWVcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbRGF0ZV0gdGhlIHRpbWUgdGhhdCB0aGUgcmVxdWVzdCBzdGFydGVkXG4gKlxuICogQCFncm91cCBSZXF1ZXN0IEJ1aWxkaW5nIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgdmFsaWRhdGUocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYSByZXF1ZXN0IGlzIGJlaW5nIHZhbGlkYXRlZC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGJlIHNlbnQuXG4gKiAgIEBwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYmVpbmcgc2VudFxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OXG4gKiAgIEBleGFtcGxlIEVuc3VyaW5nIHRoYXQgYSBjZXJ0YWluIHBhcmFtZXRlciBpcyBzZXQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbigndmFsaWRhdGUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIGlmICghcmVxLnBhcmFtcy5Cb2R5Lm1hdGNoKC9eSGVsbG9cXHMvKSkge1xuICogICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZHkgbXVzdCBzdGFydCB3aXRoIFwiSGVsbG8gXCInKTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICpcbiAqIEAhZXZlbnQgYnVpbGQocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgcGF5bG9hZCBpcyBiZWluZyBidWlsdC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCBmaWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gc2VuZCB0aGUgcmVxdWVzdFxuICogICBvdmVyIEhUVFAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnZhbGlkYXRlKVxuICogICBAZXhhbXBsZSBBZGQgYSBjdXN0b20gSFRUUCBoZWFkZXIgdG8gYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbignYnVpbGQnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDdXN0b20tSGVhZGVyJ10gPSAndmFsdWUnO1xuICogICAgIH0pO1xuICogICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyAuLi4gfSk7XG4gKlxuICogQCFldmVudCBzaWduKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGJlaW5nIHNpZ25lZC4gTGlzdGVuZXJzIHNob3VsZFxuICogICBhZGQgdGhlIGNvcnJlY3QgYXV0aGVudGljYXRpb24gaGVhZGVycyBhbmQvb3IgYWRqdXN0IHRoZSBib2R5LFxuICogICBkZXBlbmRpbmcgb24gdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBiZWluZyB1c2VkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH52YWxpZGF0ZSlcbiAqXG4gKiBAIWdyb3VwIFJlcXVlc3QgU2VuZGluZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHNlbmQocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQuIExpc3RlbmVyc1xuICogICBzaG91bGQgY2FsbCB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgbGF5ZXIgdG8gaW5pdGlhdGVcbiAqICAgdGhlIHNlbmRpbmcgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSByZXNwb25zZSBbUmVzcG9uc2VdIHRoZSByZXNwb25zZSBvYmplY3RcbiAqICAgQGNvbnRleHQgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCB0aGF0IHdhcyBzZW50XG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORFxuICpcbiAqIEAhZXZlbnQgcmV0cnkocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGEgcmVxdWVzdCBmYWlsZWQgYW5kIG1pZ2h0IG5lZWQgdG8gYmUgcmV0cmllZCBvciByZWRpcmVjdGVkLlxuICogICBJZiB0aGUgcmVzcG9uc2UgaXMgcmV0cnlhYmxlLCB0aGUgbGlzdGVuZXIgc2hvdWxkIHNldCB0aGVcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZWAgcHJvcGVydHkgdG8gYHRydWVgLCBhbmQgb3B0aW9uYWxseSBzZXRcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5RGVsYXlgIHRvIHRoZSBtaWxsaXNlY29uZCBkZWxheSBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAqICAgSW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgYHJlc3BvbnNlLmVycm9yLnJlZGlyZWN0YCBzaG91bGQgYmUgc2V0IHRvXG4gKiAgIGB0cnVlYCB3aXRoIGByZXRyeURlbGF5YCBzZXQgdG8gYW4gb3B0aW9uYWwgZGVsYXkgb24gdGhlIG5leHQgcmVxdWVzdC5cbiAqXG4gKiAgIElmIGEgbGlzdGVuZXIgZGVjaWRlcyB0aGF0IGEgcmVxdWVzdCBzaG91bGQgbm90IGJlIHJldHJpZWQsXG4gKiAgIGl0IHNob3VsZCBzZXQgYm90aCBgcmV0cnlhYmxlYCBhbmQgYHJlZGlyZWN0YCB0byBmYWxzZS5cbiAqXG4gKiAgIE5vdGUgdGhhdCBhIHJldHJ5YWJsZSBlcnJvciB3aWxsIGJlIHJldHJpZWQgYXQgbW9zdFxuICogICB7QVdTLkNvbmZpZy5tYXhSZXRyaWVzfSB0aW1lcyAoYmFzZWQgb24gdGhlIHNlcnZpY2Ugb2JqZWN0J3MgY29uZmlnKS5cbiAqICAgU2ltaWxhcmx5LCBhIHJlcXVlc3QgdGhhdCBpcyByZWRpcmVjdGVkIHdpbGwgb25seSByZWRpcmVjdCBhdCBtb3N0XG4gKiAgIHtBV1MuQ29uZmlnLm1heFJlZGlyZWN0c30gdGltZXMuXG4gKlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBleGFtcGxlIEFkZGluZyBhIGN1c3RvbSByZXRyeSBmb3IgYSA0MDQgcmVzcG9uc2VcbiAqICAgICByZXF1ZXN0Lm9uKCdyZXRyeScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgICAvLyB0aGlzIHJlc291cmNlIGlzIG5vdCB5ZXQgYXZhaWxhYmxlLCB3YWl0IDEwIHNlY29uZHMgdG8gZ2V0IGl0IGFnYWluXG4gKiAgICAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCAmJiByZXNwb25zZS5lcnJvcikge1xuICogICAgICAgICByZXNwb25zZS5lcnJvci5yZXRyeWFibGUgPSB0cnVlOyAgIC8vIHJldHJ5IHRoaXMgZXJyb3JcbiAqICAgICAgICAgcmVzcG9uc2UuZXJyb3IucmV0cnlEZWxheSA9IDEwMDAwOyAvLyB3YWl0IDEwIHNlY29uZHNcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAIWdyb3VwIERhdGEgUGFyc2luZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IGV4dHJhY3RFcnJvcihyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIG9uIGFsbCBub24tMnh4IHJlcXVlc3RzIHNvIHRoYXQgbGlzdGVuZXJzIGNhbiBleHRyYWN0XG4gKiAgIGVycm9yIGRldGFpbHMgZnJvbSB0aGUgcmVzcG9uc2UgYm9keS4gTGlzdGVuZXJzIHRvIHRoaXMgZXZlbnRcbiAqICAgc2hvdWxkIHNldCB0aGUgYHJlc3BvbnNlLmVycm9yYCBwcm9wZXJ0eS5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXh0cmFjdERhdGEocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCBpbiBzdWNjZXNzZnVsIHJlcXVlc3RzIHRvIGFsbG93IGxpc3RlbmVycyB0b1xuICogICBkZS1zZXJpYWxpemUgdGhlIHJlc3BvbnNlIGJvZHkgaW50byBgcmVzcG9uc2UuZGF0YWAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIENvbXBsZXRpb24gRXZlbnRzXG4gKlxuICogQCFldmVudCBzdWNjZXNzKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICogICBgcmVzcG9uc2UuZGF0YWAgd2lsbCBjb250YWluIHRoZSByZXNwb25zZSBkYXRhIGFuZFxuICogICBgcmVzcG9uc2UuZXJyb3JgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgYXQgYW55IHBvaW50IGR1cmluZyB0aGVcbiAqICAgcmVxdWVzdC4gYHJlc3BvbnNlLmVycm9yYCB3aWxsIGNvbnRhaW4gZGV0YWlscyBhYm91dCB0aGUgZXJyb3JcbiAqICAgdGhhdCBvY2N1cnJlZC4gYHJlc3BvbnNlLmRhdGFgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXRcbiAqICAgICB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgY29tcGxldGUocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuZXZlciBhIHJlcXVlc3QgY3ljbGUgY29tcGxldGVzLiBgcmVzcG9uc2UuZXJyb3JgXG4gKiAgIHNob3VsZCBiZSBjaGVja2VkLCBzaW5jZSB0aGUgcmVxdWVzdCBtYXkgaGF2ZSBmYWlsZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIEhUVFAgRXZlbnRzXG4gKlxuICogQCFldmVudCBodHRwSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwb25zZSwgc3RhdHVzTWVzc2FnZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gaGVhZGVycyBhcmUgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gc3RhdHVzQ29kZSBbSW50ZWdlcl0gdGhlIEhUVFAgcmVzcG9uc2UgY29kZVxuICogICBAcGFyYW0gaGVhZGVycyBbbWFwPFN0cmluZyxTdHJpbmc+XSB0aGUgcmVzcG9uc2UgaGVhZGVyc1xuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAcGFyYW0gc3RhdHVzTWVzc2FnZSBbU3RyaW5nXSBBIHN0YXR1cyBtZXNzYWdlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhUVFBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgY29kZVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRGF0YShjaHVuaywgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGRhdGEgaXMgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gY2h1bmsgW0J1ZmZlcl0gdGhlIGJ1ZmZlciBkYXRhIGNvbnRhaW5pbmcgdGhlIG5leHQgZGF0YSBjaHVua1xuICogICAgIGZyb20gdGhlIHNlcnZlclxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBXG4gKlxuICogQCFldmVudCBodHRwVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyB1cGxvYWRlZCBtb3JlIGRhdGFcbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBub3RlIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgZW1pdHRlZCBpbiBOb2RlLmpzIDAuOC54LlxuICpcbiAqIEAhZXZlbnQgaHR0cERvd25sb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyBkb3dubG9hZGVkIG1vcmUgZGF0YVxuICogICBAcGFyYW0gcHJvZ3Jlc3MgW21hcF0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBsb2FkZWRgIGFuZCBgdG90YWxgIGJ5dGVzXG4gKiAgICAgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKlxuICogQCFldmVudCBodHRwRXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGZhaWxlZFxuICogICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHRoYXQgd2FzIHRocm93blxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRG9uZShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHNlcnZlciBpcyBmaW5pc2hlZCBzZW5kaW5nIGRhdGFcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEBzZWUgQVdTLlJlc3BvbnNlXG4gKi9cbkFXUy5SZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXF1ZXN0IGZvciBhbiBvcGVyYXRpb24gb24gYSBnaXZlbiBzZXJ2aWNlIHdpdGhcbiAgICogYSBzZXQgb2YgaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2UgW0FXUy5TZXJ2aWNlXSB0aGUgc2VydmljZSB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24gb25cbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgb3BlcmF0aW9uIHRvIHBlcmZvcm0gb24gdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHBhcmFtcyBbT2JqZWN0XSBwYXJhbWV0ZXJzIHRvIHNlbmQgdG8gdGhlIG9wZXJhdGlvbi5cbiAgICogICBTZWUgdGhlIG9wZXJhdGlvbidzIGRvY3VtZW50YXRpb24gZm9yIHRoZSBmb3JtYXQgb2YgdGhlXG4gICAqICAgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXF1ZXN0KHNlcnZpY2UsIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgdmFyIGVuZHBvaW50ID0gc2VydmljZS5lbmRwb2ludDtcbiAgICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICAgIHZhciBjdXN0b21Vc2VyQWdlbnQgPSBzZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ7XG5cbiAgICAvLyBnbG9iYWwgZW5kcG9pbnRzIHNpZ24gYXMgdXMtZWFzdC0xXG4gICAgaWYgKHNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG5cbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbiAmJiBkb21haW4uYWN0aXZlO1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoZW5kcG9pbnQsIHJlZ2lvbik7XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCk7XG5cbiAgICB0aGlzLnJlc3BvbnNlID0gbmV3IEFXUy5SZXNwb25zZSh0aGlzKTtcbiAgICB0aGlzLl9hc20gPSBuZXcgQWNjZXB0b3JTdGF0ZU1hY2hpbmUoZnNtLnN0YXRlcywgJ3ZhbGlkYXRlJyk7XG4gICAgdGhpcy5faGFsdEhhbmRsZXJzT25FcnJvciA9IGZhbHNlO1xuXG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCA9IHRoaXMuZW1pdEV2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIWdyb3VwIFNlbmRpbmcgYSBSZXF1ZXN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgc2VuZChjYWxsYmFjayA9IG51bGwpXG4gICAqICAgU2VuZHMgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKlxuICAgKiAgIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgICAgQGNvbnRleHQgW0FXUy5SZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYmVpbmcgc2VudC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGggYSBjYWxsYmFja1xuICAgKiAgICAgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgcmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyBjb25zb2xlLmxvZyhlcnIsIGRhdGEpOyB9KTtcbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRoIG5vIGNhbGxiYWNrICh1c2luZyBldmVudCBoYW5kbGVycylcbiAgICogICAgIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHsgLi4uIH0pOyAvLyByZWdpc3RlciBhIGNhbGxiYWNrXG4gICAqICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIGFwcGVuZCB0byB1c2VyIGFnZW50XG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdjYWxsYmFjaycpO1xuICAgICAgdGhpcy5vbignY29tcGxldGUnLCBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHJlc3AsIHJlc3AuZXJyb3IsIHJlc3AuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UbygpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBwcm9taXNlKClcbiAgICogICBTZW5kcyB0aGUgcmVxdWVzdCBhbmQgcmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbihkYXRhKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICogICAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnJvcilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnJvciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgcmVxdWVzdC5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB1c2luZyBwcm9taXNlcy5cbiAgICogICAgIHZhciByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5wcm9taXNlKCk7XG4gICAqICAgICByZXN1bHQudGhlbihmdW5jdGlvbihkYXRhKSB7IC4uLiB9LCBmdW5jdGlvbihlcnJvcikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnJ1blRvKCdzZW5kJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJ1blRvOiBmdW5jdGlvbiBydW5UbyhzdGF0ZSwgZG9uZSkge1xuICAgIHRoaXMuX2FzbS5ydW5UbyhzdGF0ZSwgZG9uZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QsIGVtaXR0aW5nIHRoZSBlcnJvciBhbmQgY29tcGxldGUgZXZlbnRzLlxuICAgKlxuICAgKiBAIW1hY3JvIG5vYnJvd3NlclxuICAgKiBAZXhhbXBsZSBBYm9ydGluZyBhIHJlcXVlc3QgYWZ0ZXIgc2VuZGluZ1xuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLFxuICAgKiAgICAgQm9keTogbmV3IEJ1ZmZlcigxMDI0ICogMTAyNCAqIDUpIC8vIDVNQiBwYXlsb2FkXG4gICAqICAgfTtcbiAgICogICB2YXIgcmVxdWVzdCA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICAgKiAgIHJlcXVlc3Quc2VuZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yOlwiLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICAgKiAgICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyBhYm9ydCByZXF1ZXN0IGluIDEgc2Vjb25kXG4gICAqICAgc2V0VGltZW91dChyZXF1ZXN0LmFib3J0LmJpbmQocmVxdWVzdCksIDEwMDApO1xuICAgKlxuICAgKiAgIC8vIHByaW50cyBcIkVycm9yOiBSZXF1ZXN0QWJvcnRlZEVycm9yIFJlcXVlc3QgYWJvcnRlZCBieSB1c2VyXCJcbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdIHRoZSBzYW1lIHJlcXVlc3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygndmFsaWRhdGVSZXNwb25zZScpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdleHRyYWN0RXJyb3InKTtcbiAgICB0aGlzLm9uKCd2YWxpZGF0ZVJlc3BvbnNlJywgZnVuY3Rpb24gYWRkQWJvcnRlZEVycm9yKHJlc3ApIHtcbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCBieSB1c2VyJyksIHtcbiAgICAgICAgIGNvZGU6ICdSZXF1ZXN0QWJvcnRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5odHRwUmVxdWVzdC5zdHJlYW0gJiYgIXRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtLmRpZENhbGxiYWNrKSB7IC8vIGFib3J0IEhUVFAgc3RyZWFtXG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbS5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2spIHtcbiAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdzZW5kJyk7IC8vIGhhdmVuJ3Qgc2VudCB5ZXQsIHNvIGxldCdzIG5vdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVhY2ggcGFnZSBvZiByZXN1bHRzIGdpdmVuIGEgcGFnZWFibGUgcmVxdWVzdCwgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2l0aCBlYWNoIHBhZ2Ugb2YgZGF0YS4gQWZ0ZXIgYWxsIHBhZ2VzIGhhdmUgYmVlblxuICAgKiByZXRyaWV2ZWQsIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBgbnVsbGAgZGF0YS5cbiAgICpcbiAgICogQG5vdGUgVGhpcyBvcGVyYXRpb24gY2FuIGdlbmVyYXRlIG11bHRpcGxlIHJlcXVlc3RzIHRvIGEgc2VydmljZS5cbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgb2Ygb2JqZWN0cyBpbiBhbiBTMyBidWNrZXRcbiAgICogICB2YXIgcGFnZXMgPSAxO1xuICAgKiAgIHMzLmxpc3RPYmplY3RzKCkuZWFjaFBhZ2UoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSByZXR1cm47XG4gICAqICAgICBjb25zb2xlLmxvZyhcIlBhZ2VcIiwgcGFnZXMrKyk7XG4gICAqICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgd2l0aCBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2tcbiAgICogICBzMy5saXN0T2JqZWN0cyhwYXJhbXMpLmVhY2hQYWdlKGZ1bmN0aW9uKGVyciwgZGF0YSwgZG9uZSkge1xuICAgKiAgICAgZG9Tb21ldGhpbmdBc3luY0FuZE9yRXhwZW5zaXZlKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAvLyBUaGUgbmV4dCBwYWdlIG9mIHJlc3VsdHMgaXNuJ3QgZmV0Y2hlZCB1bnRpbCBkb25lIGlzIGNhbGxlZFxuICAgKiAgICAgICBkb25lKCk7XG4gICAqICAgICB9KTtcbiAgICogICB9KTtcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSwgW2RvbmVDYWxsYmFja10pXG4gICAqICAgQ2FsbGVkIHdpdGggZWFjaCBwYWdlIG9mIHJlc3VsdGluZyBkYXRhIGZyb20gdGhlIHJlcXVlc3QuIElmIHRoZVxuICAgKiAgIG9wdGlvbmFsIGBkb25lQ2FsbGJhY2tgIGlzIHByb3ZpZGVkIGluIHRoZSBmdW5jdGlvbiwgaXQgbXVzdCBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBjYWxsYmFjayBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb2JqZWN0LCBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSBhIHNpbmdsZSBwYWdlIG9mIHJlc3BvbnNlIGRhdGEuIElmIHRoZXJlIGlzIG5vXG4gICAqICAgICBtb3JlIGRhdGEsIHRoaXMgb2JqZWN0IHdpbGwgYmUgYG51bGxgLlxuICAgKiAgIEBwYXJhbSBkb25lQ2FsbGJhY2sgW0Z1bmN0aW9uXSBhbiBvcHRpb25hbCBkb25lIGNhbGxiYWNrLiBJZiB0aGlzXG4gICAqICAgICBhcmd1bWVudCBpcyBkZWZpbmVkIGluIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiwgaXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiAgICAgd2hlbiB0aGUgbmV4dCBwYWdlIGlzIHJlYWR5IHRvIGJlIHJldHJpZXZlZC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqICAgICBjb250cm9sbGluZyBzZXJpYWwgcGFnaW5hdGlvbiBhY3Jvc3MgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gICAqICAgQHJldHVybiBbQm9vbGVhbl0gaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgcGFnaW5hdGlvbiB3aWxsXG4gICAqICAgICBzdG9wLlxuICAgKlxuICAgKiBAc2VlIEFXUy5SZXF1ZXN0LmVhY2hJdGVtXG4gICAqIEBzZWUgQVdTLlJlc3BvbnNlLm5leHRQYWdlXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGVhY2hQYWdlOiBmdW5jdGlvbiBlYWNoUGFnZShjYWxsYmFjaykge1xuICAgIC8vIE1ha2UgYWxsIGNhbGxiYWNrcyBhc3luYy1pc2hcbiAgICBjYWxsYmFjayA9IEFXUy51dGlsLmZuLm1ha2VBc3luYyhjYWxsYmFjaywgMyk7XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIHJlc3BvbnNlLmVycm9yLCByZXNwb25zZS5kYXRhLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICByZXNwb25zZS5uZXh0UGFnZSgpLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIG51bGwsIG51bGwsIEFXUy51dGlsLmZuLm5vb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnVtZXJhdGVzIG92ZXIgaW5kaXZpZHVhbCBpdGVtcyBvZiBhIHJlcXVlc3QsIHBhZ2luZyB0aGUgcmVzcG9uc2VzIGlmXG4gICAqIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQGFwaSBleHBlcmltZW50YWxcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgZWFjaEl0ZW06IGZ1bmN0aW9uIGVhY2hJdGVtKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRDYWxsYmFjayhlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcblxuICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHNlbGYub3BlcmF0aW9uKTtcbiAgICAgIHZhciByZXN1bHRLZXkgPSBjb25maWcucmVzdWx0S2V5O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0S2V5KSkgcmVzdWx0S2V5ID0gcmVzdWx0S2V5WzBdO1xuICAgICAgdmFyIGl0ZW1zID0gam1lc3BhdGguc2VhcmNoKGRhdGEsIHJlc3VsdEtleSk7XG4gICAgICB2YXIgY29udGludWVJdGVyYXRpb24gPSB0cnVlO1xuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGNvbnRpbnVlSXRlcmF0aW9uID0gY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICAgIGlmIChjb250aW51ZUl0ZXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gQVdTLnV0aWwuYWJvcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRpbnVlSXRlcmF0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaFBhZ2Uod3JhcHBlZENhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgb3BlcmF0aW9uIGNhbiByZXR1cm4gbXVsdGlwbGUgcGFnZXMgb2ZcbiAgICogICByZXNwb25zZSBkYXRhLlxuICAgKiBAc2VlIEFXUy5SZXNwb25zZS5lYWNoUGFnZVxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBpc1BhZ2VhYmxlOiBmdW5jdGlvbiBpc1BhZ2VhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyh0aGlzLm9wZXJhdGlvbikgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSByZXF1ZXN0IGFuZCBjb252ZXJ0cyB0aGUgcmVxdWVzdCBvYmplY3QgaW50byBhIHJlYWRhYmxlIHN0cmVhbVxuICAgKiB0aGF0IGNhbiBiZSByZWFkIGZyb20gb3IgcGlwZWQgaW50byBhIHdyaXRhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQG5vdGUgVGhlIGRhdGEgcmVhZCBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIGNvbnRhaW5zIG9ubHlcbiAgICogICB0aGUgcmF3IEhUVFAgYm9keSBjb250ZW50cy5cbiAgICogQGV4YW1wbGUgTWFudWFsbHkgcmVhZGluZyBmcm9tIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtKCkub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcIkdvdCBkYXRhOlwiLCBkYXRhLnRvU3RyaW5nKCkpO1xuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBQaXBpbmcgYSByZXF1ZXN0IGJvZHkgaW50byBhIGZpbGVcbiAgICogICB2YXIgb3V0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oJy9wYXRoL3RvL291dGZpbGUuanBnJyk7XG4gICAqICAgczMuc2VydmljZS5nZXRPYmplY3QocGFyYW1zKS5jcmVhdGVSZWFkU3RyZWFtKCkucGlwZShvdXQpO1xuICAgKiBAcmV0dXJuIFtTdHJlYW1dIHRoZSByZWFkYWJsZSBzdHJlYW0gb2JqZWN0IHRoYXQgY2FuIGJlIHBpcGVkXG4gICAqICAgb3IgcmVhZCBmcm9tIChieSByZWdpc3RlcmluZyAnZGF0YScgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICovXG4gIGNyZWF0ZVJlYWRTdHJlYW06IGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0oKSB7XG4gICAgdmFyIHN0cmVhbXMgPSBBV1MudXRpbC5zdHJlYW07XG4gICAgdmFyIHJlcSA9IHRoaXM7XG4gICAgdmFyIHN0cmVhbSA9IG51bGw7XG5cbiAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgIHN0cmVhbSA9IG5ldyBzdHJlYW1zLlBhc3NUaHJvdWdoKCk7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtID0gbmV3IHN0cmVhbXMuU3RyZWFtKCk7XG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuXG4gICAgICBzdHJlYW0uc2VudCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghc3RyZWFtLnNlbnQgJiYgZXZlbnQgPT09ICdkYXRhJykge1xuICAgICAgICAgIHN0cmVhbS5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdodHRwSGVhZGVycycsIGZ1bmN0aW9uIHN0cmVhbUhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdodHRwRGF0YScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQSk7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignaHR0cEVycm9yJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9FUlJPUik7XG4gICAgICAgIHJlcS5vbignaHR0cEVycm9yJywgZnVuY3Rpb24gc3RyZWFtSHR0cEVycm9yKGVycm9yKSB7XG4gICAgICAgICAgcmVzcC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4cGVjdGVkTGVuO1xuICAgICAgICBpZiAocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgZXhwZWN0ZWRMZW4gPSBwYXJzZUludChoZWFkZXJzWydjb250ZW50LWxlbmd0aCddLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdGVkTGVuICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKGV4cGVjdGVkTGVuKSAmJiBleHBlY3RlZExlbiA+PSAwKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZWRMZW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQgPSBmdW5jdGlvbiBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KCkge1xuICAgICAgICAgIGlmIChzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggJiYgcmVjZWl2ZWRMZW4gIT09IGV4cGVjdGVkTGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdTdHJlYW0gY29udGVudCBsZW5ndGggbWlzbWF0Y2guIFJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICsgJyBvZiAnICsgZXhwZWN0ZWRMZW4gKyAnIGJ5dGVzLicpLFxuICAgICAgICAgICAgICB7IGNvZGU6ICdTdHJlYW1Db250ZW50TGVuZ3RoTWlzbWF0Y2gnIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaHR0cFN0cmVhbSA9IHJlc3AuaHR0cFJlc3BvbnNlLmNyZWF0ZVVuYnVmZmVyZWRTdHJlYW0oKTtcblxuICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQWNjdW11bGF0b3IgPSBuZXcgc3RyZWFtcy5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtcy5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5vbignZW5kJywgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICBodHRwU3RyZWFtLnVucGlwZShsZW5ndGhBY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5waXBlKGxlbmd0aEFjY3VtdWxhdG9yKS5waXBlKHN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGh0dHBTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBodHRwU3RyZWFtLm9uKCdlbmQnLCBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHBTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gW0FycmF5LFJlc3BvbnNlXSBhcmdzIFRoaXMgc2hvdWxkIGJlIHRoZSByZXNwb25zZSBvYmplY3QsXG4gICAqICAgb3IgYW4gYXJyYXkgb2YgYXJncyB0byBzZW5kIHRvIHRoZSBldmVudC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBhcmdzLCBkb25lKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7IGRvbmUgPSBhcmdzOyBhcmdzID0gbnVsbDsgfVxuICAgIGlmICghZG9uZSkgZG9uZSA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIGlmICghYXJncykgYXJncyA9IHRoaXMuZXZlbnRQYXJhbWV0ZXJzKGV2ZW50TmFtZSwgdGhpcy5yZXNwb25zZSk7XG5cbiAgICB2YXIgb3JpZ0VtaXQgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5lbWl0O1xuICAgIG9yaWdFbWl0LmNhbGwodGhpcywgZXZlbnROYW1lLCBhcmdzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB0aGlzLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgZG9uZS5jYWxsKHRoaXMsIGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXZlbnRQYXJhbWV0ZXJzOiBmdW5jdGlvbiBldmVudFBhcmFtZXRlcnMoZXZlbnROYW1lKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgY2FzZSAndmFsaWRhdGUnOlxuICAgICAgY2FzZSAnc2lnbic6XG4gICAgICBjYXNlICdidWlsZCc6XG4gICAgICBjYXNlICdhZnRlclZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ2FmdGVyQnVpbGQnOlxuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gW3RoaXMucmVzcG9uc2UuZXJyb3IsIHRoaXMucmVzcG9uc2VdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt0aGlzLnJlc3BvbnNlXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlc2lnbjogZnVuY3Rpb24gcHJlc2lnbihleHBpcmVzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGV4cGlyZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXhwaXJlcztcbiAgICAgIGV4cGlyZXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFXUy5TaWduZXJzLlByZXNpZ24oKS5zaWduKHRoaXMudG9HZXQoKSwgZXhwaXJlcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzUHJlc2lnbmVkOiBmdW5jdGlvbiBpc1ByZXNpZ25lZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaHR0cFJlcXVlc3QuaGVhZGVycywgJ3ByZXNpZ25lZC1leHBpcmVzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG9VbmF1dGhlbnRpY2F0ZWQ6IGZ1bmN0aW9uIHRvVW5hdXRoZW50aWNhdGVkKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFMpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3NpZ24nLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TSUdOKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b0dldDogZnVuY3Rpb24gdG9HZXQoKSB7XG4gICAgaWYgKHRoaXMuc2VydmljZS5hcGkucHJvdG9jb2wgPT09ICdxdWVyeScgfHxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGRBc0dldDogZnVuY3Rpb24gYnVpbGRBc0dldChyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5tZXRob2QgPSAnR0VUJztcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGggPSByZXF1ZXN0LnNlcnZpY2UuZW5kcG9pbnQucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz8nICsgcmVxdWVzdC5odHRwUmVxdWVzdC5ib2R5O1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuYm9keSA9ICcnO1xuXG4gICAgLy8gZG9uJ3QgbmVlZCB0aGVzZSBoZWFkZXJzIG9uIGEgR0VUIHJlcXVlc3RcbiAgICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhbHRIYW5kbGVyc09uRXJyb3I6IGZ1bmN0aW9uIGhhbHRIYW5kbGVyc09uRXJyb3IoKSB7XG4gICAgdGhpcy5faGFsdEhhbmRsZXJzT25FcnJvciA9IHRydWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVxdWVzdC5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGFwcGVuZCB0byB1c2VyIGFnZW50XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudCgncHJvbWlzZScpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZURlcGVuZGVuY3koZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzZWxmLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocmVzcC5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lICRyZXNwb25zZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGlzIG5vdCBlbnVtYmVyYWJsZVxuICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgY2lyY3VsYXIgcmVmZXJlbmNlIGVycm9ycyB3aGVuIHN0cmluZ2lmeWluZyB0aGUgSlNPTiBvYmplY3RcbiAgICAgICAgICByZXNvbHZlKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIHJlc3AuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgICckcmVzcG9uc2UnLFxuICAgICAgICAgICAge3ZhbHVlOiByZXNwfVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYucnVuVG8oKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXF1ZXN0LmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5wcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLlJlcXVlc3QpO1xuXG5BV1MudXRpbC5taXhpbihBV1MuUmVxdWVzdCwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJmdW5jdGlvbiBBY2NlcHRvclN0YXRlTWFjaGluZShzdGF0ZXMsIHN0YXRlKSB7XG4gIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGUgfHwgbnVsbDtcbiAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXMgfHwge307XG59XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5ydW5UbyA9IGZ1bmN0aW9uIHJ1blRvKGZpbmFsU3RhdGUsIGRvbmUsIGJpbmRPYmplY3QsIGlucHV0RXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBmaW5hbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5wdXRFcnJvciA9IGJpbmRPYmplY3Q7IGJpbmRPYmplY3QgPSBkb25lO1xuICAgIGRvbmUgPSBmaW5hbFN0YXRlOyBmaW5hbFN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXRlID0gc2VsZi5zdGF0ZXNbc2VsZi5jdXJyZW50U3RhdGVdO1xuICBzdGF0ZS5mbi5jYWxsKGJpbmRPYmplY3QgfHwgc2VsZiwgaW5wdXRFcnJvciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKHN0YXRlLmZhaWwpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuZmFpbDtcbiAgICAgIGVsc2UgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHQpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuYWNjZXB0O1xuICAgICAgZWxzZSByZXR1cm4gZG9uZSA/IGRvbmUuY2FsbChiaW5kT2JqZWN0KSA6IG51bGw7XG4gICAgfVxuICAgIGlmIChzZWxmLmN1cnJlbnRTdGF0ZSA9PT0gZmluYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2VsZi5ydW5UbyhmaW5hbFN0YXRlLCBkb25lLCBiaW5kT2JqZWN0LCBlcnIpO1xuICB9KTtcbn07XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5hZGRTdGF0ZSA9IGZ1bmN0aW9uIGFkZFN0YXRlKG5hbWUsIGFjY2VwdFN0YXRlLCBmYWlsU3RhdGUsIGZuKSB7XG4gIGlmICh0eXBlb2YgYWNjZXB0U3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGFjY2VwdFN0YXRlOyBhY2NlcHRTdGF0ZSA9IG51bGw7IGZhaWxTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZhaWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZmFpbFN0YXRlOyBmYWlsU3RhdGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSkgdGhpcy5jdXJyZW50U3RhdGUgPSBuYW1lO1xuICB0aGlzLnN0YXRlc1tuYW1lXSA9IHsgYWNjZXB0OiBhY2NlcHRTdGF0ZSwgZmFpbDogZmFpbFN0YXRlLCBmbjogZm4gfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2VwdG9yU3RhdGVNYWNoaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc3RhdGVfbWFjaGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGptZXNwYXRoID0gcmVxdWlyZSgnam1lc3BhdGgnKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyB0aGUgcmVzcG9uc2UgaW5mb3JtYXRpb25cbiAqIGZyb20gYSBzZXJ2aWNlIHJlcXVlc3Qgb3BlcmF0aW9uIHNlbnQgdGhyb3VnaCB7QVdTLlJlcXVlc3R9LlxuICogVGhlIHJlc3BvbnNlIG9iamVjdCBoYXMgdHdvIG1haW4gcHJvcGVydGllcyBmb3IgZ2V0dGluZyBpbmZvcm1hdGlvblxuICogYmFjayBmcm9tIGEgcmVxdWVzdDpcbiAqXG4gKiAjIyBUaGUgYGRhdGFgIHByb3BlcnR5XG4gKlxuICogVGhlIGByZXNwb25zZS5kYXRhYCBwcm9wZXJ0eSBjb250YWlucyB0aGUgc2VyaWFsaXplZCBvYmplY3QgZGF0YVxuICogcmV0cmlldmVkIGZyb20gdGhlIHNlcnZpY2UgcmVxdWVzdC4gRm9yIGluc3RhbmNlLCBmb3IgYW5cbiAqIEFtYXpvbiBEeW5hbW9EQiBgbGlzdFRhYmxlc2AgbWV0aG9kIGNhbGwsIHRoZSByZXNwb25zZSBkYXRhIG1pZ2h0XG4gKiBsb29rIGxpa2U6XG4gKlxuICogYGBgXG4gKiA+IHJlc3AuZGF0YVxuICogeyBUYWJsZU5hbWVzOlxuICogICAgWyAndGFibGUxJywgJ3RhYmxlMicsIC4uLiBdIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBgZGF0YWAgcHJvcGVydHkgY2FuIGJlIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzIChzZWUgYmVsb3cpLlxuICpcbiAqICMjIFRoZSBgZXJyb3JgIHByb3BlcnR5XG4gKlxuICogSW4gdGhlIGV2ZW50IG9mIGEgc2VydmljZSBlcnJvciAob3IgdHJhbnNmZXIgZXJyb3IpLCB0aGVcbiAqIGByZXNwb25zZS5lcnJvcmAgcHJvcGVydHkgd2lsbCBiZSBmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGVycm9yIGRhdGEgaW4gdGhlIGZvcm06XG4gKlxuICogYGBgXG4gKiB7IGNvZGU6ICdTSE9SVF9VTklRVUVfRVJST1JfQ09ERScsXG4gKiAgIG1lc3NhZ2U6ICdTb21lIGh1bWFuIHJlYWRhYmxlIGVycm9yIG1lc3NhZ2UnIH1cbiAqIGBgYFxuICpcbiAqIEluIHRoZSBjYXNlIG9mIGFuIGVycm9yLCB0aGUgYGRhdGFgIHByb3BlcnR5IHdpbGwgYmUgYG51bGxgLlxuICogTm90ZSB0aGF0IGlmIHlvdSBoYW5kbGUgZXZlbnRzIHRoYXQgY2FuIGJlIGluIGEgZmFpbHVyZSBzdGF0ZSxcbiAqIHlvdSBzaG91bGQgYWx3YXlzIGNoZWNrIHdoZXRoZXIgYHJlc3BvbnNlLmVycm9yYCBpcyBzZXRcbiAqIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjY2VzcyB0aGUgYHJlc3BvbnNlLmRhdGFgIHByb3BlcnR5LlxuICpcbiAqIEAhYXR0cmlidXRlIGRhdGFcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgRGF0YSBQcm9wZXJ0aWVzXG4gKiAgIEBub3RlIEluc2lkZSBvZiBhIHtBV1MuUmVxdWVzdH5odHRwRGF0YX0gZXZlbnQsIHRoaXNcbiAqICAgICBwcm9wZXJ0eSBjb250YWlucyBhIHNpbmdsZSByYXcgcGFja2V0IGluc3RlYWQgb2YgdGhlXG4gKiAgICAgZnVsbCBkZS1zZXJpYWxpemVkIHNlcnZpY2UgcmVzcG9uc2UuXG4gKiAgIEByZXR1cm4gW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgcmVzcG9uc2UgZGF0YVxuICogICAgIGZyb20gdGhlIHNlcnZpY2UuXG4gKlxuICogQCFhdHRyaWJ1dGUgZXJyb3JcbiAqICAgQW4gc3RydWN0dXJlIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgYSBzZXJ2aWNlXG4gKiAgIG9yIG5ldHdvcmtpbmcgZXJyb3IuXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAbm90ZSBUaGlzIGF0dHJpYnV0ZSBpcyBvbmx5IGZpbGxlZCBpZiBhIHNlcnZpY2Ugb3JcbiAqICAgICBuZXR3b3JraW5nIGVycm9yIG9jY3Vycy5cbiAqICAgQHJldHVybiBbRXJyb3JdXG4gKiAgICAgKiBjb2RlIFtTdHJpbmddIGEgdW5pcXVlIHNob3J0IGNvZGUgcmVwcmVzZW50aW5nIHRoZVxuICogICAgICAgZXJyb3IgdGhhdCB3YXMgZW1pdHRlZC5cbiAqICAgICAqIG1lc3NhZ2UgW1N0cmluZ10gYSBsb25nZXIgaHVtYW4gcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuICogICAgICogcmV0cnlhYmxlIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gKiAgICAgICByZXRyeWFibGUuXG4gKiAgICAgKiBzdGF0dXNDb2RlIFtOdW1lcmljXSBpbiB0aGUgY2FzZSBvZiBhIHJlcXVlc3QgdGhhdCByZWFjaGVkIHRoZSBzZXJ2aWNlLFxuICogICAgICAgdGhpcyB2YWx1ZSBjb250YWlucyB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gKiAgICAgKiB0aW1lIFtEYXRlXSB0aGUgZGF0ZSB0aW1lIG9iamVjdCB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAqICAgICAqIGhvc3RuYW1lIFtTdHJpbmddIHNldCB3aGVuIGEgbmV0d29ya2luZyBlcnJvciBvY2N1cnMgdG8gZWFzaWx5XG4gKiAgICAgICBpZGVudGlmeSB0aGUgZW5kcG9pbnQgb2YgdGhlIHJlcXVlc3QuXG4gKiAgICAgKiByZWdpb24gW1N0cmluZ10gc2V0IHdoZW4gYSBuZXR3b3JraW5nIGVycm9yIG9jY3VycyB0byBlYXNpbHlcbiAqICAgICAgIGlkZW50aWZ5IHRoZSByZWdpb24gb2YgdGhlIHJlcXVlc3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVxdWVzdElkXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSB1bmlxdWUgcmVxdWVzdCBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3BvbnNlLlxuICogICAgIExvZyB0aGlzIHZhbHVlIHdoZW4gZGVidWdnaW5nIHJlcXVlc3RzIGZvciBBV1Mgc3VwcG9ydC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZXRyeUNvdW50XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIE9wZXJhdGlvbiBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2YgcmV0cmllcyB0aGF0IHdlcmVcbiAqICAgICBhdHRlbXB0ZWQgYmVmb3JlIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmVkaXJlY3RDb3VudFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBPcGVyYXRpb24gUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHJlZGlyZWN0cyB0aGF0IHdlcmVcbiAqICAgICBmb2xsb3dlZCBiZWZvcmUgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwUmVzcG9uc2VcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgSFRUUCBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0FXUy5IdHRwUmVzcG9uc2VdIHRoZSByYXcgSFRUUCByZXNwb25zZSBvYmplY3RcbiAqICAgICBjb250YWluaW5nIHRoZSByZXNwb25zZSBoZWFkZXJzIGFuZCBib2R5IGluZm9ybWF0aW9uXG4gKiAgICAgZnJvbSB0aGUgc2VydmVyLlxuICpcbiAqIEBzZWUgQVdTLlJlcXVlc3RcbiAqL1xuQVdTLlJlc3BvbnNlID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLnJlZGlyZWN0Q291bnQgPSAwO1xuICAgIHRoaXMuaHR0cFJlc3BvbnNlID0gbmV3IEFXUy5IdHRwUmVzcG9uc2UoKTtcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcmVxdWVzdC5zZXJ2aWNlLm51bVJldHJpZXMoKTtcbiAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5tYXhSZWRpcmVjdHM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2Ugb2YgcmVzcG9uc2UgZGF0YSwgY2FsbGluZyB0aGVcbiAgICogY2FsbGJhY2sgd2l0aCB0aGUgcGFnZSBkYXRhIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQ2FsbGVkIHdoZW4gYSBwYWdlIG9mIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgbmV4dCByZXF1ZXN0LlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvYmplY3QsIGlmIGFuIGVycm9yIG9jY3VycmVkIGluIHRoZSByZXF1ZXN0XG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIG5leHQgcGFnZSBvZiBkYXRhLCBvciBudWxsLCBpZiB0aGVyZSBhcmUgbm9cbiAgICogICAgIG1vcmUgcGFnZXMgbGVmdC5cbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIG5leHQgcGFnZSBvZiBkYXRhXG4gICAqIEByZXR1cm4gW251bGxdIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGFuZCB0aGVyZSBhcmUgbm8gcGFnZXMgbGVmdFxuICAgKiAgIHRvIHJldHJpZXZlLlxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBuZXh0UGFnZTogZnVuY3Rpb24gbmV4dFBhZ2UoY2FsbGJhY2spIHtcbiAgICB2YXIgY29uZmlnO1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcy5yZXF1ZXN0LnNlcnZpY2U7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMucmVxdWVzdC5vcGVyYXRpb247XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IHNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyhvcGVyYXRpb24sIHRydWUpO1xuICAgIH0gY2F0Y2ggKGUpIHsgdGhpcy5lcnJvciA9IGU7IH1cblxuICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMuZXJyb3IsIG51bGwpO1xuICAgICAgZWxzZSBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHRoaXMucmVxdWVzdC5wYXJhbXMpO1xuICAgIGlmICghdGhpcy5uZXh0UGFnZVRva2Vucykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2sobnVsbCwgbnVsbCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5wdXRUb2tlbnMgPSBjb25maWcuaW5wdXRUb2tlbjtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXRUb2tlbnMgPT09ICdzdHJpbmcnKSBpbnB1dFRva2VucyA9IFtpbnB1dFRva2Vuc107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0VG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcmFtc1tpbnB1dFRva2Vuc1tpXV0gPSB0aGlzLm5leHRQYWdlVG9rZW5zW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcnZpY2UubWFrZVJlcXVlc3QodGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIG1vcmUgcGFnZXMgb2YgZGF0YSBjYW4gYmUgcmV0dXJuZWQgYnkgZnVydGhlclxuICAgKiAgIHJlcXVlc3RzXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGhhc05leHRQYWdlOiBmdW5jdGlvbiBoYXNOZXh0UGFnZSgpIHtcbiAgICB0aGlzLmNhY2hlTmV4dFBhZ2VUb2tlbnMoKTtcbiAgICBpZiAodGhpcy5uZXh0UGFnZVRva2VucykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMubmV4dFBhZ2VUb2tlbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWNoZU5leHRQYWdlVG9rZW5zOiBmdW5jdGlvbiBjYWNoZU5leHRQYWdlVG9rZW5zKCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ25leHRQYWdlVG9rZW5zJykpIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29uZmlnID0gdGhpcy5yZXF1ZXN0LnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyh0aGlzLnJlcXVlc3Qub3BlcmF0aW9uKTtcbiAgICBpZiAoIWNvbmZpZykgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG5cbiAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gbnVsbDtcbiAgICBpZiAoY29uZmlnLm1vcmVSZXN1bHRzKSB7XG4gICAgICBpZiAoIWptZXNwYXRoLnNlYXJjaCh0aGlzLmRhdGEsIGNvbmZpZy5tb3JlUmVzdWx0cykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VUb2tlbnM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4cHJzID0gY29uZmlnLm91dHB1dFRva2VuO1xuICAgIGlmICh0eXBlb2YgZXhwcnMgPT09ICdzdHJpbmcnKSBleHBycyA9IFtleHByc107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgZXhwcnMsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gam1lc3BhdGguc2VhcmNoKHRoaXMuZGF0YSwgZXhwcik7XG4gICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgIHRoaXMubmV4dFBhZ2VUb2tlbnMgPSB0aGlzLm5leHRQYWdlVG9rZW5zIHx8IFtdO1xuICAgICAgICB0aGlzLm5leHRQYWdlVG9rZW5zLnB1c2gob3V0cHV0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICB9XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzcG9uc2UuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuIFlvdVxuICogbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIEEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICpcbiAqICAgICBodHRwOi8vYXdzLmFtYXpvbi5jb20vYXBhY2hlMi4wL1xuICpcbiAqIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpc1xuICogZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENIRUNLX0FDQ0VQVE9SUyhyZXNwKSB7XG4gIHZhciB3YWl0ZXIgPSByZXNwLnJlcXVlc3QuX3dhaXRlcjtcbiAgdmFyIGFjY2VwdG9ycyA9IHdhaXRlci5jb25maWcuYWNjZXB0b3JzO1xuICB2YXIgYWNjZXB0b3JNYXRjaGVkID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9ICdyZXRyeSc7XG5cbiAgYWNjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24oYWNjZXB0b3IpIHtcbiAgICBpZiAoIWFjY2VwdG9yTWF0Y2hlZCkge1xuICAgICAgdmFyIG1hdGNoZXIgPSB3YWl0ZXIubWF0Y2hlcnNbYWNjZXB0b3IubWF0Y2hlcl07XG4gICAgICBpZiAobWF0Y2hlciAmJiBtYXRjaGVyKHJlc3AsIGFjY2VwdG9yLmV4cGVjdGVkLCBhY2NlcHRvci5hcmd1bWVudCkpIHtcbiAgICAgICAgYWNjZXB0b3JNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUgPSBhY2NlcHRvci5zdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWNjZXB0b3JNYXRjaGVkICYmIHJlc3AuZXJyb3IpIHN0YXRlID0gJ2ZhaWx1cmUnO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgd2FpdGVyLnNldFN1Y2Nlc3MocmVzcCk7XG4gIH0gZWxzZSB7XG4gICAgd2FpdGVyLnNldEVycm9yKHJlc3AsIHN0YXRlID09PSAncmV0cnknKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVzb3VyY2VXYWl0ZXIgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlIG9uIGEgc2VydmljZSBvYmplY3RcbiAgICogQHBhcmFtIHNlcnZpY2UgW1NlcnZpY2VdIHRoZSBzZXJ2aWNlIG9iamVjdCB0byB3YWl0IG9uXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgKGRlZmluZWQgaW4gd2FpdGVyIGNvbmZpZ3VyYXRpb24pIHRvIHdhaXRcbiAgICogICBmb3IuXG4gICAqIEBleGFtcGxlIENyZWF0ZSBhIHdhaXRlciBmb3IgcnVubmluZyBFQzIgaW5zdGFuY2VzXG4gICAqICAgdmFyIGVjMiA9IG5ldyBBV1MuRUMyO1xuICAgKiAgIHZhciB3YWl0ZXIgPSBuZXcgQVdTLlJlc291cmNlV2FpdGVyKGVjMiwgJ2luc3RhbmNlUnVubmluZycpO1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHN0YXRlKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb2FkV2FpdGVyQ29uZmlnKHRoaXMuc3RhdGUpO1xuICB9LFxuXG4gIHNlcnZpY2U6IG51bGwsXG5cbiAgc3RhdGU6IG51bGwsXG5cbiAgY29uZmlnOiBudWxsLFxuXG4gIG1hdGNoZXJzOiB7XG4gICAgcGF0aDogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHQsZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBwYXRoQWxsOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCwgYXJndW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgICAgdmFyIG51bVJlc3VsdHMgPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgIGlmICghbnVtUmVzdWx0cykgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaW5kID0gMCA7IGluZCA8IG51bVJlc3VsdHM7IGluZCsrKSB7XG4gICAgICAgIGlmICgham1lc3BhdGguc3RyaWN0RGVlcEVxdWFsKHJlc3VsdHNbaW5kXSwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcGF0aEFueTogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgIHZhciBudW1SZXN1bHRzID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpbmQgPSAwIDsgaW5kIDwgbnVtUmVzdWx0czsgaW5kKyspIHtcbiAgICAgICAgaWYgKGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHRzW2luZF0sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHN0YXR1czogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIHJldHVybiAodHlwZW9mIHN0YXR1c0NvZGUgPT09ICdudW1iZXInKSAmJiAoc3RhdHVzQ29kZSA9PT0gZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHJlc3AuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSByZXNwLmVycm9yLmNvZGU7XG4gICAgICB9XG4gICAgICAvLyBpZiBleHBlY3RlZCBpcyBub3Qgc3RyaW5nLCBjYW4gYmUgYm9vbGVhbiBpbmRpY2F0aW5nIHByZXNlbmNlIG9mIGVycm9yXG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09ICEhcmVzcC5lcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbihyZXNwKSB7XG4gICAgICB2YXIgd2FpdGVyID0gcmVzcC5yZXF1ZXN0Ll93YWl0ZXI7XG4gICAgICBpZiAocmVzcC5lcnJvciAmJiByZXNwLmVycm9yLmNvZGUgPT09ICdSZXNvdXJjZU5vdFJlYWR5Jykge1xuICAgICAgICByZXNwLmVycm9yLnJldHJ5RGVsYXkgPSAod2FpdGVyLmNvbmZpZy5kZWxheSB8fCAwKSAqIDEwMDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NIRUNLX09VVFBVVCcsICdleHRyYWN0RGF0YScsIENIRUNLX0FDQ0VQVE9SUyk7XG5cbiAgICBhZGQoJ0NIRUNLX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIENIRUNLX0FDQ0VQVE9SUyk7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF1cbiAgICovXG4gIHdhaXQ6IGZ1bmN0aW9uIHdhaXQocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtczsgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLiR3YWl0ZXIpIHtcbiAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLiR3YWl0ZXIuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGF5ID0gcGFyYW1zLiR3YWl0ZXIuZGVsYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhBdHRlbXB0cyA9IHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHBhcmFtcy4kd2FpdGVyO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KHRoaXMuY29uZmlnLm9wZXJhdGlvbiwgcGFyYW1zKTtcbiAgICByZXF1ZXN0Ll93YWl0ZXIgPSB0aGlzO1xuICAgIHJlcXVlc3QucmVzcG9uc2UubWF4UmV0cmllcyA9IHRoaXMuY29uZmlnLm1heEF0dGVtcHRzO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzKTtcblxuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICBzZXRTdWNjZXNzOiBmdW5jdGlvbiBzZXRTdWNjZXNzKHJlc3ApIHtcbiAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICByZXNwLmRhdGEgPSByZXNwLmRhdGEgfHwge307XG4gICAgcmVzcC5yZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygnZXh0cmFjdERhdGEnKTtcbiAgfSxcblxuICBzZXRFcnJvcjogZnVuY3Rpb24gc2V0RXJyb3IocmVzcCwgcmV0cnlhYmxlKSB7XG4gICAgcmVzcC5kYXRhID0gbnVsbDtcbiAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IocmVzcC5lcnJvciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ1Jlc291cmNlTm90UmVhZHknLFxuICAgICAgbWVzc2FnZTogJ1Jlc291cmNlIGlzIG5vdCBpbiB0aGUgc3RhdGUgJyArIHRoaXMuc3RhdGUsXG4gICAgICByZXRyeWFibGU6IHJldHJ5YWJsZVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyB3YWl0ZXIgY29uZmlndXJhdGlvbiBmcm9tIEFQSSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFdhaXRlckNvbmZpZzogZnVuY3Rpb24gbG9hZFdhaXRlckNvbmZpZyhzdGF0ZSkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlLmFwaS53YWl0ZXJzW3N0YXRlXSkge1xuICAgICAgdGhyb3cgbmV3IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdTdGF0ZU5vdEZvdW5kRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnU3RhdGUgJyArIHN0YXRlICsgJyBub3QgZm91bmQuJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSBBV1MudXRpbC5jb3B5KHRoaXMuc2VydmljZS5hcGkud2FpdGVyc1tzdGF0ZV0pO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Jlc291cmNlX3dhaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyID0gaW5oZXJpdCh7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXF1ZXN0U2lnbmVyKHJlcXVlc3QpIHtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB9LFxuXG4gIHNldFNlcnZpY2VDbGllbnRJZDogZnVuY3Rpb24gc2V0U2VydmljZUNsaWVudElkKGlkKSB7XG4gICAgdGhpcy5zZXJ2aWNlQ2xpZW50SWQgPSBpZDtcbiAgfSxcblxuICBnZXRTZXJ2aWNlQ2xpZW50SWQ6IGZ1bmN0aW9uIGdldFNlcnZpY2VDbGllbnRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlQ2xpZW50SWQ7XG4gIH1cbn0pO1xuXG5BV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24gPSBmdW5jdGlvbiBnZXRWZXJzaW9uKHZlcnNpb24pIHtcbiAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAndjInOiByZXR1cm4gQVdTLlNpZ25lcnMuVjI7XG4gICAgY2FzZSAndjMnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjM7XG4gICAgY2FzZSAndjQnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjQ7XG4gICAgY2FzZSAnczMnOiByZXR1cm4gQVdTLlNpZ25lcnMuUzM7XG4gICAgY2FzZSAndjNodHRwcyc6IHJldHVybiBBV1MuU2lnbmVycy5WM0h0dHBzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduaW5nIHZlcnNpb24gJyArIHZlcnNpb24pO1xufTtcblxucmVxdWlyZSgnLi92MicpO1xucmVxdWlyZSgnLi92MycpO1xucmVxdWlyZSgnLi92M2h0dHBzJyk7XG5yZXF1aXJlKCcuL3Y0Jyk7XG5yZXF1aXJlKCcuL3MzJyk7XG5yZXF1aXJlKCcuL3ByZXNpZ24nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvcmVxdWVzdF9zaWduZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYyID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcblxuICAgIGlmICghZGF0ZSkgZGF0ZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICByLnBhcmFtcy5UaW1lc3RhbXAgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEoZGF0ZSk7XG4gICAgci5wYXJhbXMuU2lnbmF0dXJlVmVyc2lvbiA9ICcyJztcbiAgICByLnBhcmFtcy5TaWduYXR1cmVNZXRob2QgPSAnSG1hY1NIQTI1Nic7XG4gICAgci5wYXJhbXMuQVdTQWNjZXNzS2V5SWQgPSBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHIucGFyYW1zLlNlY3VyaXR5VG9rZW4gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgZGVsZXRlIHIucGFyYW1zLlNpZ25hdHVyZTsgLy8gZGVsZXRlIG9sZCBTaWduYXR1cmUgZm9yIHJlLXNpZ25pbmdcbiAgICByLnBhcmFtcy5TaWduYXR1cmUgPSB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscyk7XG5cbiAgICByLmJvZHkgPSBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHIucGFyYW1zKTtcbiAgICByLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSByLmJvZHkubGVuZ3RoO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSwgJ2Jhc2U2NCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QuZW5kcG9pbnQuaG9zdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5wYXRobmFtZSgpKTtcbiAgICBwYXJ0cy5wdXNoKEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcodGhpcy5yZXF1ZXN0LnBhcmFtcykpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WMjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjIuanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbnJlcXVpcmUoJy4vdjMnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjNIdHRwcyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuVjMsIHtcbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMy1IVFRQUyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WM0h0dHBzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92M2h0dHBzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIHY0Q3JlZGVudGlhbHMgPSByZXF1aXJlKCcuL3Y0X2NyZWRlbnRpYWxzJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBleHBpcmVzSGVhZGVyID0gJ3ByZXNpZ25lZC1leHBpcmVzJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjQgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFY0KHJlcXVlc3QsIHNlcnZpY2VOYW1lLCBvcHRpb25zKSB7XG4gICAgQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5jYWxsKHRoaXMsIHJlcXVlc3QpO1xuICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNpZ25hdHVyZUNhY2hlID0gdHlwZW9mIG9wdGlvbnMuc2lnbmF0dXJlQ2FjaGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2lnbmF0dXJlQ2FjaGUgOiB0cnVlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3B0aW9ucy5vcGVyYXRpb247XG4gIH0sXG5cbiAgYWxnb3JpdGhtOiAnQVdTNC1ITUFDLVNIQTI1NicsXG5cbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuICAgIHZhciBkYXRldGltZSA9IEFXUy51dGlsLmRhdGUuaXNvODYwMShkYXRlKS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKTtcblxuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPVxuICAgICAgdGhpcy5hdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gIH0sXG5cbiAgYWRkSGVhZGVyczogZnVuY3Rpb24gYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gZGF0ZXRpbWU7XG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUZvclByZXNpZ25lZDogZnVuY3Rpb24gdXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICB2YXIgcXMgPSB7XG4gICAgICAnWC1BbXotRGF0ZSc6IGRhdGV0aW1lLFxuICAgICAgJ1gtQW16LUFsZ29yaXRobSc6IHRoaXMuYWxnb3JpdGhtLFxuICAgICAgJ1gtQW16LUNyZWRlbnRpYWwnOiBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIGNyZWRTdHJpbmcsXG4gICAgICAnWC1BbXotRXhwaXJlcyc6IHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdLFxuICAgICAgJ1gtQW16LVNpZ25lZEhlYWRlcnMnOiB0aGlzLnNpZ25lZEhlYWRlcnMoKVxuICAgIH07XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICBxc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICBxc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXSkge1xuICAgICAgcXNbJ0NvbnRlbnQtTUQ1J10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWNoZS1Db250cm9sJ10pIHtcbiAgICAgIHFzWydDYWNoZS1Db250cm9sJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FjaGUtQ29udHJvbCddO1xuICAgIH1cblxuICAgIC8vIG5lZWQgdG8gcHVsbCBpbiBhbnkgb3RoZXIgWC1BbXotKiBoZWFkZXJzXG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIGxvd2VyS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIE1ldGFkYXRhIHNob3VsZCBiZSBub3JtYWxpemVkXG4gICAgICAgIGlmIChsb3dlcktleS5pbmRleE9mKCd4LWFtei1tZXRhLScpID09PSAwKSB7XG4gICAgICAgICAgcXNbbG93ZXJLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobG93ZXJLZXkuaW5kZXhPZigneC1hbXotJykgPT09IDApIHtcbiAgICAgICAgICBxc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzZXAgPSB0aGlzLnJlcXVlc3QucGF0aC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JztcbiAgICB0aGlzLnJlcXVlc3QucGF0aCArPSBzZXAgKyBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHFzKTtcbiAgfSxcblxuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuYWxnb3JpdGhtICsgJyBDcmVkZW50aWFsPScgK1xuICAgICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBjcmVkU3RyaW5nKTtcbiAgICBwYXJ0cy5wdXNoKCdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCgnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLCAnKTtcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB2YXIgc2lnbmluZ0tleSA9IHY0Q3JlZGVudGlhbHMuZ2V0U2lnbmluZ0tleShcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWUsXG4gICAgICB0aGlzLnNpZ25hdHVyZUNhY2hlXG4gICAgKTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoc2lnbmluZ0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oZGF0ZXRpbWUpLCAnaGV4Jyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oZGF0ZXRpbWUpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKCdBV1M0LUhNQUMtU0hBMjU2Jyk7XG4gICAgcGFydHMucHVzaChkYXRldGltZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuaGV4RW5jb2RlZEhhc2godGhpcy5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxTdHJpbmc6IGZ1bmN0aW9uIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICB2YXIgcGFydHMgPSBbXSwgcGF0aG5hbWUgPSB0aGlzLnJlcXVlc3QucGF0aG5hbWUoKTtcbiAgICBpZiAodGhpcy5zZXJ2aWNlTmFtZSAhPT0gJ3MzJykgcGF0aG5hbWUgPSBBV1MudXRpbC51cmlFc2NhcGVQYXRoKHBhdGhuYW1lKTtcblxuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaChwYXRobmFtZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3Quc2VhcmNoKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxIZWFkZXJzKCkgKyAnXFxuJyk7XG4gICAgcGFydHMucHVzaCh0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmhleEVuY29kZWRCb2R5SGFzaCgpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgaXRlbSkge1xuICAgICAgaGVhZGVycy5wdXNoKFtrZXksIGl0ZW1dKTtcbiAgICB9KTtcbiAgICBoZWFkZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdLnRvTG93ZXJDYXNlKCkgPCBiWzBdLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgaGVhZGVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBpdGVtWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbVsxXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdIZWFkZXIgJyArIGtleSArICcgY29udGFpbnMgaW52YWxpZCB2YWx1ZScpLCB7XG4gICAgICAgICAgICBjb2RlOiAnSW52YWxpZEhlYWRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGtleSArICc6JyArXG4gICAgICAgICAgdGhpcy5jYW5vbmljYWxIZWFkZXJWYWx1ZXModmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJWYWx1ZXM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlclZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH0sXG5cbiAgc2lnbmVkSGVhZGVyczogZnVuY3Rpb24gc2lnbmVkSGVhZGVycygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBrZXlzLnNvcnQoKS5qb2luKCc7Jyk7XG4gIH0sXG5cbiAgY3JlZGVudGlhbFN0cmluZzogZnVuY3Rpb24gY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSkge1xuICAgIHJldHVybiB2NENyZWRlbnRpYWxzLmNyZWF0ZVNjb3BlKFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWVcbiAgICApO1xuICB9LFxuXG4gIGhleEVuY29kZWRIYXNoOiBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uc2hhMjU2KHN0cmluZywgJ2hleCcpO1xuICB9LFxuXG4gIGhleEVuY29kZWRCb2R5SGFzaDogZnVuY3Rpb24gaGV4RW5jb2RlZEJvZHlIYXNoKCkge1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0O1xuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkgJiYgdGhpcy5zZXJ2aWNlTmFtZSA9PT0gJ3MzJyAmJiAhcmVxdWVzdC5ib2R5KSB7XG4gICAgICByZXR1cm4gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oZXhFbmNvZGVkSGFzaCh0aGlzLnJlcXVlc3QuYm9keSB8fCAnJyk7XG4gICAgfVxuICB9LFxuXG4gIHVuc2lnbmFibGVIZWFkZXJzOiBbXG4gICAgJ2F1dGhvcml6YXRpb24nLFxuICAgICdjb250ZW50LXR5cGUnLFxuICAgICdjb250ZW50LWxlbmd0aCcsXG4gICAgJ3VzZXItYWdlbnQnLFxuICAgIGV4cGlyZXNIZWFkZXIsXG4gICAgJ2V4cGVjdCcsXG4gICAgJ3gtYW16bi10cmFjZS1pZCdcbiAgXSxcblxuICBpc1NpZ25hYmxlSGVhZGVyOiBmdW5jdGlvbiBpc1NpZ25hYmxlSGVhZGVyKGtleSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd4LWFtei0nKSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduYWJsZUhlYWRlcnMuaW5kZXhPZihrZXkpIDwgMDtcbiAgfSxcblxuICBpc1ByZXNpZ25lZDogZnVuY3Rpb24gaXNQcmVzaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlY0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92NC5qc1xuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUzMgPSBpbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgLyoqXG4gICAqIFdoZW4gYnVpbGRpbmcgdGhlIHN0cmluZ1RvU2lnbiwgdGhlc2Ugc3ViIHJlc291cmNlIHBhcmFtcyBzaG91bGQgYmVcbiAgICogcGFydCBvZiB0aGUgY2Fub25pY2FsIHJlc291cmNlIHN0cmluZyB3aXRoIHRoZWlyIE5PTi1kZWNvZGVkIHZhbHVlc1xuICAgKi9cbiAgc3ViUmVzb3VyY2VzOiB7XG4gICAgJ2FjbCc6IDEsXG4gICAgJ2FjY2VsZXJhdGUnOiAxLFxuICAgICdhbmFseXRpY3MnOiAxLFxuICAgICdjb3JzJzogMSxcbiAgICAnbGlmZWN5Y2xlJzogMSxcbiAgICAnZGVsZXRlJzogMSxcbiAgICAnaW52ZW50b3J5JzogMSxcbiAgICAnbG9jYXRpb24nOiAxLFxuICAgICdsb2dnaW5nJzogMSxcbiAgICAnbWV0cmljcyc6IDEsXG4gICAgJ25vdGlmaWNhdGlvbic6IDEsXG4gICAgJ3BhcnROdW1iZXInOiAxLFxuICAgICdwb2xpY3knOiAxLFxuICAgICdyZXF1ZXN0UGF5bWVudCc6IDEsXG4gICAgJ3JlcGxpY2F0aW9uJzogMSxcbiAgICAncmVzdG9yZSc6IDEsXG4gICAgJ3RhZ2dpbmcnOiAxLFxuICAgICd0b3JyZW50JzogMSxcbiAgICAndXBsb2FkSWQnOiAxLFxuICAgICd1cGxvYWRzJzogMSxcbiAgICAndmVyc2lvbklkJzogMSxcbiAgICAndmVyc2lvbmluZyc6IDEsXG4gICAgJ3ZlcnNpb25zJzogMSxcbiAgICAnd2Vic2l0ZSc6IDFcbiAgfSxcblxuICAvLyB3aGVuIGJ1aWxkaW5nIHRoZSBzdHJpbmdUb1NpZ24sIHRoZXNlIHF1ZXJ5c3RyaW5nIHBhcmFtcyBzaG91bGQgYmVcbiAgLy8gcGFydCBvZiB0aGUgY2Fub25pY2FsIHJlc291cmNlIHN0cmluZyB3aXRoIHRoZWlyIE5PTi1lbmNvZGVkIHZhbHVlc1xuICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAncmVzcG9uc2UtY29udGVudC10eXBlJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1sYW5ndWFnZSc6IDEsXG4gICAgJ3Jlc3BvbnNlLWV4cGlyZXMnOiAxLFxuICAgICdyZXNwb25zZS1jYWNoZS1jb250cm9sJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvbic6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtZW5jb2RpbmcnOiAxXG4gIH0sXG5cbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuICAgIGlmICghdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3ByZXNpZ25lZC1leHBpcmVzJ10pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBBV1MudXRpbC5kYXRlLnJmYzgyMihkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICAvLyBwcmVzaWduZWQgVVJMcyByZXF1aXJlIHRoaXMgaGVhZGVyIHRvIGJlIGxvd2VyY2FzZWRcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnNpZ24oY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCB0aGlzLnN0cmluZ1RvU2lnbigpKTtcbiAgICB2YXIgYXV0aCA9ICdBV1MgJyArIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJzonICsgc2lnbmF0dXJlO1xuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGF1dGg7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oKSB7XG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHIubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1snQ29udGVudC1NRDUnXSB8fCAnJyk7XG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8ICcnKTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIFwiRGF0ZVwiIGhlYWRlciwgYnV0IHdlIHVzZSBYLUFtei1EYXRlLlxuICAgIC8vIFRoZSBTMyBzaWduaW5nIG1lY2hhbmlzbSByZXF1aXJlcyB1cyB0byBwYXNzIGFuIGVtcHR5XG4gICAgLy8gc3RyaW5nIGZvciB0aGlzIERhdGUgaGVhZGVyIHJlZ2FyZGxlc3MuXG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ3ByZXNpZ25lZC1leHBpcmVzJ10gfHwgJycpO1xuXG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLmNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzKCk7XG4gICAgaWYgKGhlYWRlcnMpIHBhcnRzLnB1c2goaGVhZGVycyk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNhbm9uaWNhbGl6ZWRSZXNvdXJjZSgpKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcblxuICB9LFxuXG4gIGNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzOiBmdW5jdGlvbiBjYW5vbmljYWxpemVkQW16SGVhZGVycygpIHtcblxuICAgIHZhciBhbXpIZWFkZXJzID0gW107XG5cbiAgICBBV1MudXRpbC5lYWNoKHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUubWF0Y2goL154LWFtei0vaSkpXG4gICAgICAgIGFtekhlYWRlcnMucHVzaChuYW1lKTtcbiAgICB9KTtcblxuICAgIGFtekhlYWRlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEudG9Mb3dlckNhc2UoKSA8IGIudG9Mb3dlckNhc2UoKSA/IC0xIDogMTtcbiAgICB9KTtcblxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIGFtekhlYWRlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwYXJ0cy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSArICc6JyArIFN0cmluZyh0aGlzLnJlcXVlc3QuaGVhZGVyc1tuYW1lXSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuXG4gIH0sXG5cbiAgY2Fub25pY2FsaXplZFJlc291cmNlOiBmdW5jdGlvbiBjYW5vbmljYWxpemVkUmVzb3VyY2UoKSB7XG5cbiAgICB2YXIgciA9IHRoaXMucmVxdWVzdDtcblxuICAgIHZhciBwYXJ0cyA9IHIucGF0aC5zcGxpdCgnPycpO1xuICAgIHZhciBwYXRoID0gcGFydHNbMF07XG4gICAgdmFyIHF1ZXJ5c3RyaW5nID0gcGFydHNbMV07XG5cbiAgICB2YXIgcmVzb3VyY2UgPSAnJztcblxuICAgIGlmIChyLnZpcnR1YWxIb3N0ZWRCdWNrZXQpXG4gICAgICByZXNvdXJjZSArPSAnLycgKyByLnZpcnR1YWxIb3N0ZWRCdWNrZXQ7XG5cbiAgICByZXNvdXJjZSArPSBwYXRoO1xuXG4gICAgaWYgKHF1ZXJ5c3RyaW5nKSB7XG5cbiAgICAgIC8vIGNvbGxlY3QgYSBsaXN0IG9mIHN1YiByZXNvdXJjZXMgYW5kIHF1ZXJ5IHBhcmFtcyB0aGF0IG5lZWQgdG8gYmUgc2lnbmVkXG4gICAgICB2YXIgcmVzb3VyY2VzID0gW107XG5cbiAgICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIHF1ZXJ5c3RyaW5nLnNwbGl0KCcmJyksIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcmFtLnNwbGl0KCc9JylbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnNwbGl0KCc9JylbMV07XG4gICAgICAgIGlmICh0aGlzLnN1YlJlc291cmNlc1tuYW1lXSB8fCB0aGlzLnJlc3BvbnNlSGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgIHZhciBzdWJyZXNvdXJjZSA9IHsgbmFtZTogbmFtZSB9O1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJSZXNvdXJjZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgc3VicmVzb3VyY2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YnJlc291cmNlLnZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb3VyY2VzLnB1c2goc3VicmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVzb3VyY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubmFtZSA8IGIubmFtZSA/IC0xIDogMTsgfSk7XG5cbiAgICAgIGlmIChyZXNvdXJjZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgcXVlcnlzdHJpbmcgPSBbXTtcbiAgICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKHJlc291cmNlcywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIGlmIChyZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlzdHJpbmcucHVzaChyZXMubmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnB1c2gocmVzLm5hbWUgKyAnPScgKyByZXMudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzb3VyY2UgKz0gJz8nICsgcXVlcnlzdHJpbmcuam9pbignJicpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc291cmNlO1xuXG4gIH0sXG5cbiAgc2lnbjogZnVuY3Rpb24gc2lnbihzZWNyZXQsIHN0cmluZykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhzZWNyZXQsIHN0cmluZywgJ2Jhc2U2NCcsICdzaGExJyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlMzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy9zMy5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGV4cGlyZXNIZWFkZXIgPSAncHJlc2lnbmVkLWV4cGlyZXMnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaWduZWRVcmxCdWlsZGVyKHJlcXVlc3QpIHtcbiAgdmFyIGV4cGlyZXMgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl07XG4gIHZhciBzaWduZXJDbGFzcyA9IHJlcXVlc3Quc2VydmljZS5nZXRTaWduZXJDbGFzcyhyZXF1ZXN0KTtcblxuICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydVc2VyLUFnZW50J107XG4gIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVVzZXItQWdlbnQnXTtcblxuICBpZiAoc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgaWYgKGV4cGlyZXMgPiA2MDQ4MDApIHsgLy8gb25lIHdlZWsgZXhwaXJ5IGlzIGludmFsaWRcbiAgICAgIHZhciBtZXNzYWdlID0gJ1ByZXNpZ25pbmcgZG9lcyBub3Qgc3VwcG9ydCBleHBpcnkgdGltZSBncmVhdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhhbiBhIHdlZWsgd2l0aCBTaWdWNCBzaWduaW5nLic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEV4cGlyeVRpbWUnLCBtZXNzYWdlOiBtZXNzYWdlLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gZXhwaXJlcztcbiAgfSBlbHNlIGlmIChzaWduZXJDbGFzcyA9PT0gQVdTLlNpZ25lcnMuUzMpIHtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBwYXJzZUludChcbiAgICAgIEFXUy51dGlsLmRhdGUudW5peFRpbWVzdGFtcCgpICsgZXhwaXJlcywgMTApLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIG1lc3NhZ2U6ICdQcmVzaWduaW5nIG9ubHkgc3VwcG9ydHMgUzMgb3IgU2lnVjQgc2lnbmluZy4nLFxuICAgICAgY29kZTogJ1Vuc3VwcG9ydGVkU2lnbmVyJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZFVybFNpZ25lcihyZXF1ZXN0KSB7XG4gIHZhciBlbmRwb2ludCA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gIHZhciBwYXJzZWRVcmwgPSBBV1MudXRpbC51cmxQYXJzZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGgpO1xuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcblxuICBpZiAocGFyc2VkVXJsLnNlYXJjaCkge1xuICAgIHF1ZXJ5UGFyYW1zID0gQVdTLnV0aWwucXVlcnlTdHJpbmdQYXJzZShwYXJzZWRVcmwuc2VhcmNoLnN1YnN0cigxKSk7XG4gIH1cblxuICBBV1MudXRpbC5lYWNoKHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSBrZXkgPSAnRXhwaXJlcyc7XG4gICAgaWYgKGtleS5pbmRleE9mKCd4LWFtei1tZXRhLScpID09PSAwKSB7XG4gICAgICAvLyBEZWxldGUgZXhpc3RpbmcsIHBvdGVudGlhbGx5IG5vdCBub3JtYWxpemVkIGtleVxuICAgICAgZGVsZXRlIHF1ZXJ5UGFyYW1zW2tleV07XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXTtcblxuICB2YXIgYXV0aCA9IHF1ZXJ5UGFyYW1zWydBdXRob3JpemF0aW9uJ10uc3BsaXQoJyAnKTtcbiAgaWYgKGF1dGhbMF0gPT09ICdBV1MnKSB7XG4gICAgYXV0aCA9IGF1dGhbMV0uc3BsaXQoJzonKTtcbiAgICBxdWVyeVBhcmFtc1snQVdTQWNjZXNzS2V5SWQnXSA9IGF1dGhbMF07XG4gICAgcXVlcnlQYXJhbXNbJ1NpZ25hdHVyZSddID0gYXV0aFsxXTtcbiAgfSBlbHNlIGlmIChhdXRoWzBdID09PSAnQVdTNC1ITUFDLVNIQTI1NicpIHsgLy8gU2lnVjQgc2lnbmluZ1xuICAgIGF1dGguc2hpZnQoKTtcbiAgICB2YXIgcmVzdCA9IGF1dGguam9pbignICcpO1xuICAgIHZhciBzaWduYXR1cmUgPSByZXN0Lm1hdGNoKC9TaWduYXR1cmU9KC4qPykoPzosfFxcc3xcXHI/XFxufCQpLylbMV07XG4gICAgcXVlcnlQYXJhbXNbJ1gtQW16LVNpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1snRXhwaXJlcyddO1xuICB9XG4gIGRlbGV0ZSBxdWVyeVBhcmFtc1snQXV0aG9yaXphdGlvbiddO1xuICBkZWxldGUgcXVlcnlQYXJhbXNbJ0hvc3QnXTtcblxuICAvLyBidWlsZCBVUkxcbiAgZW5kcG9pbnQucGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gIGVuZHBvaW50LnNlYXJjaCA9IEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXVlcnlQYXJhbXMpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5QcmVzaWduID0gaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNpZ246IGZ1bmN0aW9uIHNpZ24ocmVxdWVzdCwgZXhwaXJlVGltZSwgY2FsbGJhY2spIHtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBleHBpcmVUaW1lIHx8IDM2MDA7XG4gICAgcmVxdWVzdC5vbignYnVpbGQnLCBzaWduZWRVcmxCdWlsZGVyKTtcbiAgICByZXF1ZXN0Lm9uKCdzaWduJywgc2lnbmVkVXJsU2lnbmVyKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdhZnRlckJ1aWxkJyxcbiAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNFVF9DT05URU5UX0xFTkdUSCk7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX1NIQTI1Nik7XG5cbiAgICByZXF1ZXN0LmVtaXQoJ2JlZm9yZVByZXNpZ24nLCBbcmVxdWVzdF0pO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXF1ZXN0LmJ1aWxkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZS5lcnJvcikgY2FsbGJhY2sodGhpcy5yZXNwb25zZS5lcnJvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEFXUy51dGlsLnVybEZvcm1hdChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmJ1aWxkKCk7XG4gICAgICBpZiAocmVxdWVzdC5yZXNwb25zZS5lcnJvcikgdGhyb3cgcmVxdWVzdC5yZXNwb25zZS5lcnJvcjtcbiAgICAgIHJldHVybiBBV1MudXRpbC51cmxGb3JtYXQocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCk7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5QcmVzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy9wcmVzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5QYXJhbVZhbGlkYXRvciA9IEFXUy51dGlsLmluaGVyaXQoe1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHZhbGlkYXRvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB2YWxpZGF0aW9uIFtCb29sZWFufG1hcF0gd2hldGhlciBpbnB1dCBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgKiAgICAgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9wZXJhdGlvbiBkZXNjcmlwdGlvbiBiZWZvcmUgc2VuZGluZyB0aGVcbiAgICogICAgIHJlcXVlc3QuIFBhc3MgYSBtYXAgdG8gZW5hYmxlIGFueSBvZiB0aGUgZm9sbG93aW5nIHNwZWNpZmljXG4gICAqICAgICB2YWxpZGF0aW9uIGZlYXR1cmVzOlxuICAgKlxuICAgKiAgICAgKiAqKm1pbioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1pblxuICAgKiAgICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAgICogICAgICAgdG8gYHRydWVgLlxuICAgKiAgICAgKiAqKm1heCoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgdmFsdWUgbWVldHMgdGhlIG1heFxuICAgKiAgICAgICBjb25zdHJhaW50LlxuICAgKiAgICAgKiAqKnBhdHRlcm4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGFcbiAgICogICAgICAgcmVndWxhciBleHByZXNzaW9uLlxuICAgKiAgICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICAgKiAgICAgICBvZiB0aGUgYWxsb3dhYmxlIGVudW0gdmFsdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFBhcmFtVmFsaWRhdG9yKHZhbGlkYXRpb24pIHtcbiAgICBpZiAodmFsaWRhdGlvbiA9PT0gdHJ1ZSB8fCB2YWxpZGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRpb24gPSB7J21pbic6IHRydWV9O1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRpb24gPSB2YWxpZGF0aW9uO1xuICB9LFxuXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLCBwYXJhbXMgfHwge30sIGNvbnRleHQgfHwgJ3BhcmFtcycpO1xuXG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBtc2cgPSB0aGlzLmVycm9ycy5qb2luKCdcXG4qICcpO1xuICAgICAgbXNnID0gJ1RoZXJlIHdlcmUgJyArIHRoaXMuZXJyb3JzLmxlbmd0aCArXG4gICAgICAgICcgdmFsaWRhdGlvbiBlcnJvcnM6XFxuKiAnICsgbXNnO1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKG1zZyksXG4gICAgICAgIHtjb2RlOiAnTXVsdGlwbGVWYWxpZGF0aW9uRXJyb3JzJywgZXJyb3JzOiB0aGlzLmVycm9yc30pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGZhaWw6IGZ1bmN0aW9uIGZhaWwoY29kZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuZXJyb3JzLnB1c2goQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCB7Y29kZTogY29kZX0pKTtcbiAgfSxcblxuICB2YWxpZGF0ZVN0cnVjdHVyZTogZnVuY3Rpb24gdmFsaWRhdGVTdHJ1Y3R1cmUoc2hhcGUsIHBhcmFtcywgY29udGV4dCkge1xuICAgIHRoaXMudmFsaWRhdGVUeXBlKHBhcmFtcywgY29udGV4dCwgWydvYmplY3QnXSwgJ3N0cnVjdHVyZScpO1xuXG4gICAgdmFyIHBhcmFtTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgc2hhcGUucmVxdWlyZWQgJiYgaSA8IHNoYXBlLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbU5hbWUgPSBzaGFwZS5yZXF1aXJlZFtpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaXNzaW5nUmVxdWlyZWRQYXJhbWV0ZXInLFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIGtleSBcXCcnICsgcGFyYW1OYW1lICsgJ1xcJyBpbiAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaGFzaCBtZW1iZXJzXG4gICAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdLFxuICAgICAgICAgIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAobWVtYmVyU2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbWVtYmVyQ29udGV4dCA9IFtjb250ZXh0LCBwYXJhbU5hbWVdLmpvaW4oJy4nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihtZW1iZXJTaGFwZSwgcGFyYW1WYWx1ZSwgbWVtYmVyQ29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhaWwoJ1VuZXhwZWN0ZWRQYXJhbWV0ZXInLFxuICAgICAgICAgICdVbmV4cGVjdGVkIGtleSBcXCcnICsgcGFyYW1OYW1lICsgJ1xcJyBmb3VuZCBpbiAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgdmFsaWRhdGVNZW1iZXI6IGZ1bmN0aW9uIHZhbGlkYXRlTWVtYmVyKHNoYXBlLCBwYXJhbSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSAnc3RydWN0dXJlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJ1Y3R1cmUoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUxpc3Qoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTWFwKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVNjYWxhcihzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZUxpc3Q6IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdChzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHBhcmFtcywgY29udGV4dCwgW0FycmF5XSkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgcGFyYW1zLmxlbmd0aCwgY29udGV4dCwgJ2xpc3QgbWVtYmVyIGNvdW50Jyk7XG4gICAgICAvLyB2YWxpZGF0ZSBhcnJheSBtZW1iZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLm1lbWJlciwgcGFyYW1zW2ldLCBjb250ZXh0ICsgJ1snICsgaSArICddJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlTWFwOiBmdW5jdGlvbiB2YWxpZGF0ZU1hcChzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHBhcmFtcywgY29udGV4dCwgWydvYmplY3QnXSwgJ21hcCcpKSB7XG4gICAgICAvLyBCdWlsZCB1cCBhIGNvdW50IG9mIG1hcCBtZW1iZXJzIHRvIHZhbGlkYXRlIHJhbmdlIHRyYWl0cy5cbiAgICAgIHZhciBtYXBDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbSkpIGNvbnRpbnVlO1xuICAgICAgICAvLyBWYWxpZGF0ZSBhbnkgbWFwIGtleSB0cmFpdCBjb25zdHJhaW50c1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLmtleSwgcGFyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCArICdba2V5PVxcJycgKyBwYXJhbSArICdcXCddJylcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS52YWx1ZSwgcGFyYW1zW3BhcmFtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1tcXCcnICsgcGFyYW0gKyAnXFwnXScpO1xuICAgICAgICBtYXBDb3VudCsrO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBtYXBDb3VudCwgY29udGV4dCwgJ21hcCBtZW1iZXIgY291bnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVTY2FsYXI6IGZ1bmN0aW9uIHZhbGlkYXRlU2NhbGFyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZyhzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUGF5bG9hZCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFsnYm9vbGVhbiddKTtcbiAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgW0RhdGUsXG4gICAgICAgICAgL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT9aJC8sICdudW1iZXInXSxcbiAgICAgICAgICAnRGF0ZSBvYmplY3QsIElTTy04NjAxIHN0cmluZywgb3IgYSBVTklYIHRpbWVzdGFtcCcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbCgnVW5rb3duVHlwZScsICdVbmhhbmRsZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS50eXBlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbGlkVHlwZXMgPSBbJ3N0cmluZyddO1xuICAgIGlmIChzaGFwZS5pc0pzb25WYWx1ZSkge1xuICAgICAgdmFsaWRUeXBlcyA9IHZhbGlkVHlwZXMuY29uY2F0KFsnbnVtYmVyJywgJ29iamVjdCcsICdib29sZWFuJ10pO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIHZhbGlkVHlwZXMpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlRW51bShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZS5sZW5ndGgsIGNvbnRleHQsICdzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICB0aGlzLnZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVBhdHRlcm46IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydwYXR0ZXJuJ10gJiYgc2hhcGVbJ3BhdHRlcm4nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIShuZXcgUmVnRXhwKHNoYXBlWydwYXR0ZXJuJ10pKS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ1BhdHRlcm5NYXRjaEVycm9yJywgJ1Byb3ZpZGVkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiICdcbiAgICAgICAgICArICdkb2VzIG5vdCBtYXRjaCByZWdleCBwYXR0ZXJuIC8nICsgc2hhcGVbJ3BhdHRlcm4nXSArICcvIGZvciAnXG4gICAgICAgICAgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVSYW5nZTogZnVuY3Rpb24gdmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQsIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydtaW4nXSkge1xuICAgICAgaWYgKHNoYXBlWydtaW4nXSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgc2hhcGVbJ21pbiddKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWluUmFuZ2VFcnJvcicsICdFeHBlY3RlZCAnICsgZGVzY3JpcHRvciArICcgPj0gJ1xuICAgICAgICAgICsgc2hhcGVbJ21pbiddICsgJywgYnV0IGZvdW5kICcgKyB2YWx1ZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudmFsaWRhdGlvblsnbWF4J10pIHtcbiAgICAgIGlmIChzaGFwZVsnbWF4J10gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHNoYXBlWydtYXgnXSkge1xuICAgICAgICB0aGlzLmZhaWwoJ01heFJhbmdlRXJyb3InLCAnRXhwZWN0ZWQgJyArIGRlc2NyaXB0b3IgKyAnIDw9ICdcbiAgICAgICAgICArIHNoYXBlWydtYXgnXSArICcsIGJ1dCBmb3VuZCAnICsgdmFsdWUgKyAnIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlRW51bTogZnVuY3Rpb24gdmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydlbnVtJ10gJiYgc2hhcGVbJ2VudW0nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBGYWlsIGlmIHRoZSBzdHJpbmcgdmFsdWUgaXMgbm90IHByZXNlbnQgaW4gdGhlIGVudW0gbGlzdFxuICAgICAgaWYgKHNoYXBlWydlbnVtJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnRW51bUVycm9yJywgJ0ZvdW5kIHN0cmluZyB2YWx1ZSBvZiAnICsgdmFsdWUgKyAnLCBidXQgJ1xuICAgICAgICAgICsgJ2V4cGVjdGVkICcgKyBzaGFwZVsnZW51bSddLmpvaW4oJ3wnKSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVUeXBlOiBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIGFjY2VwdGVkVHlwZXMsIHR5cGUpIHtcbiAgICAvLyBXZSB3aWxsIG5vdCBsb2cgYW4gZXJyb3IgZm9yIG51bGwgb3IgdW5kZWZpbmVkLCBidXQgd2Ugd2lsbCByZXR1cm5cbiAgICAvLyBmYWxzZSBzbyB0aGF0IGNhbGxlcnMga25vdyB0aGF0IHRoZSBleHBlY3RlZCB0eXBlIHdhcyBub3Qgc3RyaWN0bHkgbWV0LlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZm91bmRJbnZhbGlkVHlwZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0ZWRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBhY2NlcHRlZFR5cGVzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBhY2NlcHRlZFR5cGVzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXB0ZWRUeXBlc1tpXSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAoKHZhbHVlIHx8ICcnKS50b1N0cmluZygpLm1hdGNoKGFjY2VwdGVkVHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGFjY2VwdGVkVHlwZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoQVdTLnV0aWwuaXNUeXBlKHZhbHVlLCBhY2NlcHRlZFR5cGVzW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghdHlwZSAmJiAhZm91bmRJbnZhbGlkVHlwZSkgYWNjZXB0ZWRUeXBlcyA9IGFjY2VwdGVkVHlwZXMuc2xpY2UoKTtcbiAgICAgICAgYWNjZXB0ZWRUeXBlc1tpXSA9IEFXUy51dGlsLnR5cGVOYW1lKGFjY2VwdGVkVHlwZXNbaV0pO1xuICAgICAgfVxuICAgICAgZm91bmRJbnZhbGlkVHlwZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGFjY2VwdGVkVHlwZSA9IHR5cGU7XG4gICAgaWYgKCFhY2NlcHRlZFR5cGUpIHtcbiAgICAgIGFjY2VwdGVkVHlwZSA9IGFjY2VwdGVkVHlwZXMuam9pbignLCAnKS5yZXBsYWNlKC8sKFteLF0rKSQvLCAnLCBvciQxJyk7XG4gICAgfVxuXG4gICAgdmFyIHZvd2VsID0gYWNjZXB0ZWRUeXBlLm1hdGNoKC9eW2FlaW91XS9pKSA/ICduJyA6ICcnO1xuICAgIHRoaXMuZmFpbCgnSW52YWxpZFBhcmFtZXRlclR5cGUnLCAnRXhwZWN0ZWQgJyArIGNvbnRleHQgKyAnIHRvIGJlIGEnICtcbiAgICAgICAgICAgICAgdm93ZWwgKyAnICcgKyBhY2NlcHRlZFR5cGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICB2YWxpZGF0ZU51bWJlcjogZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNhc3RlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoY2FzdGVkVmFsdWUudG9TdHJpbmcoKSA9PT0gdmFsdWUpIHZhbHVlID0gY2FzdGVkVmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgWydudW1iZXInXSkpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVSYW5nZShzaGFwZSwgdmFsdWUsIGNvbnRleHQsICdudW1lcmljIHZhbHVlJyk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUGF5bG9hZDogZnVuY3Rpb24gdmFsaWRhdGVQYXlsb2FkKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHJldHVybjsgLy8gdHlwZWQgYXJyYXlzXG4gICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7IC8vIHNwZWNpYWwgY2hlY2sgZm9yIGJ1ZmZlci9zdHJlYW0gaW4gTm9kZS5qc1xuICAgICAgdmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICBpZiAoQVdTLnV0aWwuQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmVhbSkgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlcyA9IFsnQnVmZmVyJywgJ1N0cmVhbScsICdGaWxlJywgJ0Jsb2InLCAnQXJyYXlCdWZmZXInLCAnRGF0YVZpZXcnXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzVHlwZSh2YWx1ZSwgdHlwZXNbaV0pKSByZXR1cm47XG4gICAgICAgIGlmIChBV1MudXRpbC50eXBlTmFtZSh2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IHR5cGVzW2ldKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYSAnICtcbiAgICAgICdzdHJpbmcsIEJ1ZmZlciwgU3RyZWFtLCBCbG9iLCBvciB0eXBlZCBhcnJheSBvYmplY3QnKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wYXJhbV92YWxpZGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wiYWNtXCI6e1wibmFtZVwiOlwiQUNNXCIsXCJjb3JzXCI6dHJ1ZX0sXCJhcGlnYXRld2F5XCI6e1wibmFtZVwiOlwiQVBJR2F0ZXdheVwiLFwiY29yc1wiOnRydWV9LFwiYXBwbGljYXRpb25hdXRvc2NhbGluZ1wiOntcInByZWZpeFwiOlwiYXBwbGljYXRpb24tYXV0b3NjYWxpbmdcIixcIm5hbWVcIjpcIkFwcGxpY2F0aW9uQXV0b1NjYWxpbmdcIixcImNvcnNcIjp0cnVlfSxcImFwcHN0cmVhbVwiOntcIm5hbWVcIjpcIkFwcFN0cmVhbVwifSxcImF1dG9zY2FsaW5nXCI6e1wibmFtZVwiOlwiQXV0b1NjYWxpbmdcIixcImNvcnNcIjp0cnVlfSxcImJhdGNoXCI6e1wibmFtZVwiOlwiQmF0Y2hcIn0sXCJidWRnZXRzXCI6e1wibmFtZVwiOlwiQnVkZ2V0c1wifSxcImNsb3VkZGlyZWN0b3J5XCI6e1wibmFtZVwiOlwiQ2xvdWREaXJlY3RvcnlcIn0sXCJjbG91ZGZvcm1hdGlvblwiOntcIm5hbWVcIjpcIkNsb3VkRm9ybWF0aW9uXCIsXCJjb3JzXCI6dHJ1ZX0sXCJjbG91ZGZyb250XCI6e1wibmFtZVwiOlwiQ2xvdWRGcm9udFwiLFwidmVyc2lvbnNcIjpbXCIyMDEzLTA1LTEyKlwiLFwiMjAxMy0xMS0xMSpcIixcIjIwMTQtMDUtMzEqXCIsXCIyMDE0LTEwLTIxKlwiLFwiMjAxNC0xMS0wNipcIixcIjIwMTUtMDQtMTcqXCIsXCIyMDE1LTA3LTI3KlwiLFwiMjAxNS0wOS0xNypcIixcIjIwMTYtMDEtMTMqXCIsXCIyMDE2LTAxLTI4KlwiLFwiMjAxNi0wOC0wMSpcIixcIjIwMTYtMDgtMjAqXCIsXCIyMDE2LTA5LTA3KlwiLFwiMjAxNi0wOS0yOSpcIixcIjIwMTYtMTEtMjUqXCJdLFwiY29yc1wiOnRydWV9LFwiY2xvdWRoc21cIjp7XCJuYW1lXCI6XCJDbG91ZEhTTVwiLFwiY29yc1wiOnRydWV9LFwiY2xvdWRzZWFyY2hcIjp7XCJuYW1lXCI6XCJDbG91ZFNlYXJjaFwifSxcImNsb3Vkc2VhcmNoZG9tYWluXCI6e1wibmFtZVwiOlwiQ2xvdWRTZWFyY2hEb21haW5cIn0sXCJjbG91ZHRyYWlsXCI6e1wibmFtZVwiOlwiQ2xvdWRUcmFpbFwiLFwiY29yc1wiOnRydWV9LFwiY2xvdWR3YXRjaFwiOntcInByZWZpeFwiOlwibW9uaXRvcmluZ1wiLFwibmFtZVwiOlwiQ2xvdWRXYXRjaFwiLFwiY29yc1wiOnRydWV9LFwiY2xvdWR3YXRjaGV2ZW50c1wiOntcInByZWZpeFwiOlwiZXZlbnRzXCIsXCJuYW1lXCI6XCJDbG91ZFdhdGNoRXZlbnRzXCIsXCJ2ZXJzaW9uc1wiOltcIjIwMTQtMDItMDMqXCJdLFwiY29yc1wiOnRydWV9LFwiY2xvdWR3YXRjaGxvZ3NcIjp7XCJwcmVmaXhcIjpcImxvZ3NcIixcIm5hbWVcIjpcIkNsb3VkV2F0Y2hMb2dzXCIsXCJjb3JzXCI6dHJ1ZX0sXCJjb2RlYnVpbGRcIjp7XCJuYW1lXCI6XCJDb2RlQnVpbGRcIn0sXCJjb2RlY29tbWl0XCI6e1wibmFtZVwiOlwiQ29kZUNvbW1pdFwiLFwiY29yc1wiOnRydWV9LFwiY29kZWRlcGxveVwiOntcIm5hbWVcIjpcIkNvZGVEZXBsb3lcIixcImNvcnNcIjp0cnVlfSxcImNvZGVwaXBlbGluZVwiOntcIm5hbWVcIjpcIkNvZGVQaXBlbGluZVwiLFwiY29yc1wiOnRydWV9LFwiY29nbml0b2lkZW50aXR5XCI6e1wicHJlZml4XCI6XCJjb2duaXRvLWlkZW50aXR5XCIsXCJuYW1lXCI6XCJDb2duaXRvSWRlbnRpdHlcIixcImNvcnNcIjp0cnVlfSxcImNvZ25pdG9pZGVudGl0eXNlcnZpY2Vwcm92aWRlclwiOntcInByZWZpeFwiOlwiY29nbml0by1pZHBcIixcIm5hbWVcIjpcIkNvZ25pdG9JZGVudGl0eVNlcnZpY2VQcm92aWRlclwiLFwiY29yc1wiOnRydWV9LFwiY29nbml0b3N5bmNcIjp7XCJwcmVmaXhcIjpcImNvZ25pdG8tc3luY1wiLFwibmFtZVwiOlwiQ29nbml0b1N5bmNcIixcImNvcnNcIjp0cnVlfSxcImNvbmZpZ3NlcnZpY2VcIjp7XCJwcmVmaXhcIjpcImNvbmZpZ1wiLFwibmFtZVwiOlwiQ29uZmlnU2VydmljZVwiLFwiY29yc1wiOnRydWV9LFwiY3VyXCI6e1wibmFtZVwiOlwiQ1VSXCIsXCJjb3JzXCI6dHJ1ZX0sXCJkYXRhcGlwZWxpbmVcIjp7XCJuYW1lXCI6XCJEYXRhUGlwZWxpbmVcIn0sXCJkZXZpY2VmYXJtXCI6e1wibmFtZVwiOlwiRGV2aWNlRmFybVwiLFwiY29yc1wiOnRydWV9LFwiZGlyZWN0Y29ubmVjdFwiOntcIm5hbWVcIjpcIkRpcmVjdENvbm5lY3RcIixcImNvcnNcIjp0cnVlfSxcImRpcmVjdG9yeXNlcnZpY2VcIjp7XCJwcmVmaXhcIjpcImRzXCIsXCJuYW1lXCI6XCJEaXJlY3RvcnlTZXJ2aWNlXCJ9LFwiZGlzY292ZXJ5XCI6e1wibmFtZVwiOlwiRGlzY292ZXJ5XCJ9LFwiZG1zXCI6e1wibmFtZVwiOlwiRE1TXCJ9LFwiZHluYW1vZGJcIjp7XCJuYW1lXCI6XCJEeW5hbW9EQlwiLFwiY29yc1wiOnRydWV9LFwiZHluYW1vZGJzdHJlYW1zXCI6e1wicHJlZml4XCI6XCJzdHJlYW1zLmR5bmFtb2RiXCIsXCJuYW1lXCI6XCJEeW5hbW9EQlN0cmVhbXNcIixcImNvcnNcIjp0cnVlfSxcImVjMlwiOntcIm5hbWVcIjpcIkVDMlwiLFwidmVyc2lvbnNcIjpbXCIyMDEzLTA2LTE1KlwiLFwiMjAxMy0xMC0xNSpcIixcIjIwMTQtMDItMDEqXCIsXCIyMDE0LTA1LTAxKlwiLFwiMjAxNC0wNi0xNSpcIixcIjIwMTQtMDktMDEqXCIsXCIyMDE0LTEwLTAxKlwiLFwiMjAxNS0wMy0wMSpcIixcIjIwMTUtMDQtMTUqXCIsXCIyMDE1LTEwLTAxKlwiLFwiMjAxNi0wNC0wMSpcIixcIjIwMTYtMDktMTUqXCJdLFwiY29yc1wiOnRydWV9LFwiZWNyXCI6e1wibmFtZVwiOlwiRUNSXCIsXCJjb3JzXCI6dHJ1ZX0sXCJlY3NcIjp7XCJuYW1lXCI6XCJFQ1NcIixcImNvcnNcIjp0cnVlfSxcImVmc1wiOntcInByZWZpeFwiOlwiZWxhc3RpY2ZpbGVzeXN0ZW1cIixcIm5hbWVcIjpcIkVGU1wiLFwiY29yc1wiOnRydWV9LFwiZWxhc3RpY2FjaGVcIjp7XCJuYW1lXCI6XCJFbGFzdGlDYWNoZVwiLFwidmVyc2lvbnNcIjpbXCIyMDEyLTExLTE1KlwiLFwiMjAxNC0wMy0yNCpcIixcIjIwMTQtMDctMTUqXCIsXCIyMDE0LTA5LTMwKlwiXSxcImNvcnNcIjp0cnVlfSxcImVsYXN0aWNiZWFuc3RhbGtcIjp7XCJuYW1lXCI6XCJFbGFzdGljQmVhbnN0YWxrXCIsXCJjb3JzXCI6dHJ1ZX0sXCJlbGJcIjp7XCJwcmVmaXhcIjpcImVsYXN0aWNsb2FkYmFsYW5jaW5nXCIsXCJuYW1lXCI6XCJFTEJcIixcImNvcnNcIjp0cnVlfSxcImVsYnYyXCI6e1wicHJlZml4XCI6XCJlbGFzdGljbG9hZGJhbGFuY2luZ3YyXCIsXCJuYW1lXCI6XCJFTEJ2MlwiLFwiY29yc1wiOnRydWV9LFwiZW1yXCI6e1wicHJlZml4XCI6XCJlbGFzdGljbWFwcmVkdWNlXCIsXCJuYW1lXCI6XCJFTVJcIixcImNvcnNcIjp0cnVlfSxcImVzXCI6e1wibmFtZVwiOlwiRVNcIn0sXCJlbGFzdGljdHJhbnNjb2RlclwiOntcIm5hbWVcIjpcIkVsYXN0aWNUcmFuc2NvZGVyXCIsXCJjb3JzXCI6dHJ1ZX0sXCJmaXJlaG9zZVwiOntcIm5hbWVcIjpcIkZpcmVob3NlXCIsXCJjb3JzXCI6dHJ1ZX0sXCJnYW1lbGlmdFwiOntcIm5hbWVcIjpcIkdhbWVMaWZ0XCIsXCJjb3JzXCI6dHJ1ZX0sXCJnbGFjaWVyXCI6e1wibmFtZVwiOlwiR2xhY2llclwifSxcImhlYWx0aFwiOntcIm5hbWVcIjpcIkhlYWx0aFwifSxcImlhbVwiOntcIm5hbWVcIjpcIklBTVwifSxcImltcG9ydGV4cG9ydFwiOntcIm5hbWVcIjpcIkltcG9ydEV4cG9ydFwifSxcImluc3BlY3RvclwiOntcIm5hbWVcIjpcIkluc3BlY3RvclwiLFwidmVyc2lvbnNcIjpbXCIyMDE1LTA4LTE4KlwiXSxcImNvcnNcIjp0cnVlfSxcImlvdFwiOntcIm5hbWVcIjpcIklvdFwiLFwiY29yc1wiOnRydWV9LFwiaW90ZGF0YVwiOntcInByZWZpeFwiOlwiaW90LWRhdGFcIixcIm5hbWVcIjpcIklvdERhdGFcIixcImNvcnNcIjp0cnVlfSxcImtpbmVzaXNcIjp7XCJuYW1lXCI6XCJLaW5lc2lzXCIsXCJjb3JzXCI6dHJ1ZX0sXCJraW5lc2lzYW5hbHl0aWNzXCI6e1wibmFtZVwiOlwiS2luZXNpc0FuYWx5dGljc1wifSxcImttc1wiOntcIm5hbWVcIjpcIktNU1wiLFwiY29yc1wiOnRydWV9LFwibGFtYmRhXCI6e1wibmFtZVwiOlwiTGFtYmRhXCIsXCJjb3JzXCI6dHJ1ZX0sXCJsZXhydW50aW1lXCI6e1wicHJlZml4XCI6XCJydW50aW1lLmxleFwiLFwibmFtZVwiOlwiTGV4UnVudGltZVwiLFwiY29yc1wiOnRydWV9LFwibGlnaHRzYWlsXCI6e1wibmFtZVwiOlwiTGlnaHRzYWlsXCJ9LFwibWFjaGluZWxlYXJuaW5nXCI6e1wibmFtZVwiOlwiTWFjaGluZUxlYXJuaW5nXCIsXCJjb3JzXCI6dHJ1ZX0sXCJtYXJrZXRwbGFjZWNvbW1lcmNlYW5hbHl0aWNzXCI6e1wibmFtZVwiOlwiTWFya2V0cGxhY2VDb21tZXJjZUFuYWx5dGljc1wiLFwiY29yc1wiOnRydWV9LFwibWFya2V0cGxhY2VtZXRlcmluZ1wiOntcInByZWZpeFwiOlwibWV0ZXJpbmdtYXJrZXRwbGFjZVwiLFwibmFtZVwiOlwiTWFya2V0cGxhY2VNZXRlcmluZ1wifSxcIm10dXJrXCI6e1wicHJlZml4XCI6XCJtdHVyay1yZXF1ZXN0ZXJcIixcIm5hbWVcIjpcIk1UdXJrXCIsXCJjb3JzXCI6dHJ1ZX0sXCJtb2JpbGVhbmFseXRpY3NcIjp7XCJuYW1lXCI6XCJNb2JpbGVBbmFseXRpY3NcIixcImNvcnNcIjp0cnVlfSxcIm9wc3dvcmtzXCI6e1wibmFtZVwiOlwiT3BzV29ya3NcIixcImNvcnNcIjp0cnVlfSxcIm9wc3dvcmtzY21cIjp7XCJuYW1lXCI6XCJPcHNXb3Jrc0NNXCJ9LFwib3JnYW5pemF0aW9uc1wiOntcIm5hbWVcIjpcIk9yZ2FuaXphdGlvbnNcIn0sXCJwaW5wb2ludFwiOntcIm5hbWVcIjpcIlBpbnBvaW50XCJ9LFwicG9sbHlcIjp7XCJuYW1lXCI6XCJQb2xseVwiLFwiY29yc1wiOnRydWV9LFwicmRzXCI6e1wibmFtZVwiOlwiUkRTXCIsXCJ2ZXJzaW9uc1wiOltcIjIwMTQtMDktMDEqXCJdLFwiY29yc1wiOnRydWV9LFwicmVkc2hpZnRcIjp7XCJuYW1lXCI6XCJSZWRzaGlmdFwiLFwiY29yc1wiOnRydWV9LFwicmVrb2duaXRpb25cIjp7XCJuYW1lXCI6XCJSZWtvZ25pdGlvblwiLFwiY29yc1wiOnRydWV9LFwicmVzb3VyY2Vncm91cHN0YWdnaW5nYXBpXCI6e1wibmFtZVwiOlwiUmVzb3VyY2VHcm91cHNUYWdnaW5nQVBJXCJ9LFwicm91dGU1M1wiOntcIm5hbWVcIjpcIlJvdXRlNTNcIixcImNvcnNcIjp0cnVlfSxcInJvdXRlNTNkb21haW5zXCI6e1wibmFtZVwiOlwiUm91dGU1M0RvbWFpbnNcIixcImNvcnNcIjp0cnVlfSxcInMzXCI6e1wibmFtZVwiOlwiUzNcIixcImR1YWxzdGFja0F2YWlsYWJsZVwiOnRydWUsXCJjb3JzXCI6dHJ1ZX0sXCJzZXJ2aWNlY2F0YWxvZ1wiOntcIm5hbWVcIjpcIlNlcnZpY2VDYXRhbG9nXCIsXCJjb3JzXCI6dHJ1ZX0sXCJzZXNcIjp7XCJwcmVmaXhcIjpcImVtYWlsXCIsXCJuYW1lXCI6XCJTRVNcIixcImNvcnNcIjp0cnVlfSxcInNoaWVsZFwiOntcIm5hbWVcIjpcIlNoaWVsZFwifSxcInNpbXBsZWRiXCI6e1wicHJlZml4XCI6XCJzZGJcIixcIm5hbWVcIjpcIlNpbXBsZURCXCJ9LFwic21zXCI6e1wibmFtZVwiOlwiU01TXCJ9LFwic25vd2JhbGxcIjp7XCJuYW1lXCI6XCJTbm93YmFsbFwifSxcInNuc1wiOntcIm5hbWVcIjpcIlNOU1wiLFwiY29yc1wiOnRydWV9LFwic3FzXCI6e1wibmFtZVwiOlwiU1FTXCIsXCJjb3JzXCI6dHJ1ZX0sXCJzc21cIjp7XCJuYW1lXCI6XCJTU01cIixcImNvcnNcIjp0cnVlfSxcInN0b3JhZ2VnYXRld2F5XCI6e1wibmFtZVwiOlwiU3RvcmFnZUdhdGV3YXlcIixcImNvcnNcIjp0cnVlfSxcInN0ZXBmdW5jdGlvbnNcIjp7XCJwcmVmaXhcIjpcInN0YXRlc1wiLFwibmFtZVwiOlwiU3RlcEZ1bmN0aW9uc1wifSxcInN0c1wiOntcIm5hbWVcIjpcIlNUU1wiLFwiY29yc1wiOnRydWV9LFwic3VwcG9ydFwiOntcIm5hbWVcIjpcIlN1cHBvcnRcIn0sXCJzd2ZcIjp7XCJuYW1lXCI6XCJTV0ZcIn0sXCJ4cmF5XCI6e1wibmFtZVwiOlwiWFJheVwifSxcIndhZlwiOntcIm5hbWVcIjpcIldBRlwiLFwiY29yc1wiOnRydWV9LFwid2FmcmVnaW9uYWxcIjp7XCJwcmVmaXhcIjpcIndhZi1yZWdpb25hbFwiLFwibmFtZVwiOlwiV0FGUmVnaW9uYWxcIn0sXCJ3b3JrZG9jc1wiOntcIm5hbWVcIjpcIldvcmtEb2NzXCIsXCJjb3JzXCI6dHJ1ZX0sXCJ3b3Jrc3BhY2VzXCI6e1wibmFtZVwiOlwiV29ya1NwYWNlc1wifSxcImNvZGVzdGFyXCI6e1wibmFtZVwiOlwiQ29kZVN0YXJcIn0sXCJsZXhtb2RlbGJ1aWxkaW5nc2VydmljZVwiOntcInByZWZpeFwiOlwibGV4LW1vZGVsc1wiLFwibmFtZVwiOlwiTGV4TW9kZWxCdWlsZGluZ1NlcnZpY2VcIn0sXCJtYXJrZXRwbGFjZWVudGl0bGVtZW50c2VydmljZVwiOntcInByZWZpeFwiOlwiZW50aXRsZW1lbnQubWFya2V0cGxhY2VcIixcIm5hbWVcIjpcIk1hcmtldHBsYWNlRW50aXRsZW1lbnRTZXJ2aWNlXCJ9LFwiYXRoZW5hXCI6e1wibmFtZVwiOlwiQXRoZW5hXCJ9LFwiZ3JlZW5ncmFzc1wiOntcIm5hbWVcIjpcIkdyZWVuZ3Jhc3NcIn0sXCJkYXhcIjp7XCJuYW1lXCI6XCJEQVhcIn0sXCJtaWdyYXRpb25odWJcIjp7XCJwcmVmaXhcIjpcIkFXU01pZ3JhdGlvbkh1YlwiLFwibmFtZVwiOlwiTWlncmF0aW9uSHViXCJ9LFwiY2xvdWRoc212MlwiOntcIm5hbWVcIjpcIkNsb3VkSFNNVjJcIn0sXCJnbHVlXCI6e1wibmFtZVwiOlwiR2x1ZVwifX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvbWV0YWRhdGEuanNvblxuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHYxID0gcmVxdWlyZSgnLi92MScpO1xudmFyIHY0ID0gcmVxdWlyZSgnLi92NCcpO1xuXG52YXIgdXVpZCA9IHY0O1xudXVpZC52MSA9IHYxO1xudXVpZC52NCA9IHY0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbi8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG52YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbi8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG52YXIgX3NlZWRCeXRlcyA9IHJuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW1xuICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL3YxLmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxudmFyIHNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMTogc2hhLFxuICBzaGEyNTY6IHNoYTI1NixcbiAgbWQ1OiBtZDVcbn1cblxudmFyIGJsb2Nrc2l6ZSA9IDY0XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKTsgemVyb0J1ZmZlci5maWxsKDApXG5mdW5jdGlvbiBobWFjKGZuLCBrZXksIGRhdGEpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSBrZXkgPSBuZXcgQnVmZmVyKGtleSlcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gZm4oa2V5KVxuICB9IGVsc2UgaWYoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgemVyb0J1ZmZlcl0sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpLCBvcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHZhciBoYXNoID0gZm4oQnVmZmVyLmNvbmNhdChbaXBhZCwgZGF0YV0pKVxuICByZXR1cm4gZm4oQnVmZmVyLmNvbmNhdChbb3BhZCwgaGFzaF0pKVxufVxuXG5mdW5jdGlvbiBoYXNoKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgdmFyIGZuID0gYWxnb3JpdGhtc1thbGddXG4gIHZhciBidWZzID0gW11cbiAgdmFyIGxlbmd0aCA9IDBcbiAgaWYoIWZuKSBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICAgICAgICBcbiAgICAgIGJ1ZnMucHVzaChkYXRhKVxuICAgICAgbGVuZ3RoICs9IGRhdGEubGVuZ3RoXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGlnZXN0OiBmdW5jdGlvbiAoZW5jKSB7XG4gICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZzKVxuICAgICAgdmFyIHIgPSBrZXkgPyBobWFjKGZuLCBrZXksIGJ1ZikgOiBmbihidWYpXG4gICAgICBidWZzID0gbnVsbFxuICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChhbGcpIHsgcmV0dXJuIGhhc2goYWxnKSB9XG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnLCBrZXkpIHsgcmV0dXJuIGhhc2goYWxnLCBrZXkpIH1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihzaXplLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCkge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgbmV3IEJ1ZmZlcihybmcoc2l6ZSkpKVxuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaChhLCBmKSB7XG4gIGZvcih2YXIgaSBpbiBhKVxuICAgIGYoYVtpXSwgaSlcbn1cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG5lYWNoKFsnY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVDaXBoZXInXG4sICdjcmVhdGVDaXBoZXJpdidcbiwgJ2NyZWF0ZURlY2lwaGVyJ1xuLCAnY3JlYXRlRGVjaXBoZXJpdidcbiwgJ2NyZWF0ZVNpZ24nXG4sICdjcmVhdGVWZXJpZnknXG4sICdjcmVhdGVEaWZmaWVIZWxsbWFuJ1xuLCAncGJrZGYyJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gQXJyYXkoODApO1xuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcbiAgdmFyIGUgPSAtMTAwOTU4OTc3NjtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgdmFyIG9sZGUgPSBlO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYoaiA8IDE2KSB3W2pdID0geFtpICsgal07XG4gICAgICBlbHNlIHdbal0gPSByb2wod1tqLTNdIF4gd1tqLThdIF4gd1tqLTE0XSBeIHdbai0xNl0sIDEpO1xuICAgICAgdmFyIHQgPSBzYWZlX2FkZChzYWZlX2FkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBzYWZlX2FkZChzYWZlX2FkZChlLCB3W2pdKSwgc2hhMV9rdChqKSkpO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSByb2woYiwgMzApO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgZSA9IHNhZmVfYWRkKGUsIG9sZGUpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcblxufVxuXG4vKlxuICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAqIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpXG57XG4gIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgcmV0dXJuIGIgXiBjIF4gZDtcbn1cblxuLypcbiAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2t0KHQpXG57XG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTEoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTEsIDIwLCB0cnVlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlxuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciBzYWZlX2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn07XG5cbnZhciBTID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpO1xufTtcblxudmFyIFIgPSBmdW5jdGlvbihYLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbik7XG59O1xuXG52YXIgQ2ggPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xufTtcblxudmFyIE1haiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xufTtcblxudmFyIFNpZ21hMDI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDIpIF4gUyh4LCAxMykgXiBTKHgsIDIyKSk7XG59O1xuXG52YXIgU2lnbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNikgXiBTKHgsIDExKSBeIFMoeCwgMjUpKTtcbn07XG5cbnZhciBHYW1tYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSk7XG59O1xuXG52YXIgR2FtbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgMTcpIF4gUyh4LCAxOSkgXiBSKHgsIDEwKSk7XG59O1xuXG52YXIgY29yZV9zaGEyNTYgPSBmdW5jdGlvbihtLCBsKSB7XG4gIHZhciBLID0gbmV3IEFycmF5KDB4NDI4QTJGOTgsMHg3MTM3NDQ5MSwweEI1QzBGQkNGLDB4RTlCNURCQTUsMHgzOTU2QzI1QiwweDU5RjExMUYxLDB4OTIzRjgyQTQsMHhBQjFDNUVENSwweEQ4MDdBQTk4LDB4MTI4MzVCMDEsMHgyNDMxODVCRSwweDU1MEM3REMzLDB4NzJCRTVENzQsMHg4MERFQjFGRSwweDlCREMwNkE3LDB4QzE5QkYxNzQsMHhFNDlCNjlDMSwweEVGQkU0Nzg2LDB4RkMxOURDNiwweDI0MENBMUNDLDB4MkRFOTJDNkYsMHg0QTc0ODRBQSwweDVDQjBBOURDLDB4NzZGOTg4REEsMHg5ODNFNTE1MiwweEE4MzFDNjZELDB4QjAwMzI3QzgsMHhCRjU5N0ZDNywweEM2RTAwQkYzLDB4RDVBNzkxNDcsMHg2Q0E2MzUxLDB4MTQyOTI5NjcsMHgyN0I3MEE4NSwweDJFMUIyMTM4LDB4NEQyQzZERkMsMHg1MzM4MEQxMywweDY1MEE3MzU0LDB4NzY2QTBBQkIsMHg4MUMyQzkyRSwweDkyNzIyQzg1LDB4QTJCRkU4QTEsMHhBODFBNjY0QiwweEMyNEI4QjcwLDB4Qzc2QzUxQTMsMHhEMTkyRTgxOSwweEQ2OTkwNjI0LDB4RjQwRTM1ODUsMHgxMDZBQTA3MCwweDE5QTRDMTE2LDB4MUUzNzZDMDgsMHgyNzQ4Nzc0QywweDM0QjBCQ0I1LDB4MzkxQzBDQjMsMHg0RUQ4QUE0QSwweDVCOUNDQTRGLDB4NjgyRTZGRjMsMHg3NDhGODJFRSwweDc4QTU2MzZGLDB4ODRDODc4MTQsMHg4Q0M3MDIwOCwweDkwQkVGRkZBLDB4QTQ1MDZDRUIsMHhCRUY5QTNGNywweEM2NzE3OEYyKTtcbiAgdmFyIEhBU0ggPSBuZXcgQXJyYXkoMHg2QTA5RTY2NywgMHhCQjY3QUU4NSwgMHgzQzZFRjM3MiwgMHhBNTRGRjUzQSwgMHg1MTBFNTI3RiwgMHg5QjA1Njg4QywgMHgxRjgzRDlBQiwgMHg1QkUwQ0QxOSk7XG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoNjQpO1xuICAgIHZhciBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqO1xuICAgIHZhciBUMSwgVDI7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIG1bbCA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGwgJSAzMik7XG4gIG1bKChsICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgYSA9IEhBU0hbMF07IGIgPSBIQVNIWzFdOyBjID0gSEFTSFsyXTsgZCA9IEhBU0hbM107IGUgPSBIQVNIWzRdOyBmID0gSEFTSFs1XTsgZyA9IEhBU0hbNl07IGggPSBIQVNIWzddO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgaWYgKGogPCAxNikge1xuICAgICAgICBXW2pdID0gbVtqICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBXW2pdID0gc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoR2FtbWExMjU2KFdbaiAtIDJdKSwgV1tqIC0gN10pLCBHYW1tYTAyNTYoV1tqIC0gMTVdKSksIFdbaiAtIDE2XSk7XG4gICAgICB9XG4gICAgICBUMSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKGgsIFNpZ21hMTI1NihlKSksIENoKGUsIGYsIGcpKSwgS1tqXSksIFdbal0pO1xuICAgICAgVDIgPSBzYWZlX2FkZChTaWdtYTAyNTYoYSksIE1haihhLCBiLCBjKSk7XG4gICAgICBoID0gZzsgZyA9IGY7IGYgPSBlOyBlID0gc2FmZV9hZGQoZCwgVDEpOyBkID0gYzsgYyA9IGI7IGIgPSBhOyBhID0gc2FmZV9hZGQoVDEsIFQyKTtcbiAgICB9XG4gICAgSEFTSFswXSA9IHNhZmVfYWRkKGEsIEhBU0hbMF0pOyBIQVNIWzFdID0gc2FmZV9hZGQoYiwgSEFTSFsxXSk7IEhBU0hbMl0gPSBzYWZlX2FkZChjLCBIQVNIWzJdKTsgSEFTSFszXSA9IHNhZmVfYWRkKGQsIEhBU0hbM10pO1xuICAgIEhBU0hbNF0gPSBzYWZlX2FkZChlLCBIQVNIWzRdKTsgSEFTSFs1XSA9IHNhZmVfYWRkKGYsIEhBU0hbNV0pOyBIQVNIWzZdID0gc2FmZV9hZGQoZywgSEFTSFs2XSk7IEhBU0hbN10gPSBzYWZlX2FkZChoLCBIQVNIWzddKTtcbiAgfVxuICByZXR1cm4gSEFTSDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhMjU2KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9zaGEyNTYsIDMyLCB0cnVlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEyNTYuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHdoYXR3Z1JORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxyXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXHJcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXHJcbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cclxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxyXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcclxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cclxuICovXHJcblxyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxuLypcclxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfdm1fdGVzdCgpXHJcbntcclxuICByZXR1cm4gaGV4X21kNShcImFiY1wiKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcclxuICovXHJcbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcclxue1xyXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXHJcbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XHJcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xyXG5cclxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xyXG4gIHZhciBiID0gLTI3MTczMzg3OTtcclxuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xyXG4gIHZhciBkID0gIDI3MTczMzg3ODtcclxuXHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxyXG4gIHtcclxuICAgIHZhciBvbGRhID0gYTtcclxuICAgIHZhciBvbGRiID0gYjtcclxuICAgIHZhciBvbGRjID0gYztcclxuICAgIHZhciBvbGRkID0gZDtcclxuXHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcclxuXHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcclxuXHJcbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XHJcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XHJcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XHJcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcclxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cclxuICovXHJcbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXHJcbntcclxuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xyXG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcclxuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcclxufVxyXG5cclxuLypcclxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxyXG4gKi9cclxuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcclxue1xyXG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XHJcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvdXJsL3VybC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20ge0FXUy5TVFN9LiBXaXRob3V0IGFueVxuICogZXh0cmEgcGFyYW1ldGVycywgY3JlZGVudGlhbHMgd2lsbCBiZSBmZXRjaGVkIGZyb20gdGhlXG4gKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbi4gSWYgYW4gSUFNIHJvbGUgaXMgcHJvdmlkZWQsIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3BlcmF0aW9uIHdpbGwgYmUgdXNlZCB0byBmZXRjaCBjcmVkZW50aWFscyBmb3IgdGhlXG4gKiByb2xlIGluc3RlYWQuXG4gKlxuICogVG8gc2V0dXAgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLCBjb25maWd1cmUgYSBzZXQgb2YgbWFzdGVyIGNyZWRlbnRpYWxzXG4gKiB1c2luZyB0aGUgc3RhbmRhcmQgY3JlZGVudGlhbHMgcHJvdmlkZXJzIChlbnZpcm9ubWVudCwgRUMyIGluc3RhbmNlIG1ldGFkYXRhLFxuICogb3IgZnJvbSB0aGUgZmlsZXN5c3RlbSksIHRoZW4gc2V0IHRoZSBnbG9iYWwgY3JlZGVudGlhbHMgdG8gYSBuZXdcbiAqIHRlbXBvcmFyeSBjcmVkZW50aWFscyBvYmplY3Q6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gTm90ZSB0aGF0IGVudmlyb25tZW50IGNyZWRlbnRpYWxzIGFyZSBsb2FkZWQgYnkgZGVmYXVsdCxcbiAqIC8vIHRoZSBmb2xsb3dpbmcgbGluZSBpcyBzaG93biBmb3IgY2xhcml0eTpcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpO1xuICpcbiAqIC8vIE5vdyBzZXQgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIHNlZWRlZCBmcm9tIHRoZSBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gKlxuICogLy8gc3Vic2VxdWVudCByZXF1ZXN0cyB3aWxsIG5vdyB1c2UgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAqIG5ldyBBV1MuUzMoKS5saXN0QnVja2V0KGZ1bmN0aW9uKGVyciwgZGF0YSkgeyAuLi4gfSk7XG4gKiBgYGBcbiAqXG4gKiBAIWF0dHJpYnV0ZSBtYXN0ZXJDcmVkZW50aWFsc1xuICogICBAcmV0dXJuIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBtYXN0ZXIgKG5vbi10ZW1wb3JhcnkpIGNyZWRlbnRpYWxzIHVzZWQgdG9cbiAqICAgICBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAqIEBub3RlIChzZWUgY29uc3RydWN0b3IpXG4gKi9cbkFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRlbXBvcmFyeSBjcmVkZW50aWFscyBvYmplY3QuXG4gICAqXG4gICAqIEBub3RlIEluIG9yZGVyIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMsIHlvdSBmaXJzdCBuZWVkIHRvIGhhdmVcbiAgICogICBcIm1hc3RlclwiIGNyZWRlbnRpYWxzIGNvbmZpZ3VyZWQgaW4ge0FXUy5Db25maWcuY3JlZGVudGlhbHN9LiBUaGVzZVxuICAgKiAgIG1hc3RlciBjcmVkZW50aWFscyBhcmUgbmVjZXNzYXJ5IHRvIHJldHJpZXZlIHRoZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMsXG4gICAqICAgYXMgd2VsbCBhcyByZWZyZXNoIHRoZSBjcmVkZW50aWFscyB3aGVuIHRoZXkgZXhwaXJlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZVxuICAgKiAgIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9ucy5cbiAgICogICBJZiBhIGBSb2xlQXJuYCBwYXJhbWV0ZXIgaXMgcGFzc2VkIGluLCBjcmVkZW50aWFscyB3aWxsIGJlIGJhc2VkIG9uIHRoZVxuICAgKiAgIElBTSByb2xlLlxuICAgKiBAcGFyYW0gbWFzdGVyQ3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciAobm9uLXRlbXBvcmFyeSkgY3JlZGVudGlhbHNcbiAgICogIHVzZWQgdG8gZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgZ2VuZXJpYyB0ZW1wb3JhcnkgY3JlZGVudGlhbHNcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGFuIElBTSByb2xlXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvVGVtcG9yYXJ5Q3JlZGVudGlhbHMnLFxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5TVFMuYXNzdW1lUm9sZVxuICAgKiBAc2VlIEFXUy5TVFMuZ2V0U2Vzc2lvblRva2VuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gVGVtcG9yYXJ5Q3JlZGVudGlhbHMocGFyYW1zLCBtYXN0ZXJDcmVkZW50aWFscykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMubG9hZE1hc3RlckNyZWRlbnRpYWxzKG1hc3RlckNyZWRlbnRpYWxzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgaWYgKHRoaXMucGFyYW1zLlJvbGVBcm4pIHtcbiAgICAgIHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9XG4gICAgICAgIHRoaXMucGFyYW1zLlJvbGVTZXNzaW9uTmFtZSB8fCAndGVtcG9yYXJ5LWNyZWRlbnRpYWxzJztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBjcmVkZW50aWFscyB1c2luZyB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvclxuICAgKiB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59LCBkZXBlbmRpbmcgb24gd2hldGhlciBhbiBJQU0gcm9sZSBBUk4gd2FzIHBhc3NlZFxuICAgKiB0byB0aGUgY3JlZGVudGlhbHMge2NvbnN0cnVjdG9yfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4gICAgc2VsZi5tYXN0ZXJDcmVkZW50aWFscy5nZXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzID0gc2VsZi5tYXN0ZXJDcmVkZW50aWFscztcbiAgICAgIHZhciBvcGVyYXRpb24gPSBzZWxmLnBhcmFtcy5Sb2xlQXJuID9cbiAgICAgICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGUgOiBzZWxmLnNlcnZpY2UuZ2V0U2Vzc2lvblRva2VuO1xuICAgICAgb3BlcmF0aW9uLmNhbGwoc2VsZi5zZXJ2aWNlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZE1hc3RlckNyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkTWFzdGVyQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpIHtcbiAgICB0aGlzLm1hc3RlckNyZWRlbnRpYWxzID0gbWFzdGVyQ3JlZGVudGlhbHMgfHwgQVdTLmNvbmZpZy5jcmVkZW50aWFscztcbiAgICB3aGlsZSAodGhpcy5tYXN0ZXJDcmVkZW50aWFscy5tYXN0ZXJDcmVkZW50aWFscykge1xuICAgICAgdGhpcy5tYXN0ZXJDcmVkZW50aWFscyA9IHRoaXMubWFzdGVyQ3JlZGVudGlhbHMubWFzdGVyQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hc3RlckNyZWRlbnRpYWxzLmdldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5tYXN0ZXJDcmVkZW50aWFscyA9IG5ldyBBV1MuQ3JlZGVudGlhbHModGhpcy5tYXN0ZXJDcmVkZW50aWFscyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU1RTLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQG92ZXJsb2FkIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscyA9IG51bGwpXG4gICAqICAgQ3JlYXRlcyBhIGNyZWRlbnRpYWxzIG9iamVjdCBmcm9tIFNUUyByZXNwb25zZSBkYXRhIGNvbnRhaW5pbmdcbiAgICogICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbi4gVXNlZnVsIGZvciBxdWlja2x5IHNldHRpbmcgQVdTIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiAgIEBub3RlIFRoaXMgaXMgYSBsb3ctbGV2ZWwgdXRpbGl0eSBmdW5jdGlvbi4gSWYgeW91IHdhbnQgdG8gbG9hZCB0ZW1wb3JhcnlcbiAgICogICAgIGNyZWRlbnRpYWxzIGludG8geW91ciBwcm9jZXNzIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzIHRvIEFXUyByZXNvdXJjZXMsXG4gICAqICAgICB5b3Ugc2hvdWxkIHVzZSB7QVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzfSBpbnN0ZWFkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIGRhdGEgcmV0cmlldmVkIGZyb20gYSBjYWxsIHRvIHtnZXRGZWRlcmF0ZWRUb2tlbn0sXG4gICAqICAgICB7Z2V0U2Vzc2lvblRva2VufSwge2Fzc3VtZVJvbGV9LCBvciB7YXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIGFuIG9wdGlvbmFsIGNyZWRlbnRpYWxzIG9iamVjdCB0b1xuICAgKiAgICAgZmlsbCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9iamVjdC4gVXNlZnVsIHdoZW4gbW9kaWZ5aW5nIGFuXG4gICAqICAgICBleGlzdGluZyBjcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIHJlZnJlc2ggY2FsbC5cbiAgICogICBAcmV0dXJuIFtBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHNdIHRoZSBzZXQgb2YgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgICBsb2FkZWQgZnJvbSBhIHJhdyBTVFMgb3BlcmF0aW9uIHJlc3BvbnNlLlxuICAgKiAgIEBleGFtcGxlIFVzaW5nIGNyZWRlbnRpYWxzRnJvbSB0byBsb2FkIGdsb2JhbCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBzdHMgPSBuZXcgQVdTLlNUUygpO1xuICAgKiAgICAgc3RzLmdldFNlc3Npb25Ub2tlbihmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKFwiRXJyb3IgZ2V0dGluZyBjcmVkZW50aWFsc1wiKTtcbiAgICogICAgICAgZWxzZSB7XG4gICAqICAgICAgICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IHN0cy5jcmVkZW50aWFsc0Zyb20oZGF0YSk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pO1xuICAgKiAgIEBzZWUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzXG4gICAqL1xuICBjcmVkZW50aWFsc0Zyb206IGZ1bmN0aW9uIGNyZWRlbnRpYWxzRnJvbShkYXRhLCBjcmVkZW50aWFscykge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFjcmVkZW50aWFscykgY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKCk7XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEFjY2Vzc0tleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICAgIHJldHVybiBjcmVkZW50aWFscztcbiAgfSxcblxuICBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5OiBmdW5jdGlvbiBhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGFzc3VtZVJvbGVXaXRoU0FNTDogZnVuY3Rpb24gYXNzdW1lUm9sZVdpdGhTQU1MKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnYXNzdW1lUm9sZVdpdGhTQU1MJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvc3RzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInZlcnNpb25cIjpcIjIuMFwiLFwibWV0YWRhdGFcIjp7XCJhcGlWZXJzaW9uXCI6XCIyMDExLTA2LTE1XCIsXCJlbmRwb2ludFByZWZpeFwiOlwic3RzXCIsXCJnbG9iYWxFbmRwb2ludFwiOlwic3RzLmFtYXpvbmF3cy5jb21cIixcInByb3RvY29sXCI6XCJxdWVyeVwiLFwic2VydmljZUFiYnJldmlhdGlvblwiOlwiQVdTIFNUU1wiLFwic2VydmljZUZ1bGxOYW1lXCI6XCJBV1MgU2VjdXJpdHkgVG9rZW4gU2VydmljZVwiLFwic2lnbmF0dXJlVmVyc2lvblwiOlwidjRcIixcInVpZFwiOlwic3RzLTIwMTEtMDYtMTVcIixcInhtbE5hbWVzcGFjZVwiOlwiaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS9cIn0sXCJvcGVyYXRpb25zXCI6e1wiQXNzdW1lUm9sZVwiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlJvbGVBcm5cIixcIlJvbGVTZXNzaW9uTmFtZVwiXSxcIm1lbWJlcnNcIjp7XCJSb2xlQXJuXCI6e30sXCJSb2xlU2Vzc2lvbk5hbWVcIjp7fSxcIlBvbGljeVwiOnt9LFwiRHVyYXRpb25TZWNvbmRzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIkV4dGVybmFsSWRcIjp7fSxcIlNlcmlhbE51bWJlclwiOnt9LFwiVG9rZW5Db2RlXCI6e319fSxcIm91dHB1dFwiOntcInJlc3VsdFdyYXBwZXJcIjpcIkFzc3VtZVJvbGVSZXN1bHRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkNyZWRlbnRpYWxzXCI6e1wic2hhcGVcIjpcIlNhXCJ9LFwiQXNzdW1lZFJvbGVVc2VyXCI6e1wic2hhcGVcIjpcIlNmXCJ9LFwiUGFja2VkUG9saWN5U2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn19fX0sXCJBc3N1bWVSb2xlV2l0aFNBTUxcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJSb2xlQXJuXCIsXCJQcmluY2lwYWxBcm5cIixcIlNBTUxBc3NlcnRpb25cIl0sXCJtZW1iZXJzXCI6e1wiUm9sZUFyblwiOnt9LFwiUHJpbmNpcGFsQXJuXCI6e30sXCJTQU1MQXNzZXJ0aW9uXCI6e30sXCJQb2xpY3lcIjp7fSxcIkR1cmF0aW9uU2Vjb25kc1wiOntcInR5cGVcIjpcImludGVnZXJcIn19fSxcIm91dHB1dFwiOntcInJlc3VsdFdyYXBwZXJcIjpcIkFzc3VtZVJvbGVXaXRoU0FNTFJlc3VsdFwiLFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiQ3JlZGVudGlhbHNcIjp7XCJzaGFwZVwiOlwiU2FcIn0sXCJBc3N1bWVkUm9sZVVzZXJcIjp7XCJzaGFwZVwiOlwiU2ZcIn0sXCJQYWNrZWRQb2xpY3lTaXplXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIlN1YmplY3RcIjp7fSxcIlN1YmplY3RUeXBlXCI6e30sXCJJc3N1ZXJcIjp7fSxcIkF1ZGllbmNlXCI6e30sXCJOYW1lUXVhbGlmaWVyXCI6e319fX0sXCJBc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiUm9sZUFyblwiLFwiUm9sZVNlc3Npb25OYW1lXCIsXCJXZWJJZGVudGl0eVRva2VuXCJdLFwibWVtYmVyc1wiOntcIlJvbGVBcm5cIjp7fSxcIlJvbGVTZXNzaW9uTmFtZVwiOnt9LFwiV2ViSWRlbnRpdHlUb2tlblwiOnt9LFwiUHJvdmlkZXJJZFwiOnt9LFwiUG9saWN5XCI6e30sXCJEdXJhdGlvblNlY29uZHNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9fX0sXCJvdXRwdXRcIjp7XCJyZXN1bHRXcmFwcGVyXCI6XCJBc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5UmVzdWx0XCIsXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJDcmVkZW50aWFsc1wiOntcInNoYXBlXCI6XCJTYVwifSxcIlN1YmplY3RGcm9tV2ViSWRlbnRpdHlUb2tlblwiOnt9LFwiQXNzdW1lZFJvbGVVc2VyXCI6e1wic2hhcGVcIjpcIlNmXCJ9LFwiUGFja2VkUG9saWN5U2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJQcm92aWRlclwiOnt9LFwiQXVkaWVuY2VcIjp7fX19fSxcIkRlY29kZUF1dGhvcml6YXRpb25NZXNzYWdlXCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiRW5jb2RlZE1lc3NhZ2VcIl0sXCJtZW1iZXJzXCI6e1wiRW5jb2RlZE1lc3NhZ2VcIjp7fX19LFwib3V0cHV0XCI6e1wicmVzdWx0V3JhcHBlclwiOlwiRGVjb2RlQXV0aG9yaXphdGlvbk1lc3NhZ2VSZXN1bHRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkRlY29kZWRNZXNzYWdlXCI6e319fX0sXCJHZXRDYWxsZXJJZGVudGl0eVwiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e319LFwib3V0cHV0XCI6e1wicmVzdWx0V3JhcHBlclwiOlwiR2V0Q2FsbGVySWRlbnRpdHlSZXN1bHRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlVzZXJJZFwiOnt9LFwiQWNjb3VudFwiOnt9LFwiQXJuXCI6e319fX0sXCJHZXRGZWRlcmF0aW9uVG9rZW5cIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJOYW1lXCJdLFwibWVtYmVyc1wiOntcIk5hbWVcIjp7fSxcIlBvbGljeVwiOnt9LFwiRHVyYXRpb25TZWNvbmRzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifX19LFwib3V0cHV0XCI6e1wicmVzdWx0V3JhcHBlclwiOlwiR2V0RmVkZXJhdGlvblRva2VuUmVzdWx0XCIsXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJDcmVkZW50aWFsc1wiOntcInNoYXBlXCI6XCJTYVwifSxcIkZlZGVyYXRlZFVzZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiRmVkZXJhdGVkVXNlcklkXCIsXCJBcm5cIl0sXCJtZW1iZXJzXCI6e1wiRmVkZXJhdGVkVXNlcklkXCI6e30sXCJBcm5cIjp7fX19LFwiUGFja2VkUG9saWN5U2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn19fX0sXCJHZXRTZXNzaW9uVG9rZW5cIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkR1cmF0aW9uU2Vjb25kc1wiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJTZXJpYWxOdW1iZXJcIjp7fSxcIlRva2VuQ29kZVwiOnt9fX0sXCJvdXRwdXRcIjp7XCJyZXN1bHRXcmFwcGVyXCI6XCJHZXRTZXNzaW9uVG9rZW5SZXN1bHRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkNyZWRlbnRpYWxzXCI6e1wic2hhcGVcIjpcIlNhXCJ9fX19fSxcInNoYXBlc1wiOntcIlNhXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkFjY2Vzc0tleUlkXCIsXCJTZWNyZXRBY2Nlc3NLZXlcIixcIlNlc3Npb25Ub2tlblwiLFwiRXhwaXJhdGlvblwiXSxcIm1lbWJlcnNcIjp7XCJBY2Nlc3NLZXlJZFwiOnt9LFwiU2VjcmV0QWNjZXNzS2V5XCI6e30sXCJTZXNzaW9uVG9rZW5cIjp7fSxcIkV4cGlyYXRpb25cIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn19fSxcIlNmXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkFzc3VtZWRSb2xlSWRcIixcIkFyblwiXSxcIm1lbWJlcnNcIjp7XCJBc3N1bWVkUm9sZUlkXCI6e30sXCJBcm5cIjp7fX19fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvc3RzLTIwMTEtMDYtMTUubWluLmpzb25cbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wicGFnaW5hdGlvblwiOnt9fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9zdHMtMjAxMS0wNi0xNS5wYWdpbmF0b3JzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDIzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4uIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBXZWJJZGVudGl0eVRva2VuYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCBhbmQgYFdlYklkZW50aXR5VG9rZW5gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBXZWJJZGVudGl0eVRva2VuLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuV2ViSWRlbnRpdHlUb2tlbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVG8gdXBkYXRlIHRoZSB0b2tlbiwgc2V0IHRoZVxuICogICAgIGBwYXJhbXMuV2ViSWRlbnRpdHlUb2tlbmAgcHJvcGVydHkuXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIHJhdyBkYXRhIHJlc3BvbnNlIGZyb20gdGhlIGNhbGwgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gZ2V0XG4gKiAgICAgYWNjZXNzIHRvIG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gKi9cbkFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLldlYklkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvV2ViSWRlbnRpdHknLFxuICAgKiAgICAgV2ViSWRlbnRpdHlUb2tlbjogJ0FCQ0RFRkdISUpLTE1OT1AnLCAvLyB0b2tlbiBmcm9tIGlkZW50aXR5IHNlcnZpY2VcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicgLy8gb3B0aW9uYWwgbmFtZSwgZGVmYXVsdHMgdG8gd2ViLWlkZW50aXR5XG4gICAqICAgfSwge1xuICAgKiAgICAgLy8gb3B0aW9uYWxseSBwcm92aWRlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIHVuZGVybHlpbmcgQVdTLlNUUyBzZXJ2aWNlIGNsaWVudFxuICAgKiAgICAgLy8gaWYgY29uZmlndXJhdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gY29uZmlndXJhdGlvbiB3aWxsIGJlIHB1bGxlZCBmcm9tIEFXUy5jb25maWdcbiAgICpcbiAgICogICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gV2ViSWRlbnRpdHlDcmVkZW50aWFscyhwYXJhbXMsIGNsaWVudENvbmZpZykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID0gdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd3ZWItaWRlbnRpdHknO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4gICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlKSB7XG4gICAgICB2YXIgc3RzQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIHRoaXMuX2NsaWVudENvbmZpZyk7XG4gICAgICBzdHNDb25maWcucGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBuZXcgU1RTKHN0c0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIENvZ25pdG9JZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvY29nbml0b2lkZW50aXR5Jyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiB1c2luZ1xuICogdGhlIEFtYXpvbiBDb2duaXRvIElkZW50aXR5IHNlcnZpY2UuXG4gKlxuICogQnkgZGVmYXVsdCB0aGlzIHByb3ZpZGVyIGdldHMgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSBzZXJ2aWNlIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJlcXVpcmVzIGVpdGhlciBhbiBgSWRlbnRpdHlJZGAgb3IgYW4gYElkZW50aXR5UG9vbElkYCAoQW1hem9uIENvZ25pdG9cbiAqIElkZW50aXR5IFBvb2wgSUQpLCB3aGljaCBpcyB1c2VkIHRvIGNhbGwge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWR9IHRvXG4gKiBvYnRhaW4gYW4gYElkZW50aXR5SWRgLiBJZiB0aGUgaWRlbnRpdHkgb3IgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZCBpblxuICogdGhlIEFtYXpvbiBDb2duaXRvIENvbnNvbGUgdG8gdXNlIElBTSByb2xlcyB3aXRoIHRoZSBhcHByb3ByaWF0ZSBwZXJtaXNzaW9ucyxcbiAqIHRoZW4gYWRkaXRpb25hbGx5IGEgYFJvbGVBcm5gIGlzIHJlcXVpcmVkIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0XG4gKiBwb2xpY3kgZm9yIHRoZSBBbWF6b24gQ29nbml0byByb2xlIHRoYXQgdGhlIHVzZXIgd2lsbCBsb2cgaW50by4gSWYgYSBgUm9sZUFybmBcbiAqIGlzIHByb3ZpZGVkLCB0aGVuIHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLCBhZnRlciBmaXJzdCBnZXR0aW5nIGFuXG4gKiBPcGVuIElEIHRva2VuIGZyb20ge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LlxuICpcbiAqIEluIGFkZGl0aW9uLCBpZiB0aGlzIGNyZWRlbnRpYWwgcHJvdmlkZXIgaXMgdXNlZCB0byBwcm92aWRlIGF1dGhlbnRpY2F0ZWRcbiAqIGxvZ2luLCB0aGUgYExvZ2luc2AgbWFwIG1heSBiZSBzZXQgdG8gdGhlIHRva2VucyBwcm92aWRlZCBieSB0aGUgcmVzcGVjdGl2ZVxuICogaWRlbnRpdHkgcHJvdmlkZXJzLiBTZWUge2NvbnN0cnVjdG9yfSBmb3IgYW4gZXhhbXBsZSBvbiBjcmVhdGluZyBhIGNyZWRlbnRpYWxzXG4gKiBvYmplY3Qgd2l0aCBwcm9wZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFdlYklkZW50aXR5VG9rZW4sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5Mb2dpbnNbJ2dyYXBoLmZhY2Vib29rLmNvbSddID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldElkfSxcbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0sIGFuZFxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5XZWJJZGVudGl0eVRva2VuYCBwcm9wZXJ0eS5cbiAqIEAhYXR0cmlidXRlIGRhdGFcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgcmF3IGRhdGEgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9LCBvclxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBnZXRcbiAqICAgICBhY2Nlc3MgdG8gb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXNwb25zZS5cbiAqIEAhYXR0cmlidXRlIGlkZW50aXR5SWRcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQ29nbml0byBJRCByZXR1cm5lZCBieSB0aGUgbGFzdCBjYWxsIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LiBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGFjdHVhbFxuICogICAgIGZpbmFsIHJlc29sdmVkIGlkZW50aXR5IElEIGZyb20gQW1hem9uIENvZ25pdG8uXG4gKi9cbkFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvY2FsU3RvcmFnZUtleToge1xuICAgIGlkOiAnYXdzLmNvZ25pdG8uaWRlbnRpdHktaWQuJyxcbiAgICBwcm92aWRlcnM6ICdhd3MuY29nbml0by5pZGVudGl0eS1wcm92aWRlcnMuJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKlxuICAgKiAgICAgLy8gZWl0aGVyIElkZW50aXR5UG9vbElkIG9yIElkZW50aXR5SWQgaXMgcmVxdWlyZWRcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlQb29sSWQgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SUQgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlJZCBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5XG4gICAqICAgICAvLyBvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBJZGVudGl0eVBvb2xJZDogJ3VzLWVhc3QtMToxNjk5ZWJjMC03OTAwLTQwOTktYjkxMC0yZGY5NGY1MmEwMzAnLFxuICAgKiAgICAgSWRlbnRpdHlJZDogJ3VzLWVhc3QtMToxMjhkMGE3NC1jODJmLTQ1NTMtOTE2ZC05MDA1M2U0YThiMGYnXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiB0aGUgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZFxuICAgKiAgICAgLy8gdG8gdXNlIElBTSByb2xlcyBpbiB0aGUgQW1hem9uIENvZ25pdG8gQ29uc29sZVxuICAgKiAgICAgLy8gU2VlIHRoZSBSb2xlQXJuIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL01ZQVBQLUNvZ25pdG9JZGVudGl0eScsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCB0b2tlbnMsIHVzZWQgZm9yIGF1dGhlbnRpY2F0ZWQgbG9naW5cbiAgICogICAgIC8vIFNlZSB0aGUgTG9naW5zIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldElEIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBMb2dpbnM6IHtcbiAgICogICAgICAgJ2dyYXBoLmZhY2Vib29rLmNvbSc6ICdGQlRPS0VOJyxcbiAgICogICAgICAgJ3d3dy5hbWF6b24uY29tJzogJ0FNQVpPTlRPS0VOJyxcbiAgICogICAgICAgJ2FjY291bnRzLmdvb2dsZS5jb20nOiAnR09PR0xFVE9LRU4nLFxuICAgKiAgICAgICAnYXBpLnR3aXR0ZXIuY29tJzogJ1RXSVRURVJUT0tFTicsXG4gICAqICAgICAgICd3d3cuZGlnaXRzLmNvbSc6ICdESUdJVFNUT0tFTidcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCBuYW1lLCBkZWZhdWx0cyB0byB3ZWItaWRlbnRpdHlcbiAgICogICAgIC8vIFNlZSB0aGUgUm9sZVNlc3Npb25OYW1lIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiBhcHBsaWNhdGlvbiBydW5zIGluIGEgYnJvd3NlclxuICAgKiAgICAgLy8gYW5kIG11bHRpcGxlIHVzZXJzIGFyZSBzaWduZWQgaW4gYXQgb25jZSwgdXNlZCBmb3IgY2FjaGluZ1xuICAgKiAgICAgTG9naW5JZDogJ2V4YW1wbGVAZ21haWwuY29tJ1xuICAgKlxuICAgKiAgIH0sIHtcbiAgICogICAgICAvLyBvcHRpb25hbGx5IHByb3ZpZGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgdW5kZXJseWluZyBzZXJ2aWNlIGNsaWVudHNcbiAgICogICAgICAvLyBpZiBjb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBjb25maWd1cmF0aW9uIHdpbGwgYmUgcHVsbGVkIGZyb20gQVdTLmNvbmZpZ1xuICAgKlxuICAgKiAgICAgIC8vIHJlZ2lvbiBzaG91bGQgbWF0Y2ggdGhlIHJlZ2lvbiB5b3VyIGlkZW50aXR5IHBvb2wgaXMgbG9jYXRlZCBpblxuICAgKiAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAqXG4gICAqICAgICAgLy8gc3BlY2lmeSB0aW1lb3V0IG9wdGlvbnNcbiAgICogICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWRcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuXG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKiBAbm90ZSBJZiBhIHJlZ2lvbiBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIGdsb2JhbCBBV1MuY29uZmlnLCBvclxuICAgKiAgIHNwZWNpZmllZCBpbiB0aGUgYGNsaWVudENvbmZpZ2AgdG8gdGhlIENvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzXG4gICAqICAgY29uc3RydWN0b3IsIHlvdSBtYXkgZW5jb3VudGVyIGEgJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnJyBlcnJvclxuICAgKiAgIHdoZW4gY2FsbGluZyBtYWtpbmcgYSBzZXJ2aWNlIGNhbGwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICAgIHRoaXMubG9hZENhY2hlZElkKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWRlbnRpdHlJZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYubG9hZENhY2hlZElkKCk7XG4gICAgICAgIHJldHVybiBzZWxmLl9pZGVudGl0eUlkIHx8IHNlbGYucGFyYW1zLklkZW50aXR5SWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYuX2lkZW50aXR5SWQgPSBpZGVudGl0eUlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0sXG4gICAqIG9yIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIEFXUy5DcmVkZW50aWFscy5nZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICBzZWxmLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBzZWxmLmdldElkKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgaWYgKCFzZWxmLnBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICAgICAgc2VsZi5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmdldENyZWRlbnRpYWxzRnJvbVNUUyhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBDb2duaXRvIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWRcbiAgICogaWRlbnRpdHkgcG9vbCBJRC4gVXNlIHRoaXMgdG8gbWFudWFsbHkgaW52YWxpZGF0ZSB5b3VyIGNhY2hlIGlmXG4gICAqIHRoZSBpZGVudGl0eSBwb29sIElEIHdhcyBkZWxldGVkLlxuICAgKi9cbiAgY2xlYXJDYWNoZWRJZDogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBkZWxldGUgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZDtcblxuICAgIHZhciBwb29sSWQgPSB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZDtcbiAgICB2YXIgbG9naW5JZCA9IHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJyc7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleS5pZCArIHBvb2xJZCArIGxvZ2luSWRdO1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXkucHJvdmlkZXJzICsgcG9vbElkICsgbG9naW5JZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXJJZE9uTm90QXV0aG9yaXplZDogZnVuY3Rpb24gY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGVyci5jb2RlID09ICdOb3RBdXRob3JpemVkRXhjZXB0aW9uJykge1xuICAgICAgc2VsZi5jbGVhckNhY2hlZElkKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBDb2duaXRvIElELCBsb2FkaW5nIGZyb20gY2FjaGUgaWYgaXQgd2FzIGFscmVhZHkgcmV0cmlldmVkXG4gICAqIG9uIHRoaXMgZGV2aWNlLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBpZGVudGl0eUlkKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yLCBudWxsXSBhbiBlcnJvciBvYmplY3QgaWYgdGhlIGNhbGwgZmFpbGVkIG9yIG51bGwgaWZcbiAgICogICAgIGl0IHN1Y2NlZWRlZC5cbiAgICogICBAcGFyYW0gaWRlbnRpdHlJZCBbU3RyaW5nLCBudWxsXSBpZiBzdWNjZXNzZnVsLCB0aGUgY2FsbGJhY2sgd2lsbCByZXR1cm5cbiAgICogICAgIHRoZSBDb2duaXRvIElELlxuICAgKiBAbm90ZSBJZiBub3QgbG9hZGVkIGV4cGxpY2l0bHksIHRoZSBDb2duaXRvIElEIGlzIGxvYWRlZCBhbmQgc3RvcmVkIGluXG4gICAqICAgbG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9mIGEgZGV2aWNlLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCk7XG4gICAgfVxuXG4gICAgc2VsZi5jb2duaXRvLmdldElkKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YS5JZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEuSWRlbnRpdHlJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkQ3JlZGVudGlhbHMoZGF0YSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWRhdGEgfHwgIWNyZWRlbnRpYWxzKSByZXR1cm47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEtleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHk6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBzZWxmLmNhY2hlSWQoZGF0YSk7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubG9hZENyZWRlbnRpYWxzKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHNGcm9tU1RTOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0Zyb21TVFMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldE9wZW5JZFRva2VuKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5jYWNoZUlkKGRhdGEpO1xuICAgICAgICBzZWxmLnBhcmFtcy5XZWJJZGVudGl0eVRva2VuID0gZGF0YS5Ub2tlbjtcbiAgICAgICAgc2VsZi53ZWJJZGVudGl0eUNyZWRlbnRpYWxzLnJlZnJlc2goZnVuY3Rpb24od2ViRXJyKSB7XG4gICAgICAgICAgaWYgKCF3ZWJFcnIpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHNlbGYud2ViSWRlbnRpdHlDcmVkZW50aWFscy5kYXRhO1xuICAgICAgICAgICAgc2VsZi5zdHMuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHdlYkVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENhY2hlZElkOiBmdW5jdGlvbiBsb2FkQ2FjaGVkSWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW4gdGhlIGJyb3dzZXIgd2Ugc291cmNlIGRlZmF1bHQgSWRlbnRpdHlJZCBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSAmJiAhc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCkge1xuICAgICAgdmFyIGlkID0gc2VsZi5nZXRTdG9yYWdlKCdpZCcpO1xuICAgICAgaWYgKGlkICYmIHNlbGYucGFyYW1zLkxvZ2lucykge1xuICAgICAgICB2YXIgYWN0dWFsUHJvdmlkZXJzID0gT2JqZWN0LmtleXMoc2VsZi5wYXJhbXMuTG9naW5zKTtcbiAgICAgICAgdmFyIGNhY2hlZFByb3ZpZGVycyA9XG4gICAgICAgICAgKHNlbGYuZ2V0U3RvcmFnZSgncHJvdmlkZXJzJykgfHwgJycpLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgLy8gb25seSBsb2FkIElEIGlmIGF0IGxlYXN0IG9uZSBwcm92aWRlciB1c2VkIHRoaXMgSUQgYmVmb3JlXG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSBjYWNoZWRQcm92aWRlcnMuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gYWN0dWFsUHJvdmlkZXJzLmluZGV4T2YobikgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWQpIHtcbiAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGlkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDbGllbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xpZW50Q29uZmlnID0gdGhpcy5fY2xpZW50Q29uZmlnO1xuICAgIHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyB8fFxuICAgICAgbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHRoaXMucGFyYW1zLCBjbGllbnRDb25maWcpO1xuICAgIGlmICghdGhpcy5jb2duaXRvKSB7XG4gICAgICB2YXIgY29nbml0b0NvbmZpZyA9IEFXUy51dGlsLm1lcmdlKHt9LCBjbGllbnRDb25maWcpO1xuICAgICAgY29nbml0b0NvbmZpZy5wYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMuY29nbml0byA9IG5ldyBDb2duaXRvSWRlbnRpdHkoY29nbml0b0NvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuc3RzID0gdGhpcy5zdHMgfHwgbmV3IFNUUyhjbGllbnRDb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhY2hlSWQ6IGZ1bmN0aW9uIGNhY2hlSWQoZGF0YSkge1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZCA9IHRoaXMuX2lkZW50aXR5SWQ7XG5cbiAgICAvLyBjYWNoZSB0aGlzIElkZW50aXR5SWQgaW4gYnJvd3NlciBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RvcmFnZSgnaWQnLCBkYXRhLklkZW50aXR5SWQpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuTG9naW5zKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcmFnZSgncHJvdmlkZXJzJywgT2JqZWN0LmtleXModGhpcy5wYXJhbXMuTG9naW5zKS5qb2luKCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTdG9yYWdlOiBmdW5jdGlvbiBnZXRTdG9yYWdlKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXlba2V5XSArIHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkICsgKHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJycpXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRTdG9yYWdlOiBmdW5jdGlvbiBzZXRTdG9yYWdlKGtleSwgdmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleVtrZXldICsgdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQgKyAodGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJyldID0gdmFsO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc3RvcmFnZTogKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc3RvcmFnZSA9IEFXUy51dGlsLmlzQnJvd3NlcigpICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPT09ICdvYmplY3QnID9cbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlIDoge307XG5cbiAgICAgIC8vIFRlc3Qgc2V0L3JlbW92ZSB3aGljaCB3b3VsZCB0aHJvdyBhbiBlcnJvciBpbiBTYWZhcmkncyBwcml2YXRlIGJyb3dzaW5nXG4gICAgICBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ10gPSAnZm9vYmFyJztcbiAgICAgIGRlbGV0ZSBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ107XG5cbiAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH0pKClcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscy5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydjb2duaXRvaWRlbnRpdHknXSA9IHt9O1xuQVdTLkNvZ25pdG9JZGVudGl0eSA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnY29nbml0b2lkZW50aXR5JywgWycyMDE0LTA2LTMwJ10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL2NvZ25pdG9pZGVudGl0eScpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snY29nbml0b2lkZW50aXR5J10sICcyMDE0LTA2LTMwJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5taW4uanNvbicpO1xuICAgIG1vZGVsLnBhZ2luYXRvcnMgPSByZXF1aXJlKCcuLi9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5wYWdpbmF0b3JzLmpzb24nKS5wYWdpbmF0aW9uO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuQ29nbml0b0lkZW50aXR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL2NvZ25pdG9pZGVudGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5Db2duaXRvSWRlbnRpdHkucHJvdG90eXBlLCB7XG4gIGdldE9wZW5JZFRva2VuOiBmdW5jdGlvbiBnZXRPcGVuSWRUb2tlbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2dldE9wZW5JZFRva2VuJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnZ2V0SWQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5OiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL2NvZ25pdG9pZGVudGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJ2ZXJzaW9uXCI6XCIyLjBcIixcIm1ldGFkYXRhXCI6e1wiYXBpVmVyc2lvblwiOlwiMjAxNC0wNi0zMFwiLFwiZW5kcG9pbnRQcmVmaXhcIjpcImNvZ25pdG8taWRlbnRpdHlcIixcImpzb25WZXJzaW9uXCI6XCIxLjFcIixcInByb3RvY29sXCI6XCJqc29uXCIsXCJzZXJ2aWNlRnVsbE5hbWVcIjpcIkFtYXpvbiBDb2duaXRvIElkZW50aXR5XCIsXCJzaWduYXR1cmVWZXJzaW9uXCI6XCJ2NFwiLFwidGFyZ2V0UHJlZml4XCI6XCJBV1NDb2duaXRvSWRlbnRpdHlTZXJ2aWNlXCIsXCJ1aWRcIjpcImNvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMFwifSxcIm9wZXJhdGlvbnNcIjp7XCJDcmVhdGVJZGVudGl0eVBvb2xcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZGVudGl0eVBvb2xOYW1lXCIsXCJBbGxvd1VuYXV0aGVudGljYXRlZElkZW50aXRpZXNcIl0sXCJtZW1iZXJzXCI6e1wiSWRlbnRpdHlQb29sTmFtZVwiOnt9LFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcIlN1cHBvcnRlZExvZ2luUHJvdmlkZXJzXCI6e1wic2hhcGVcIjpcIlM0XCJ9LFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6e30sXCJPcGVuSWRDb25uZWN0UHJvdmlkZXJBUk5zXCI6e1wic2hhcGVcIjpcIlM4XCJ9LFwiQ29nbml0b0lkZW50aXR5UHJvdmlkZXJzXCI6e1wic2hhcGVcIjpcIlNhXCJ9LFwiU2FtbFByb3ZpZGVyQVJOc1wiOntcInNoYXBlXCI6XCJTZlwifX19LFwib3V0cHV0XCI6e1wic2hhcGVcIjpcIlNnXCJ9fSxcIkRlbGV0ZUlkZW50aXRpZXNcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZGVudGl0eUlkc1RvRGVsZXRlXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRzVG9EZWxldGVcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7fX19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlVucHJvY2Vzc2VkSWRlbnRpdHlJZHNcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJFcnJvckNvZGVcIjp7fX19fX19fSxcIkRlbGV0ZUlkZW50aXR5UG9vbFwiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIklkZW50aXR5UG9vbElkXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5UG9vbElkXCI6e319fX0sXCJEZXNjcmliZUlkZW50aXR5XCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlJZFwiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e319fSxcIm91dHB1dFwiOntcInNoYXBlXCI6XCJTclwifX0sXCJEZXNjcmliZUlkZW50aXR5UG9vbFwiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIklkZW50aXR5UG9vbElkXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5UG9vbElkXCI6e319fSxcIm91dHB1dFwiOntcInNoYXBlXCI6XCJTZ1wifX0sXCJHZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5XCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlJZFwiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJMb2dpbnNcIjp7XCJzaGFwZVwiOlwiU3dcIn0sXCJDdXN0b21Sb2xlQXJuXCI6e319fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRcIjp7fSxcIkNyZWRlbnRpYWxzXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiQWNjZXNzS2V5SWRcIjp7fSxcIlNlY3JldEtleVwiOnt9LFwiU2Vzc2lvblRva2VuXCI6e30sXCJFeHBpcmF0aW9uXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9fX19fX0sXCJHZXRJZFwiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIklkZW50aXR5UG9vbElkXCJdLFwibWVtYmVyc1wiOntcIkFjY291bnRJZFwiOnt9LFwiSWRlbnRpdHlQb29sSWRcIjp7fSxcIkxvZ2luc1wiOntcInNoYXBlXCI6XCJTd1wifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSWRlbnRpdHlJZFwiOnt9fX19LFwiR2V0SWRlbnRpdHlQb29sUm9sZXNcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZGVudGl0eVBvb2xJZFwiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eVBvb2xJZFwiOnt9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJZGVudGl0eVBvb2xJZFwiOnt9LFwiUm9sZXNcIjp7XCJzaGFwZVwiOlwiUzE4XCJ9LFwiUm9sZU1hcHBpbmdzXCI6e1wic2hhcGVcIjpcIlMxYVwifX19fSxcIkdldE9wZW5JZFRva2VuXCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlJZFwiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJMb2dpbnNcIjp7XCJzaGFwZVwiOlwiU3dcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRcIjp7fSxcIlRva2VuXCI6e319fX0sXCJHZXRPcGVuSWRUb2tlbkZvckRldmVsb3BlcklkZW50aXR5XCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlQb29sSWRcIixcIkxvZ2luc1wiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eVBvb2xJZFwiOnt9LFwiSWRlbnRpdHlJZFwiOnt9LFwiTG9naW5zXCI6e1wic2hhcGVcIjpcIlN3XCJ9LFwiVG9rZW5EdXJhdGlvblwiOntcInR5cGVcIjpcImxvbmdcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRcIjp7fSxcIlRva2VuXCI6e319fX0sXCJMaXN0SWRlbnRpdGllc1wiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIklkZW50aXR5UG9vbElkXCIsXCJNYXhSZXN1bHRzXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5UG9vbElkXCI6e30sXCJNYXhSZXN1bHRzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIk5leHRUb2tlblwiOnt9LFwiSGlkZURpc2FibGVkXCI6e1widHlwZVwiOlwiYm9vbGVhblwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSWRlbnRpdHlQb29sSWRcIjp7fSxcIklkZW50aXRpZXNcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJzaGFwZVwiOlwiU3JcIn19LFwiTmV4dFRva2VuXCI6e319fX0sXCJMaXN0SWRlbnRpdHlQb29sc1wiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIk1heFJlc3VsdHNcIl0sXCJtZW1iZXJzXCI6e1wiTWF4UmVzdWx0c1wiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJOZXh0VG9rZW5cIjp7fX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSWRlbnRpdHlQb29sc1wiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkZW50aXR5UG9vbElkXCI6e30sXCJJZGVudGl0eVBvb2xOYW1lXCI6e319fX0sXCJOZXh0VG9rZW5cIjp7fX19fSxcIkxvb2t1cERldmVsb3BlcklkZW50aXR5XCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlQb29sSWRcIl0sXCJtZW1iZXJzXCI6e1wiSWRlbnRpdHlQb29sSWRcIjp7fSxcIklkZW50aXR5SWRcIjp7fSxcIkRldmVsb3BlclVzZXJJZGVudGlmaWVyXCI6e30sXCJNYXhSZXN1bHRzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIk5leHRUb2tlblwiOnt9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllckxpc3RcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7fX0sXCJOZXh0VG9rZW5cIjp7fX19fSxcIk1lcmdlRGV2ZWxvcGVySWRlbnRpdGllc1wiOntcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlNvdXJjZVVzZXJJZGVudGlmaWVyXCIsXCJEZXN0aW5hdGlvblVzZXJJZGVudGlmaWVyXCIsXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIixcIklkZW50aXR5UG9vbElkXCJdLFwibWVtYmVyc1wiOntcIlNvdXJjZVVzZXJJZGVudGlmaWVyXCI6e30sXCJEZXN0aW5hdGlvblVzZXJJZGVudGlmaWVyXCI6e30sXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjp7fSxcIklkZW50aXR5UG9vbElkXCI6e319fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRcIjp7fX19fSxcIlNldElkZW50aXR5UG9vbFJvbGVzXCI6e1wiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlQb29sSWRcIixcIlJvbGVzXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5UG9vbElkXCI6e30sXCJSb2xlc1wiOntcInNoYXBlXCI6XCJTMThcIn0sXCJSb2xlTWFwcGluZ3NcIjp7XCJzaGFwZVwiOlwiUzFhXCJ9fX19LFwiVW5saW5rRGV2ZWxvcGVySWRlbnRpdHlcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZGVudGl0eUlkXCIsXCJJZGVudGl0eVBvb2xJZFwiLFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCIsXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJJZGVudGl0eVBvb2xJZFwiOnt9LFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6e30sXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiOnt9fX19LFwiVW5saW5rSWRlbnRpdHlcIjp7XCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZGVudGl0eUlkXCIsXCJMb2dpbnNcIixcIkxvZ2luc1RvUmVtb3ZlXCJdLFwibWVtYmVyc1wiOntcIklkZW50aXR5SWRcIjp7fSxcIkxvZ2luc1wiOntcInNoYXBlXCI6XCJTd1wifSxcIkxvZ2luc1RvUmVtb3ZlXCI6e1wic2hhcGVcIjpcIlNzXCJ9fX19LFwiVXBkYXRlSWRlbnRpdHlQb29sXCI6e1wiaW5wdXRcIjp7XCJzaGFwZVwiOlwiU2dcIn0sXCJvdXRwdXRcIjp7XCJzaGFwZVwiOlwiU2dcIn19fSxcInNoYXBlc1wiOntcIlM0XCI6e1widHlwZVwiOlwibWFwXCIsXCJrZXlcIjp7fSxcInZhbHVlXCI6e319LFwiUzhcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7fX0sXCJTYVwiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlByb3ZpZGVyTmFtZVwiOnt9LFwiQ2xpZW50SWRcIjp7fSxcIlNlcnZlclNpZGVUb2tlbkNoZWNrXCI6e1widHlwZVwiOlwiYm9vbGVhblwifX19fSxcIlNmXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e319LFwiU2dcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiSWRlbnRpdHlQb29sSWRcIixcIklkZW50aXR5UG9vbE5hbWVcIixcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiXSxcIm1lbWJlcnNcIjp7XCJJZGVudGl0eVBvb2xJZFwiOnt9LFwiSWRlbnRpdHlQb29sTmFtZVwiOnt9LFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcIlN1cHBvcnRlZExvZ2luUHJvdmlkZXJzXCI6e1wic2hhcGVcIjpcIlM0XCJ9LFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6e30sXCJPcGVuSWRDb25uZWN0UHJvdmlkZXJBUk5zXCI6e1wic2hhcGVcIjpcIlM4XCJ9LFwiQ29nbml0b0lkZW50aXR5UHJvdmlkZXJzXCI6e1wic2hhcGVcIjpcIlNhXCJ9LFwiU2FtbFByb3ZpZGVyQVJOc1wiOntcInNoYXBlXCI6XCJTZlwifX19LFwiU3JcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJZGVudGl0eUlkXCI6e30sXCJMb2dpbnNcIjp7XCJzaGFwZVwiOlwiU3NcIn0sXCJDcmVhdGlvbkRhdGVcIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJMYXN0TW9kaWZpZWREYXRlXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9fX0sXCJTc1wiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOnt9fSxcIlN3XCI6e1widHlwZVwiOlwibWFwXCIsXCJrZXlcIjp7fSxcInZhbHVlXCI6e319LFwiUzE4XCI6e1widHlwZVwiOlwibWFwXCIsXCJrZXlcIjp7fSxcInZhbHVlXCI6e319LFwiUzFhXCI6e1widHlwZVwiOlwibWFwXCIsXCJrZXlcIjp7fSxcInZhbHVlXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlR5cGVcIl0sXCJtZW1iZXJzXCI6e1wiVHlwZVwiOnt9LFwiQW1iaWd1b3VzUm9sZVJlc29sdXRpb25cIjp7fSxcIlJ1bGVzQ29uZmlndXJhdGlvblwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJSdWxlc1wiXSxcIm1lbWJlcnNcIjp7XCJSdWxlc1wiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJDbGFpbVwiLFwiTWF0Y2hUeXBlXCIsXCJWYWx1ZVwiLFwiUm9sZUFSTlwiXSxcIm1lbWJlcnNcIjp7XCJDbGFpbVwiOnt9LFwiTWF0Y2hUeXBlXCI6e30sXCJWYWx1ZVwiOnt9LFwiUm9sZUFSTlwiOnt9fX19fX19fX19fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9jb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzAubWluLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wicGFnaW5hdGlvblwiOnt9fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9jb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzAucGFnaW5hdG9ycy5qc29uXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgU0FNTCBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfSBzZXJ2aWNlIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb25cbiAqIHJlcXVpcmVzIGEgYFJvbGVBcm5gIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0IHBvbGljeSBmb3IgdGhlXG4gKiBhcHBsaWNhdGlvbiBmb3Igd2hpY2ggY3JlZGVudGlhbHMgd2lsbCBiZSBnaXZlbiwgYXMgd2VsbCBhcyBhIGBQcmluY2lwYWxBcm5gXG4gKiByZXByZXNlbnRpbmcgdGhlIEFSTiBmb3IgdGhlIFNBTUwgaWRlbnRpdHkgcHJvdmlkZXIuIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBTQU1MQXNzZXJ0aW9uYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCwgYFByaW5jaXBhbEFybmAsIGFuZCBgU0FNTEFzc2VydGlvbmAgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFNBTUxBc3NlcnRpb24sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5TQU1MQXNzZXJ0aW9uID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLlNBTUxBc3NlcnRpb25gIHByb3BlcnR5LlxuICovXG5BV1MuU0FNTENyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTClcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuU0FNTENyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxSb2xlJyxcbiAgICogICAgIFByaW5jaXBhbEFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvU0FNTFByaW5jaXBhbCcsXG4gICAqICAgICBTQU1MQXNzZXJ0aW9uOiAnYmFzZTY0LXRva2VuJywgLy8gYmFzZTY0LWVuY29kZWQgdG9rZW4gZnJvbSBJZFBcbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTFxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFNBTUxDcmVkZW50aWFscyhwYXJhbXMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfVxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhTQU1MKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuc2VydmljZS5jcmVkZW50aWFsc0Zyb20oZGF0YSwgc2VsZik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VydmljZSA9IHRoaXMuc2VydmljZSB8fCBuZXcgU1RTKHtwYXJhbXM6IHRoaXMucGFyYW1zfSk7XG4gIH1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9zYW1sX2NyZWRlbnRpYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG5cbmZ1bmN0aW9uIERvbVhtbFBhcnNlcigpIHsgfVxuXG5Eb21YbWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oeG1sLCBzaGFwZSkge1xuICBpZiAoeG1sLnJlcGxhY2UoL15cXHMrLywgJycpID09PSAnJykgcmV0dXJuIHt9O1xuXG4gIHZhciByZXN1bHQsIGVycm9yO1xuICB0cnkge1xuICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICByZXN1bHQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICB9IGNhdGNoIChzeW50YXhFcnJvcikge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBzeW50YXhFcnJvcixcbiAgICAgICAgICAgIGNvZGU6ICdYTUxQYXJzZXJFcnJvcicsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBlbXB0eSBkb2N1bWVudC4nKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Vycm9yID0gcmVzdWx0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuICAgICAgaWYgKGlzRXJyb3IgJiYgKGlzRXJyb3IucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnYm9keScgfHxcbiAgICAgICAgICBpc0Vycm9yLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdib2R5JykpIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGlzRXJyb3IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpWzBdIHx8IGlzRXJyb3I7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKGVycm9yRWxlbWVudC50ZXh0Q29udGVudCB8fCAnUGFyc2VyIGVycm9yIGluIGRvY3VtZW50JyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZTogJ1hNTFBhcnNlckVycm9yJyxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgcmVzdWx0LmFzeW5jID0gZmFsc2U7XG5cbiAgICAgIGlmICghcmVzdWx0LmxvYWRYTUwoeG1sKSkge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgWE1MIHBhcnNlcicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuXG4gIGlmIChyZXN1bHQgJiYgcmVzdWx0LmRvY3VtZW50RWxlbWVudCAmJiAhZXJyb3IpIHtcbiAgICB2YXIgZGF0YSA9IHBhcnNlWG1sKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQsIHNoYXBlKTtcbiAgICB2YXIgbWV0YWRhdGEgPSByZXN1bHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1Jlc3BvbnNlTWV0YWRhdGEnKVswXTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIGRhdGEuUmVzcG9uc2VNZXRhZGF0YSA9IHBhcnNlWG1sKG1ldGFkYXRhLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgdXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwge2NvZGU6ICdYTUxQYXJzZXJFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZX0pO1xuICB9IGVsc2UgeyAvLyBlbXB0eSB4bWwgZG9jdW1lbnRcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlWG1sKHhtbCwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSkgc2hhcGUgPSB7fTtcbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHBhcnNlU3RydWN0dXJlKHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiBwYXJzZU1hcCh4bWwsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHBhcnNlTGlzdCh4bWwsIHNoYXBlKTtcbiAgICBjYXNlIHVuZGVmaW5lZDogY2FzZSBudWxsOiByZXR1cm4gcGFyc2VVbmtub3duKHhtbCk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHBhcnNlU2NhbGFyKHhtbCwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RydWN0dXJlKHhtbCwgc2hhcGUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgaWYgKHhtbCA9PT0gbnVsbCkgcmV0dXJuIGRhdGE7XG5cbiAgdXRpbC5lYWNoKHNoYXBlLm1lbWJlcnMsIGZ1bmN0aW9uKG1lbWJlck5hbWUsIG1lbWJlclNoYXBlKSB7XG4gICAgaWYgKG1lbWJlclNoYXBlLmlzWG1sQXR0cmlidXRlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHhtbC5hdHRyaWJ1dGVzLCBtZW1iZXJTaGFwZS5uYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB4bWwuYXR0cmlidXRlc1ttZW1iZXJTaGFwZS5uYW1lXS52YWx1ZTtcbiAgICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IHBhcnNlWG1sKHt0ZXh0Q29udGVudDogdmFsdWV9LCBtZW1iZXJTaGFwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4bWxDaGlsZCA9IG1lbWJlclNoYXBlLmZsYXR0ZW5lZCA/IHhtbCA6XG4gICAgICAgIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShtZW1iZXJTaGFwZS5uYW1lKVswXTtcbiAgICAgIGlmICh4bWxDaGlsZCkge1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gcGFyc2VYbWwoeG1sQ2hpbGQsIG1lbWJlclNoYXBlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW1lbWJlclNoYXBlLmZsYXR0ZW5lZCAmJiBtZW1iZXJTaGFwZS50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgZGF0YVttZW1iZXJOYW1lXSA9IG1lbWJlclNoYXBlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuICB2YXIgdGFnTmFtZSA9IHNoYXBlLmZsYXR0ZW5lZCA/IHNoYXBlLm5hbWUgOiAnZW50cnknO1xuXG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICB2YXIga2V5ID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoeG1sS2V5KVswXS50ZXh0Q29udGVudDtcbiAgICAgIHZhciB2YWx1ZSA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKHhtbFZhbHVlKVswXTtcbiAgICAgIGRhdGFba2V5XSA9IHBhcnNlWG1sKHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpc3QoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgdGFnTmFtZSA9IHNoYXBlLmZsYXR0ZW5lZCA/IHNoYXBlLm5hbWUgOiAoc2hhcGUubWVtYmVyLm5hbWUgfHwgJ21lbWJlcicpO1xuXG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLm5vZGVOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICBkYXRhLnB1c2gocGFyc2VYbWwoY2hpbGQsIHNoYXBlLm1lbWJlcikpO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTY2FsYXIoeG1sLCBzaGFwZSkge1xuICBpZiAoeG1sLmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciBlbmNvZGluZyA9IHhtbC5nZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJyk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgc2hhcGUgPSBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiBlbmNvZGluZ30pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXh0ID0geG1sLnRleHRDb250ZW50O1xuICBpZiAodGV4dCA9PT0gJycpIHRleHQgPSBudWxsO1xuICBpZiAodHlwZW9mIHNoYXBlLnRvVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaGFwZS50b1R5cGUodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VVbmtub3duKHhtbCkge1xuICBpZiAoeG1sID09PSB1bmRlZmluZWQgfHwgeG1sID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgLy8gZW1wdHkgb2JqZWN0XG4gIGlmICgheG1sLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgaWYgKHhtbC5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiB7fTtcbiAgICBpZiAoeG1sLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgZWxzZSByZXR1cm4geG1sLnRleHRDb250ZW50O1xuICB9XG5cbiAgLy8gb2JqZWN0LCBwYXJzZSBhcyBzdHJ1Y3R1cmVcbiAgdmFyIHNoYXBlID0ge3R5cGU6ICdzdHJ1Y3R1cmUnLCBtZW1iZXJzOiB7fX07XG4gIHZhciBjaGlsZCA9IHhtbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgdmFyIHRhZyA9IGNoaWxkLm5vZGVOYW1lO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcGUubWVtYmVycywgdGFnKSkge1xuICAgICAgLy8gbXVsdGlwbGUgdGFncyBvZiB0aGUgc2FtZSBuYW1lIG1ha2VzIGl0IGEgbGlzdFxuICAgICAgc2hhcGUubWVtYmVyc1t0YWddLnR5cGUgPSAnbGlzdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlLm1lbWJlcnNbdGFnXSA9IHtuYW1lOiB0YWd9O1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRG9tWG1sUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2Jyb3dzZXJfcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnJlcXVpcmUoJy4uL2h0dHAnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlhIUkNsaWVudCA9IEFXUy51dGlsLmluaGVyaXQoe1xuICBoYW5kbGVSZXF1ZXN0OiBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KGh0dHBSZXF1ZXN0LCBodHRwT3B0aW9ucywgY2FsbGJhY2ssIGVyckNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbmRwb2ludCA9IGh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICAgIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHZhciBocmVmID0gZW5kcG9pbnQucHJvdG9jb2wgKyAnLy8nICsgZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgaWYgKGVuZHBvaW50LnBvcnQgIT09IDgwICYmIGVuZHBvaW50LnBvcnQgIT09IDQ0Mykge1xuICAgICAgaHJlZiArPSAnOicgKyBlbmRwb2ludC5wb3J0O1xuICAgIH1cbiAgICBocmVmICs9IGh0dHBSZXF1ZXN0LnBhdGg7XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIGhlYWRlcnNFbWl0dGVkID0gZmFsc2U7XG4gICAgaHR0cFJlcXVlc3Quc3RyZWFtID0geGhyO1xuXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwKSByZXR1cm47IC8vIDAgY29kZSBpcyBpbnZhbGlkXG4gICAgICB9IGNhdGNoIChlKSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID49IHRoaXMuSEVBREVSU19SRUNFSVZFRCAmJiAhaGVhZGVyc0VtaXR0ZWQpIHtcbiAgICAgICAgZW1pdHRlci5zdGF0dXNDb2RlID0geGhyLnN0YXR1cztcbiAgICAgICAgZW1pdHRlci5oZWFkZXJzID0gc2VsZi5wYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgICAgICAgZW1pdHRlci5lbWl0KFxuICAgICAgICAgICdoZWFkZXJzJyxcbiAgICAgICAgICBlbWl0dGVyLnN0YXR1c0NvZGUsXG4gICAgICAgICAgZW1pdHRlci5oZWFkZXJzLFxuICAgICAgICAgIHhoci5zdGF0dXNUZXh0XG4gICAgICAgICk7XG4gICAgICAgIGhlYWRlcnNFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICBzZWxmLmZpbmlzaFJlcXVlc3QoeGhyLCBlbWl0dGVyKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdCgnc2VuZFByb2dyZXNzJywgZXZ0KTtcbiAgICB9KTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ3JlY2VpdmVQcm9ncmVzcycsIGV2dCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZXJyQ2FsbGJhY2soQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdUaW1lb3V0JyksIHtjb2RlOiAnVGltZW91dEVycm9yJ30pKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgZXJyQ2FsbGJhY2soQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdOZXR3b3JrIEZhaWx1cmUnKSwge1xuICAgICAgICBjb2RlOiAnTmV0d29ya2luZ0Vycm9yJ1xuICAgICAgfSkpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlcnJDYWxsYmFjayhBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcpLCB7XG4gICAgICAgIGNvZGU6ICdSZXF1ZXN0QWJvcnRlZEVycm9yJ1xuICAgICAgfSkpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGNhbGxiYWNrKGVtaXR0ZXIpO1xuICAgIHhoci5vcGVuKGh0dHBSZXF1ZXN0Lm1ldGhvZCwgaHJlZiwgaHR0cE9wdGlvbnMueGhyQXN5bmMgIT09IGZhbHNlKTtcbiAgICBBV1MudXRpbC5lYWNoKGh0dHBSZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnQ29udGVudC1MZW5ndGgnICYmIGtleSAhPT0gJ1VzZXItQWdlbnQnICYmIGtleSAhPT0gJ0hvc3QnKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQgJiYgaHR0cE9wdGlvbnMueGhyQXN5bmMgIT09IGZhbHNlKSB7XG4gICAgICB4aHIudGltZW91dCA9IGh0dHBPcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGh0dHBPcHRpb25zLnhocldpdGhDcmVkZW50aWFscykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuICAgIHRyeSB7IHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInOyB9IGNhdGNoIChlKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChodHRwUmVxdWVzdC5ib2R5KSB7XG4gICAgICAgIHhoci5zZW5kKGh0dHBSZXF1ZXN0LmJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChodHRwUmVxdWVzdC5ib2R5ICYmIHR5cGVvZiBodHRwUmVxdWVzdC5ib2R5LmJ1ZmZlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgeGhyLnNlbmQoaHR0cFJlcXVlc3QuYm9keS5idWZmZXIpOyAvLyBzZW5kIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtaXR0ZXI7XG4gIH0sXG5cbiAgcGFyc2VIZWFkZXJzOiBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoKHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciBrZXkgPSBsaW5lLnNwbGl0KCc6JywgMSlbMF07XG4gICAgICB2YXIgdmFsdWUgPSBsaW5lLnN1YnN0cmluZyhrZXkubGVuZ3RoICsgMik7XG4gICAgICBpZiAoa2V5Lmxlbmd0aCA+IDApIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sXG5cbiAgZmluaXNoUmVxdWVzdDogZnVuY3Rpb24gZmluaXNoUmVxdWVzdCh4aHIsIGVtaXR0ZXIpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgdmFyIGFiID0geGhyLnJlc3BvbnNlO1xuICAgICAgYnVmZmVyID0gbmV3IEFXUy51dGlsLkJ1ZmZlcihhYi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFidWZmZXIgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBV1MudXRpbC5CdWZmZXIoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmIChidWZmZXIpIGVtaXR0ZXIuZW1pdCgnZGF0YScsIGJ1ZmZlcik7XG4gICAgZW1pdHRlci5lbWl0KCdlbmQnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5IdHRwQ2xpZW50LnByb3RvdHlwZSA9IEFXUy5YSFJDbGllbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9IDE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwL3hoci5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB2NENyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi4vc2lnbmVycy92NF9jcmVkZW50aWFscycpO1xuXG4vLyBQdWxsIGluIG1hbmFnZWQgdXBsb2FkIGV4dGVuc2lvblxucmVxdWlyZSgnLi4vczMvbWFuYWdlZF91cGxvYWQnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIG9wZXJhdGlvbnNXaXRoMjAwU3RhdHVzQ29kZUVycm9yID0ge1xuICAnY29tcGxldGVNdWx0aXBhcnRVcGxvYWQnOiB0cnVlLFxuICAnY29weU9iamVjdCc6IHRydWUsXG4gICd1cGxvYWRQYXJ0Q29weSc6IHRydWVcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbiB2YXIgcmVnaW9uUmVkaXJlY3RFcnJvckNvZGVzID0gW1xuICAnQXV0aG9yaXphdGlvbkhlYWRlck1hbGZvcm1lZCcsIC8vIG5vbi1oZWFkIG9wZXJhdGlvbnMgb24gdmlydHVhbC1ob3N0ZWQgZ2xvYmFsIGJ1Y2tldCBlbmRwb2ludHNcbiAgJ0JhZFJlcXVlc3QnLCAvLyBoZWFkIG9wZXJhdGlvbnMgb24gdmlydHVhbC1ob3N0ZWQgZ2xvYmFsIGJ1Y2tldCBlbmRwb2ludHNcbiAgJ1Blcm1hbmVudFJlZGlyZWN0JywgLy8gbm9uLWhlYWQgb3BlcmF0aW9ucyBvbiBwYXRoLXN0eWxlIG9yIHJlZ2lvbmFsIGVuZHBvaW50c1xuICAzMDEgLy8gaGVhZCBvcGVyYXRpb25zIG9uIHBhdGgtc3R5bGUgb3IgcmVnaW9uYWwgZW5kcG9pbnRzXG4gXTtcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5TMy5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmF0dXJlVmVyc2lvbjogZnVuY3Rpb24gZ2V0U2lnbmF0dXJlVmVyc2lvbihyZXF1ZXN0KSB7XG4gICAgdmFyIGRlZmF1bHRBcGlWZXJzaW9uID0gdGhpcy5hcGkuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICB2YXIgdXNlckRlZmluZWRWZXJzaW9uID0gdGhpcy5fb3JpZ2luYWxDb25maWcgPyB0aGlzLl9vcmlnaW5hbENvbmZpZy5zaWduYXR1cmVWZXJzaW9uIDogbnVsbDtcbiAgICB2YXIgcmVnaW9uRGVmaW5lZFZlcnNpb24gPSB0aGlzLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uO1xuICAgIHZhciBpc1ByZXNpZ25lZCA9IHJlcXVlc3QgPyByZXF1ZXN0LmlzUHJlc2lnbmVkKCkgOiBmYWxzZTtcbiAgICAvKlxuICAgICAgMSkgVXNlciBkZWZpbmVkIHZlcnNpb24gc3BlY2lmaWVkOlxuICAgICAgICBhKSBhbHdheXMgcmV0dXJuIHVzZXIgZGVmaW5lZCB2ZXJzaW9uXG4gICAgICAyKSBObyB1c2VyIGRlZmluZWQgdmVyc2lvbiBzcGVjaWZpZWQ6XG4gICAgICAgIGEpIGRlZmF1bHQgdG8gbG93ZXN0IHZlcnNpb24gdGhlIHJlZ2lvbiBzdXBwb3J0c1xuICAgICAgICBiKSBJZiB1c2luZyBwcmVzaWduZWQgdXJscywgZGVmYXVsdCB0byBsb3dlc3QgdmVyc2lvbiB0aGUgcmVnaW9uIHN1cHBvcnRzXG4gICAgKi9cbiAgICBpZiAodXNlckRlZmluZWRWZXJzaW9uKSB7XG4gICAgICB1c2VyRGVmaW5lZFZlcnNpb24gPSB1c2VyRGVmaW5lZFZlcnNpb24gPT09ICd2MicgPyAnczMnIDogdXNlckRlZmluZWRWZXJzaW9uO1xuICAgICAgcmV0dXJuIHVzZXJEZWZpbmVkVmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKGlzUHJlc2lnbmVkICE9PSB0cnVlKSB7XG4gICAgICBkZWZhdWx0QXBpVmVyc2lvbiA9ICd2NCc7XG4gICAgfSBlbHNlIGlmIChyZWdpb25EZWZpbmVkVmVyc2lvbikge1xuICAgICAgZGVmYXVsdEFwaVZlcnNpb24gPSByZWdpb25EZWZpbmVkVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRBcGlWZXJzaW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNpZ25lckNsYXNzOiBmdW5jdGlvbiBnZXRTaWduZXJDbGFzcyhyZXF1ZXN0KSB7XG4gICAgdmFyIHNpZ25hdHVyZVZlcnNpb24gPSB0aGlzLmdldFNpZ25hdHVyZVZlcnNpb24ocmVxdWVzdCk7XG4gICAgcmV0dXJuIEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuZ2V0VmVyc2lvbihzaWduYXR1cmVWZXJzaW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZVNlcnZpY2U6IGZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZSgpIHtcbiAgICB2YXIgbXNnO1xuICAgIHZhciBtZXNzYWdlcyA9IFtdO1xuXG4gICAgLy8gZGVmYXVsdCB0byB1cy1lYXN0LTEgd2hlbiBubyByZWdpb24gaXMgcHJvdmlkZWRcbiAgICBpZiAoIXRoaXMuY29uZmlnLnJlZ2lvbikgdGhpcy5jb25maWcucmVnaW9uID0gJ3VzLWVhc3QtMSc7XG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuZHBvaW50ICYmIHRoaXMuY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goJ0FuIGVuZHBvaW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjb25maWd1cmluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BzM0J1Y2tldEVuZHBvaW50YCB0byB0cnVlLicpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBtc2cgPSBtZXNzYWdlc1swXTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIG1zZyA9ICdNdWx0aXBsZSBjb25maWd1cmF0aW9uIGVycm9yczpcXG4nICsgbWVzc2FnZXMuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGlmIChtc2cpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7bmFtZTogJ0ludmFsaWRFbmRwb2ludCcsIG1lc3NhZ2U6IG1zZ30pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaG91bGREaXNhYmxlQm9keVNpZ25pbmc6IGZ1bmN0aW9uIHNob3VsZERpc2FibGVCb2R5U2lnbmluZyhyZXF1ZXN0KSB7XG4gICAgdmFyIHNpZ25lckNsYXNzID0gdGhpcy5nZXRTaWduZXJDbGFzcygpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zM0Rpc2FibGVCb2R5U2lnbmluZyA9PT0gdHJ1ZSAmJiBzaWduZXJDbGFzcyA9PT0gQVdTLlNpZ25lcnMuVjRcbiAgICAgICAgJiYgcmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0dXBSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBzZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZVNjaGVtZSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLnZhbGlkYXRlQnVja2V0RW5kcG9pbnQpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy5jb3JyZWN0QnVja2V0UmVnaW9uRnJvbUNhY2hlKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVCdWNrZXROYW1lKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuYWRkQ29udGVudFR5cGUpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5wb3B1bGF0ZVVSSSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmNvbXB1dGVDb250ZW50TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdhZnRlckJ1aWxkJywgdGhpcy5hZGRFeHBlY3QxMDBDb250aW51ZSk7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RXJyb3InLCB0aGlzLmV4dHJhY3RFcnJvcik7XG4gICAgcmVxdWVzdC5vbkFzeW5jKCdleHRyYWN0RXJyb3InLCB0aGlzLnJlcXVlc3RCdWNrZXRSZWdpb24pO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgdGhpcy5leHRyYWN0RGF0YSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignZXh0cmFjdERhdGEnLCBBV1MudXRpbC5ob2lzdFBheWxvYWRNZW1iZXIpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2JlZm9yZVByZXNpZ24nLCB0aGlzLnByZXBhcmVTaWduZWRVcmwpO1xuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmVxdWVzdC5vbkFzeW5jKCdyZXRyeScsIHRoaXMucmVxUmVnaW9uRm9yTmV0d29ya2luZ0Vycm9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpKSAge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCB0aGlzLmRpc2FibGVCb2R5U2lnbmluZyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlU2NoZW1lOiBmdW5jdGlvbihyZXEpIHtcbiAgICB2YXIgcGFyYW1zID0gcmVxLnBhcmFtcyxcbiAgICAgICAgc2NoZW1lID0gcmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50LnByb3RvY29sLFxuICAgICAgICBzZW5zaXRpdmUgPSBwYXJhbXMuU1NFQ3VzdG9tZXJLZXkgfHwgcGFyYW1zLkNvcHlTb3VyY2VTU0VDdXN0b21lcktleTtcbiAgICBpZiAoc2Vuc2l0aXZlICYmIHNjaGVtZSAhPT0gJ2h0dHBzOicpIHtcbiAgICAgIHZhciBtc2cgPSAnQ2Fubm90IHNlbmQgU1NFIGtleXMgb3ZlciBIVFRQLiBTZXQgXFwnc3NsRW5hYmxlZFxcJycgK1xuICAgICAgICAndG8gXFwndHJ1ZVxcJyBpbiB5b3VyIGNvbmZpZ3VyYXRpb24nO1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgIHsgY29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogbXNnIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUJ1Y2tldEVuZHBvaW50OiBmdW5jdGlvbihyZXEpIHtcbiAgICBpZiAoIXJlcS5wYXJhbXMuQnVja2V0ICYmIHJlcS5zZXJ2aWNlLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICB2YXIgbXNnID0gJ0Nhbm5vdCBzZW5kIHJlcXVlc3RzIHRvIHJvb3QgQVBJIHdpdGggYHMzQnVja2V0RW5kcG9pbnRgIHNldC4nO1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgIHsgY29kZTogJ0NvbmZpZ0Vycm9yJywgbWVzc2FnZTogbXNnIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUJ1Y2tldE5hbWU6IGZ1bmN0aW9uIHZhbGlkYXRlQnVja2V0TmFtZShyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gc2VydmljZS5nZXRTaWduYXR1cmVWZXJzaW9uKHJlcSk7XG4gICAgLy8gT25seSB2YWxpZGF0ZSBidWNrZXRzIHdoZW4gdXNpbmcgc2lndjRcbiAgICBpZiAoc2lnbmF0dXJlVmVyc2lvbiAhPT0gJ3Y0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcyAmJiByZXEucGFyYW1zLkJ1Y2tldDtcbiAgICB2YXIga2V5ID0gcmVxLnBhcmFtcyAmJiByZXEucGFyYW1zLktleTtcbiAgICB2YXIgc2xhc2hJbmRleCA9IGJ1Y2tldCAmJiBidWNrZXQuaW5kZXhPZignLycpO1xuICAgIGlmIChidWNrZXQgJiYgc2xhc2hJbmRleCA+PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVxLnBhcmFtcyA9IEFXUy51dGlsLmNvcHkocmVxLnBhcmFtcyk7XG4gICAgICAgIC8vIE5lZWQgdG8gaW5jbHVkZSB0cmFpbGluZyBzbGFzaCB0byBtYXRjaCBzaWd2MiBiZWhhdmlvclxuICAgICAgICB2YXIgcHJlZml4ID0gYnVja2V0LnN1YnN0cihzbGFzaEluZGV4ICsgMSkgfHwgJyc7XG4gICAgICAgIHJlcS5wYXJhbXMuS2V5ID0gcHJlZml4ICsgJy8nICsga2V5O1xuICAgICAgICByZXEucGFyYW1zLkJ1Y2tldCA9IGJ1Y2tldC5zdWJzdHIoMCwgc2xhc2hJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbXNnID0gJ0J1Y2tldCBuYW1lcyBjYW5ub3QgY29udGFpbiBmb3J3YXJkIHNsYXNoZXMuIEJ1Y2tldDogJyArIGJ1Y2tldDtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgeyBjb2RlOiAnSW52YWxpZEJ1Y2tldCcsIG1lc3NhZ2U6IG1zZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNWYWxpZEFjY2VsZXJhdGVPcGVyYXRpb246IGZ1bmN0aW9uIGlzVmFsaWRBY2NlbGVyYXRlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciBpbnZhbGlkT3BlcmF0aW9ucyA9IFtcbiAgICAgICdjcmVhdGVCdWNrZXQnLFxuICAgICAgJ2RlbGV0ZUJ1Y2tldCcsXG4gICAgICAnbGlzdEJ1Y2tldHMnXG4gICAgXTtcbiAgICByZXR1cm4gaW52YWxpZE9wZXJhdGlvbnMuaW5kZXhPZihvcGVyYXRpb24pID09PSAtMTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTMyBwcmVmZXJzIGRucy1jb21wYXRpYmxlIGJ1Y2tldCBuYW1lcyB0byBiZSBtb3ZlZCBmcm9tIHRoZSB1cmkgcGF0aFxuICAgKiB0byB0aGUgaG9zdG5hbWUgYXMgYSBzdWItZG9tYWluLiAgVGhpcyBpcyBub3QgcG9zc2libGUsIGV2ZW4gZm9yIGRucy1jb21wYXRcbiAgICogYnVja2V0cyB3aGVuIHVzaW5nIFNTTCBhbmQgdGhlIGJ1Y2tldCBuYW1lIGNvbnRhaW5zIGEgZG90ICgnLicpLiAgVGhlXG4gICAqIHNzbCB3aWxkY2FyZCBjZXJ0aWZpY2F0ZSBpcyBvbmx5IDEtbGV2ZWwgZGVlcC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwb3B1bGF0ZVVSSTogZnVuY3Rpb24gcG9wdWxhdGVVUkkocmVxKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICAgIHZhciBiID0gcmVxLnBhcmFtcy5CdWNrZXQ7XG4gICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICB2YXIgZW5kcG9pbnQgPSBodHRwUmVxdWVzdC5lbmRwb2ludDtcbiAgICBpZiAoYikge1xuICAgICAgaWYgKCFzZXJ2aWNlLnBhdGhTdHlsZUJ1Y2tldE5hbWUoYikpIHtcbiAgICAgICAgaWYgKHNlcnZpY2UuY29uZmlnLnVzZUFjY2VsZXJhdGVFbmRwb2ludCAmJiBzZXJ2aWNlLmlzVmFsaWRBY2NlbGVyYXRlT3BlcmF0aW9uKHJlcS5vcGVyYXRpb24pKSB7XG4gICAgICAgICAgaWYgKHNlcnZpY2UuY29uZmlnLnVzZUR1YWxzdGFjaykge1xuICAgICAgICAgICAgZW5kcG9pbnQuaG9zdG5hbWUgPSBiICsgJy5zMy1hY2NlbGVyYXRlLmR1YWxzdGFjay5hbWF6b25hd3MuY29tJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kcG9pbnQuaG9zdG5hbWUgPSBiICsgJy5zMy1hY2NlbGVyYXRlLmFtYXpvbmF3cy5jb20nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2VydmljZS5jb25maWcuczNCdWNrZXRFbmRwb2ludCkge1xuICAgICAgICAgIGVuZHBvaW50Lmhvc3RuYW1lID1cbiAgICAgICAgICAgIGIgKyAnLicgKyBlbmRwb2ludC5ob3N0bmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3J0ID0gZW5kcG9pbnQucG9ydDtcbiAgICAgICAgaWYgKHBvcnQgIT09IDgwICYmIHBvcnQgIT09IDQ0Mykge1xuICAgICAgICAgIGVuZHBvaW50Lmhvc3QgPSBlbmRwb2ludC5ob3N0bmFtZSArICc6JyArXG4gICAgICAgICAgICBlbmRwb2ludC5wb3J0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZHBvaW50Lmhvc3QgPSBlbmRwb2ludC5ob3N0bmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHBSZXF1ZXN0LnZpcnR1YWxIb3N0ZWRCdWNrZXQgPSBiOyAvLyBuZWVkZWQgZm9yIHNpZ25pbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgc2VydmljZS5yZW1vdmVWaXJ0dWFsSG9zdGVkQnVja2V0RnJvbVBhdGgocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBidWNrZXQgbmFtZSBvdXQgb2YgdGhlIHBhdGggaWYgYnVja2V0IGlzIHZpcnR1YWwtaG9zdGVkXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoOiBmdW5jdGlvbiByZW1vdmVWaXJ0dWFsSG9zdGVkQnVja2V0RnJvbVBhdGgocmVxKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICAgIHZhciBidWNrZXQgPSBodHRwUmVxdWVzdC52aXJ0dWFsSG9zdGVkQnVja2V0O1xuICAgIGlmIChidWNrZXQgJiYgaHR0cFJlcXVlc3QucGF0aCkge1xuICAgICAgaHR0cFJlcXVlc3QucGF0aCA9IGh0dHBSZXF1ZXN0LnBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCcvJyArIGJ1Y2tldCksICcnKTtcbiAgICAgIGlmIChodHRwUmVxdWVzdC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgaHR0cFJlcXVlc3QucGF0aCA9ICcvJyArIGh0dHBSZXF1ZXN0LnBhdGg7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIEV4cGVjdDogMTAwLWNvbnRpbnVlIGhlYWRlciBpZiBwYXlsb2FkIGlzIGdyZWF0ZXItb3ItZXF1YWwgMU1CXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkRXhwZWN0MTAwQ29udGludWU6IGZ1bmN0aW9uIGFkZEV4cGVjdDEwMENvbnRpbnVlKHJlcSkge1xuICAgIHZhciBsZW4gPSByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkgJiYgbGVuID49IDEwMjQgKiAxMDI0KSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snRXhwZWN0J10gPSAnMTAwLWNvbnRpbnVlJztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpZiBub25lIGlzIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZENvbnRlbnRUeXBlOiBmdW5jdGlvbiBhZGRDb250ZW50VHlwZShyZXEpIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gICAgaWYgKGh0dHBSZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgfHwgaHR0cFJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBub3Qgc2V0IGluIEdFVC9IRUFEIHJlcXVlc3RzXG4gICAgICBkZWxldGUgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkgeyAvLyBhbHdheXMgaGF2ZSBhIENvbnRlbnQtVHlwZVxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICB9XG5cbiAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIGlmICh0eXBlb2YgaHR0cFJlcXVlc3QuYm9keSA9PT0gJ3N0cmluZycgJiYgIWNvbnRlbnRUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9LykpIHtcbiAgICAgICAgdmFyIGNoYXJzZXQgPSAnOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gKz0gY2hhcnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXBsYWNlRm4gPSBmdW5jdGlvbihfLCBwcmVmaXgsIGNoYXJzZXROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGNoYXJzZXROYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPVxuICAgICAgICAgIGNvbnRlbnRUeXBlLnJlcGxhY2UoLyg7XFxzKmNoYXJzZXQ9KSguKykkLywgcmVwbGFjZUZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0YWJsZUNoZWNrc3VtT3BlcmF0aW9uczoge1xuICAgIHB1dEJ1Y2tldENvcnM6IHRydWUsXG4gICAgcHV0QnVja2V0TGlmZWN5Y2xlOiB0cnVlLFxuICAgIHB1dEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb246IHRydWUsXG4gICAgcHV0QnVja2V0VGFnZ2luZzogdHJ1ZSxcbiAgICBkZWxldGVPYmplY3RzOiB0cnVlLFxuICAgIHB1dEJ1Y2tldFJlcGxpY2F0aW9uOiB0cnVlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGNoZWNrc3VtcyBzaG91bGQgYmUgY29tcHV0ZWQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBJZiB0aGUgcmVxdWVzdCByZXF1aXJlcyBjaGVja3N1bXMgdG8gYmUgY29tcHV0ZWQsIHRoaXMgd2lsbCBhbHdheXNcbiAgICogcmV0dXJuIHRydWUsIG90aGVyd2lzZSBpdCBkZXBlbmRzIG9uIHdoZXRoZXIge0FXUy5Db25maWcuY29tcHV0ZUNoZWNrc3Vtc31cbiAgICogaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVxIFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbXB1dGUgY2hlY2tzdW1zIGZvciBhIHJlcXVlc3QuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgd2lsbENvbXB1dGVDaGVja3N1bXM6IGZ1bmN0aW9uIHdpbGxDb21wdXRlQ2hlY2tzdW1zKHJlcSkge1xuICAgIGlmICh0aGlzLmNvbXB1dGFibGVDaGVja3N1bU9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0pIHJldHVybiB0cnVlO1xuICAgIGlmICghdGhpcy5jb25maWcuY29tcHV0ZUNoZWNrc3VtcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVE9ETzogY29tcHV0ZSBjaGVja3N1bXMgZm9yIFN0cmVhbSBvYmplY3RzXG4gICAgaWYgKCFBV1MudXRpbC5CdWZmZXIuaXNCdWZmZXIocmVxLmh0dHBSZXF1ZXN0LmJvZHkpICYmXG4gICAgICAgIHR5cGVvZiByZXEuaHR0cFJlcXVlc3QuYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dC5tZW1iZXJzO1xuXG4gICAgLy8gU2hhMjU2IHNpZ25pbmcgZGlzYWJsZWQsIGFuZCBub3QgYSBwcmVzaWduZWQgdXJsXG4gICAgaWYgKHJlcS5zZXJ2aWNlLnNob3VsZERpc2FibGVCb2R5U2lnbmluZyhyZXEpICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnMsICdwcmVzaWduZWQtZXhwaXJlcycpKSB7XG4gICAgICBpZiAocnVsZXMuQ29udGVudE1ENSAmJiAhcmVxLnBhcmFtcy5Db250ZW50TUQ1KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFY0IHNpZ25lciB1c2VzIFNIQTI1NiBzaWduYXR1cmVzIHNvIG9ubHkgY29tcHV0ZSBNRDUgaWYgaXQgaXMgcmVxdWlyZWRcbiAgICBpZiAocmVxLnNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKSA9PT0gQVdTLlNpZ25lcnMuVjQpIHtcbiAgICAgIGlmIChydWxlcy5Db250ZW50TUQ1ICYmICFydWxlcy5Db250ZW50TUQ1LnJlcXVpcmVkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGVzLkNvbnRlbnRNRDUgJiYgIXJlcS5wYXJhbXMuQ29udGVudE1ENSkgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEEgbGlzdGVuZXIgdGhhdCBjb21wdXRlcyB0aGUgQ29udGVudC1NRDUgYW5kIHNldHMgaXQgaW4gdGhlIGhlYWRlci5cbiAgICogQHNlZSBBV1MuUzMud2lsbENvbXB1dGVDaGVja3N1bXNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlQ29udGVudE1kNTogZnVuY3Rpb24gY29tcHV0ZUNvbnRlbnRNZDUocmVxKSB7XG4gICAgaWYgKHJlcS5zZXJ2aWNlLndpbGxDb21wdXRlQ2hlY2tzdW1zKHJlcSkpIHtcbiAgICAgIHZhciBtZDUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KHJlcS5odHRwUmVxdWVzdC5ib2R5LCAnYmFzZTY0Jyk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXSA9IG1kNTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1OiBmdW5jdGlvbiBjb21wdXRlU3NlQ3VzdG9tZXJLZXlNZDUocmVxKSB7XG4gICAgdmFyIGtleXMgPSB7XG4gICAgICBTU0VDdXN0b21lcktleTogJ3gtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENScsXG4gICAgICBDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXk6ICd4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDUnXG4gICAgfTtcbiAgICBBV1MudXRpbC5lYWNoKGtleXMsIGZ1bmN0aW9uKGtleSwgaGVhZGVyKSB7XG4gICAgICBpZiAocmVxLnBhcmFtc1trZXldKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEFXUy51dGlsLmNyeXB0by5tZDUocmVxLnBhcmFtc1trZXldLCAnYmFzZTY0Jyk7XG4gICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBidWNrZXQgbmFtZSBzaG91bGQgYmUgbGVmdCBpbiB0aGUgVVJJIHBhdGggZm9yXG4gICAqIGEgcmVxdWVzdCB0byBTMy4gIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW50byBhY2NvdW50IHRoZSBjdXJyZW50XG4gICAqIGVuZHBvaW50IHByb3RvY29sIChlLmcuIGh0dHAgb3IgaHR0cHMpLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhdGhTdHlsZUJ1Y2tldE5hbWU6IGZ1bmN0aW9uIHBhdGhTdHlsZUJ1Y2tldE5hbWUoYnVja2V0TmFtZSkge1xuICAgIC8vIHVzZXIgY2FuIGZvcmNlIHBhdGggc3R5bGUgcmVxdWVzdHMgdmlhIHRoZSBjb25maWd1cmF0aW9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnMzRm9yY2VQYXRoU3R5bGUpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5kbnNDb21wYXRpYmxlQnVja2V0TmFtZShidWNrZXROYW1lKSkge1xuICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5zc2xFbmFibGVkICYmIGJ1Y2tldE5hbWUubWF0Y2goL1xcLi8pKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIG5vdCBkbnMgY29tcGF0aWJsZSBuYW1lcyBtdXN0IGFsd2F5cyB1c2UgcGF0aCBzdHlsZVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBidWNrZXQgbmFtZSBpcyBETlMgY29tcGF0aWJsZS4gIEJ1Y2tldHMgY3JlYXRlZFxuICAgKiBvdXRzaWRlIG9mIHRoZSBjbGFzc2ljIHJlZ2lvbiBNVVNUIGJlIEROUyBjb21wYXRpYmxlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRuc0NvbXBhdGlibGVCdWNrZXROYW1lOiBmdW5jdGlvbiBkbnNDb21wYXRpYmxlQnVja2V0TmFtZShidWNrZXROYW1lKSB7XG4gICAgdmFyIGIgPSBidWNrZXROYW1lO1xuICAgIHZhciBkb21haW4gPSBuZXcgUmVnRXhwKC9eW2EtejAtOV1bYS16MC05XFwuXFwtXXsxLDYxfVthLXowLTldJC8pO1xuICAgIHZhciBpcEFkZHJlc3MgPSBuZXcgUmVnRXhwKC8oXFxkK1xcLil7M31cXGQrLyk7XG4gICAgdmFyIGRvdHMgPSBuZXcgUmVnRXhwKC9cXC5cXC4vKTtcbiAgICByZXR1cm4gKGIubWF0Y2goZG9tYWluKSAmJiAhYi5tYXRjaChpcEFkZHJlc3MpICYmICFiLm1hdGNoKGRvdHMpKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciByZXNwb25zZSBjb250YWlucyBhbiBlcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZTogZnVuY3Rpb24gc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBodHRwUmVzcG9uc2UgPSByZXNwLmh0dHBSZXNwb25zZTtcbiAgICBpZiAob3BlcmF0aW9uc1dpdGgyMDBTdGF0dXNDb2RlRXJyb3JbcmVxLm9wZXJhdGlvbl0gJiZcbiAgICAgICAgaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKS5tYXRjaCgnPEVycm9yPicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDMwMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGVycm9yIGNhbiBiZSByZXRyaWVkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlhYmxlRXJyb3I6IGZ1bmN0aW9uIHJldHJ5YWJsZUVycm9yKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgaWYgKG9wZXJhdGlvbnNXaXRoMjAwU3RhdHVzQ29kZUVycm9yW3JlcXVlc3Qub3BlcmF0aW9uXSAmJlxuICAgICAgICBlcnJvci5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldCAmJlxuICAgICAgICByZXF1ZXN0LnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbcmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdSZXF1ZXN0VGltZW91dCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgJiZcbiAgICAgICAgcmVnaW9uUmVkaXJlY3RFcnJvckNvZGVzLmluZGV4T2YoZXJyb3IuY29kZSkgIT0gLTEgJiZcbiAgICAgICAgZXJyb3IucmVnaW9uICYmIGVycm9yLnJlZ2lvbiAhPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24gPSBlcnJvci5yZWdpb247XG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA9PT0gMzAxKSB7XG4gICAgICAgIHJlcXVlc3Quc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zdXBlciA9IEFXUy5TZXJ2aWNlLnByb3RvdHlwZS5yZXRyeWFibGVFcnJvcjtcbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvciwgcmVxdWVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGh0dHBSZXF1ZXN0IHdpdGggcmVnaW9uLiBJZiByZWdpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuXG4gICAqIHRoZSBodHRwUmVxdWVzdCB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gaHR0cFJlcXVlc3QucmVnaW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmVxQnVja2V0UmVnaW9uOiBmdW5jdGlvbiB1cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgcmVnaW9uKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICBpZiAodHlwZW9mIHJlZ2lvbiA9PT0gJ3N0cmluZycgJiYgcmVnaW9uLmxlbmd0aCkge1xuICAgICAgaHR0cFJlcXVlc3QucmVnaW9uID0gcmVnaW9uO1xuICAgIH1cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3QubWF0Y2goL3MzKD8hLWFjY2VsZXJhdGUpLipcXC5hbWF6b25hd3NcXC5jb20kLykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gICAgdmFyIHMzQ29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgdmFyIHMzQnVja2V0RW5kcG9pbnQgPSBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50O1xuICAgIGlmIChzM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBkZWxldGUgczNDb25maWcuczNCdWNrZXRFbmRwb2ludDtcbiAgICB9XG4gICAgdmFyIG5ld0NvbmZpZyA9IEFXUy51dGlsLmNvcHkoczNDb25maWcpO1xuICAgIGRlbGV0ZSBuZXdDb25maWcuZW5kcG9pbnQ7XG4gICAgbmV3Q29uZmlnLnJlZ2lvbiA9IGh0dHBSZXF1ZXN0LnJlZ2lvbjtcblxuICAgIGh0dHBSZXF1ZXN0LmVuZHBvaW50ID0gKG5ldyBBV1MuUzMobmV3Q29uZmlnKSkuZW5kcG9pbnQ7XG4gICAgc2VydmljZS5wb3B1bGF0ZVVSSShyZXF1ZXN0KTtcbiAgICBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50ID0gczNCdWNrZXRFbmRwb2ludDtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzLkhvc3QgPSBodHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuXG4gICAgaWYgKHJlcXVlc3QuX2FzbS5jdXJyZW50U3RhdGUgPT09ICd2YWxpZGF0ZScpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgc2VydmljZS5wb3B1bGF0ZVVSSSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHNlcnZpY2UucmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc3BlY2lhbGl6ZWQgcGFyc2VyIGZvciBnZXRCdWNrZXRMb2NhdGlvbiAtLSBhbGwgb3RoZXJcbiAgICogb3BlcmF0aW9ucyBhcmUgcGFyc2VkIGJ5IHRoZSBzdXBlciBjbGFzcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0RGF0YTogZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgaWYgKHJlcS5vcGVyYXRpb24gPT09ICdnZXRCdWNrZXRMb2NhdGlvbicpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKS5tYXRjaCgvPiguKyk8XFwvTG9jYXRpb24vKTtcbiAgICAgIGRlbGV0ZSByZXNwLmRhdGFbJ18nXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gbWF0Y2hbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBidWNrZXQgPSByZXEucGFyYW1zLkJ1Y2tldCB8fCBudWxsO1xuICAgIGlmIChyZXEub3BlcmF0aW9uID09PSAnZGVsZXRlQnVja2V0JyAmJiB0eXBlb2YgYnVja2V0ID09PSAnc3RyaW5nJyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgcmVxLnNlcnZpY2UuY2xlYXJCdWNrZXRSZWdpb25DYWNoZShidWNrZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgfHwge307XG4gICAgICB2YXIgcmVnaW9uID0gaGVhZGVyc1sneC1hbXotYnVja2V0LXJlZ2lvbiddIHx8IG51bGw7XG4gICAgICBpZiAoIXJlZ2lvbiAmJiByZXEub3BlcmF0aW9uID09PSAnY3JlYXRlQnVja2V0JyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgICB2YXIgY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbiA9IHJlcS5wYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbjtcbiAgICAgICAgaWYgKCFjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbi5Mb2NhdGlvbkNvbnN0cmFpbnQgPT09ICdFVScpIHtcbiAgICAgICAgICByZWdpb24gPSAnZXUtd2VzdC0xJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uLkxvY2F0aW9uQ29uc3RyYWludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgIGlmIChidWNrZXQgJiYgcmVnaW9uICE9PSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdKSB7XG4gICAgICAgICAgICByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gcmVnaW9uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVxLnNlcnZpY2UuZXh0cmFjdFJlcXVlc3RJZHMocmVzcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFuIGVycm9yIG9iamVjdCBmcm9tIHRoZSBodHRwIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RFcnJvcjogZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgICB2YXIgY29kZXMgPSB7XG4gICAgICAzMDQ6ICdOb3RNb2RpZmllZCcsXG4gICAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgICAgNDAwOiAnQmFkUmVxdWVzdCcsXG4gICAgICA0MDQ6ICdOb3RGb3VuZCdcbiAgICB9O1xuXG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgY29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5IHx8ICcnO1xuXG4gICAgdmFyIGhlYWRlcnMgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzIHx8IHt9O1xuICAgIHZhciByZWdpb24gPSBoZWFkZXJzWyd4LWFtei1idWNrZXQtcmVnaW9uJ10gfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcy5CdWNrZXQgfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0UmVnaW9uQ2FjaGUgPSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZTtcbiAgICBpZiAocmVnaW9uICYmIGJ1Y2tldCAmJiByZWdpb24gIT09IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0pIHtcbiAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZFJlZ2lvbjtcbiAgICBpZiAoY29kZXNbY29kZV0gJiYgYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChidWNrZXQgJiYgIXJlZ2lvbikge1xuICAgICAgICBjYWNoZWRSZWdpb24gPSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG4gICAgICAgIGlmIChjYWNoZWRSZWdpb24gIT09IHJlcS5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgICAgICByZWdpb24gPSBjYWNoZWRSZWdpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiBjb2Rlc1tjb2RlXSxcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKGJvZHkudG9TdHJpbmcoKSk7XG5cbiAgICAgIGlmIChkYXRhLlJlZ2lvbiAmJiAhcmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IGRhdGEuUmVnaW9uO1xuICAgICAgICBpZiAoYnVja2V0ICYmIHJlZ2lvbiAhPT0gYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSkge1xuICAgICAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnVja2V0ICYmICFyZWdpb24gJiYgIWRhdGEuUmVnaW9uKSB7XG4gICAgICAgIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlZFJlZ2lvbiAhPT0gcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgICAgIHJlZ2lvbiA9IGNhY2hlZFJlZ2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogZGF0YS5Db2RlIHx8IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZSB8fCBudWxsLFxuICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcS5zZXJ2aWNlLmV4dHJhY3RSZXF1ZXN0SWRzKHJlc3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiByZWdpb24gd2FzIG5vdCBvYnRhaW5lZCBzeW5jaHJvbm91c2x5LCB0aGVuIHNlbmQgYXN5bmMgcmVxdWVzdFxuICAgKiB0byBnZXQgYnVja2V0IHJlZ2lvbiBmb3IgZXJyb3JzIHJlc3VsdGluZyBmcm9tIHdyb25nIHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXF1ZXN0QnVja2V0UmVnaW9uOiBmdW5jdGlvbiByZXF1ZXN0QnVja2V0UmVnaW9uKHJlc3AsIGRvbmUpIHtcbiAgICB2YXIgZXJyb3IgPSByZXNwLmVycm9yO1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG5cbiAgICBpZiAoIWVycm9yIHx8ICFidWNrZXQgfHwgZXJyb3IucmVnaW9uIHx8IHJlcS5vcGVyYXRpb24gPT09ICdsaXN0T2JqZWN0cycgfHxcbiAgICAgICAgKEFXUy51dGlsLmlzTm9kZSgpICYmIHJlcS5vcGVyYXRpb24gPT09ICdoZWFkQnVja2V0JykgfHxcbiAgICAgICAgKGVycm9yLnN0YXR1c0NvZGUgPT09IDQwMCAmJiByZXEub3BlcmF0aW9uICE9PSAnaGVhZE9iamVjdCcpIHx8XG4gICAgICAgIHJlZ2lvblJlZGlyZWN0RXJyb3JDb2Rlcy5pbmRleE9mKGVycm9yLmNvZGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIHJlcU9wZXJhdGlvbiA9IEFXUy51dGlsLmlzTm9kZSgpID8gJ2hlYWRCdWNrZXQnIDogJ2xpc3RPYmplY3RzJztcbiAgICB2YXIgcmVxUGFyYW1zID0ge0J1Y2tldDogYnVja2V0fTtcbiAgICBpZiAocmVxT3BlcmF0aW9uID09PSAnbGlzdE9iamVjdHMnKSByZXFQYXJhbXMuTWF4S2V5cyA9IDA7XG4gICAgdmFyIHJlZ2lvblJlcSA9IHJlcS5zZXJ2aWNlW3JlcU9wZXJhdGlvbl0ocmVxUGFyYW1zKTtcbiAgICByZWdpb25SZXEuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXQgPSBidWNrZXQ7XG4gICAgcmVnaW9uUmVxLnNlbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVnaW9uID0gcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSB8fCBudWxsO1xuICAgICAgZXJyb3IucmVnaW9uID0gcmVnaW9uO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gICAvKipcbiAgICogRm9yIGJyb3dzZXIgb25seS4gSWYgTmV0d29ya2luZ0Vycm9yIHJlY2VpdmVkLCB3aWxsIGF0dGVtcHQgdG8gb2J0YWluXG4gICAqIHRoZSBidWNrZXQgcmVnaW9uLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICByZXFSZWdpb25Gb3JOZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIHJlcVJlZ2lvbkZvck5ldHdvcmtpbmdFcnJvcihyZXNwLCBkb25lKSB7XG4gICAgaWYgKCFBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIGVycm9yID0gcmVzcC5lcnJvcjtcbiAgICB2YXIgcmVxdWVzdCA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgYnVja2V0ID0gcmVxdWVzdC5wYXJhbXMuQnVja2V0O1xuICAgIGlmICghZXJyb3IgfHwgZXJyb3IuY29kZSAhPT0gJ05ldHdvcmtpbmdFcnJvcicgfHwgIWJ1Y2tldCB8fFxuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbiA9PT0gJ3VzLWVhc3QtMScpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBidWNrZXRSZWdpb25DYWNoZSA9IHNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgdmFyIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcblxuICAgIGlmIChjYWNoZWRSZWdpb24gJiYgY2FjaGVkUmVnaW9uICE9PSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgY2FjaGVkUmVnaW9uKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKCFzZXJ2aWNlLmRuc0NvbXBhdGlibGVCdWNrZXROYW1lKGJ1Y2tldCkpIHtcbiAgICAgIHNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcXVlc3QsICd1cy1lYXN0LTEnKTtcbiAgICAgIGlmIChidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdICE9PSAndXMtZWFzdC0xJykge1xuICAgICAgICBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gJ3VzLWVhc3QtMSc7XG4gICAgICB9XG4gICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LnZpcnR1YWxIb3N0ZWRCdWNrZXQpIHtcbiAgICAgIHZhciBnZXRSZWdpb25SZXEgPSBzZXJ2aWNlLmxpc3RPYmplY3RzKHtCdWNrZXQ6IGJ1Y2tldCwgTWF4S2V5czogMH0pO1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24oZ2V0UmVnaW9uUmVxLCAndXMtZWFzdC0xJyk7XG4gICAgICBnZXRSZWdpb25SZXEuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXQgPSBidWNrZXQ7XG5cbiAgICAgIGdldFJlZ2lvblJlcS5zZW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVnaW9uID0gc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG4gICAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgICAgIHNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcXVlc3QsIHJlZ2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEROUy1jb21wYXRpYmxlIHBhdGgtc3R5bGVcbiAgICAgIC8vIChzM0ZvcmNlUGF0aFN0eWxlIG9yIGJ1Y2tldCBuYW1lIHdpdGggZG90IG92ZXIgaHR0cHMpXG4gICAgICAvLyBDYW5ub3Qgb2J0YWluIHJlZ2lvbiBpbmZvcm1hdGlvbiBmb3IgdGhpcyBjYXNlXG4gICAgICBkb25lKCk7XG4gICAgfVxuICAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgZm9yIGJ1Y2tldCByZWdpb24uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgIGJ1Y2tldFJlZ2lvbkNhY2hlOiB7fSxcblxuICAvKipcbiAgICogQ2xlYXJzIGJ1Y2tldCByZWdpb24gY2FjaGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgIGNsZWFyQnVja2V0UmVnaW9uQ2FjaGU6IGZ1bmN0aW9uKGJ1Y2tldHMpIHtcbiAgICB2YXIgYnVja2V0UmVnaW9uQ2FjaGUgPSB0aGlzLmJ1Y2tldFJlZ2lvbkNhY2hlO1xuICAgIGlmICghYnVja2V0cykge1xuICAgICAgYnVja2V0cyA9IE9iamVjdC5rZXlzKGJ1Y2tldFJlZ2lvbkNhY2hlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBidWNrZXRzID09PSAnc3RyaW5nJykge1xuICAgICAgYnVja2V0cyA9IFtidWNrZXRzXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWxldGUgYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBidWNrZXRSZWdpb25DYWNoZTtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQ29ycmVjdHMgcmVxdWVzdCByZWdpb24gaWYgYnVja2V0J3MgY2FjaGVkIHJlZ2lvbiBpcyBkaWZmZXJlbnRcbiAgICAqXG4gICAgKiBAYXBpIHByaXZhdGVcbiAgICAqL1xuICBjb3JyZWN0QnVja2V0UmVnaW9uRnJvbUNhY2hlOiBmdW5jdGlvbiBjb3JyZWN0QnVja2V0UmVnaW9uRnJvbUNhY2hlKHJlcSkge1xuICAgIHZhciBidWNrZXQgPSByZXEucGFyYW1zLkJ1Y2tldCB8fCBudWxsO1xuICAgIGlmIChidWNrZXQpIHtcbiAgICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgICB2YXIgcmVxdWVzdFJlZ2lvbiA9IHJlcS5odHRwUmVxdWVzdC5yZWdpb247XG4gICAgICB2YXIgY2FjaGVkUmVnaW9uID0gc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdO1xuICAgICAgaWYgKGNhY2hlZFJlZ2lvbiAmJiBjYWNoZWRSZWdpb24gIT09IHJlcXVlc3RSZWdpb24pIHtcbiAgICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxLCBjYWNoZWRSZWdpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgUzMgc3BlY2lmaWMgcmVxdWVzdCBpZHMgZnJvbSB0aGUgaHR0cCByZXNwb25zZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0UmVxdWVzdElkczogZnVuY3Rpb24gZXh0cmFjdFJlcXVlc3RJZHMocmVzcCkge1xuICAgIHZhciBleHRlbmRlZFJlcXVlc3RJZCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgPyByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1pZC0yJ10gOiBudWxsO1xuICAgIHZhciBjZklkID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyA/IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWNmLWlkJ10gOiBudWxsO1xuICAgIHJlc3AuZXh0ZW5kZWRSZXF1ZXN0SWQgPSBleHRlbmRlZFJlcXVlc3RJZDtcbiAgICByZXNwLmNmSWQgPSBjZklkO1xuXG4gICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgIHJlc3AuZXJyb3IucmVxdWVzdElkID0gcmVzcC5yZXF1ZXN0SWQgfHwgbnVsbDtcbiAgICAgIHJlc3AuZXJyb3IuZXh0ZW5kZWRSZXF1ZXN0SWQgPSBleHRlbmRlZFJlcXVlc3RJZDtcbiAgICAgIHJlc3AuZXJyb3IuY2ZJZCA9IGNmSWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBwcmUtc2lnbmVkIFVSTCBmb3IgYSBnaXZlbiBvcGVyYXRpb24gbmFtZS5cbiAgICpcbiAgICogQG5vdGUgWW91IG11c3QgZW5zdXJlIHRoYXQgeW91IGhhdmUgc3RhdGljIG9yIHByZXZpb3VzbHkgcmVzb2x2ZWRcbiAgICogICBjcmVkZW50aWFscyBpZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBzeW5jaHJvbm91c2x5ICh3aXRoIG5vIGNhbGxiYWNrKSxcbiAgICogICBvdGhlcndpc2UgaXQgbWF5IG5vdCBwcm9wZXJseSBzaWduIHRoZSByZXF1ZXN0LiBJZiB5b3UgY2Fubm90IGd1YXJhbnRlZVxuICAgKiAgIHRoaXMgKHlvdSBhcmUgdXNpbmcgYW4gYXN5bmNocm9ub3VzIGNyZWRlbnRpYWwgcHJvdmlkZXIsIGkuZS4sIEVDMlxuICAgKiAgIElBTSByb2xlcyksIHlvdSBzaG91bGQgYWx3YXlzIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhbiBhc3luY2hyb25vdXNcbiAgICogICBjYWxsYmFjay5cbiAgICogQG5vdGUgTm90IGFsbCBvcGVyYXRpb24gcGFyYW1ldGVycyBhcmUgc3VwcG9ydGVkIHdoZW4gdXNpbmcgcHJlLXNpZ25lZFxuICAgKiAgIFVSTHMuIENlcnRhaW4gcGFyYW1ldGVycywgc3VjaCBhcyBgU1NFQ3VzdG9tZXJLZXlgLCBgQUNMYCwgYEV4cGlyZXNgLFxuICAgKiAgIGBDb250ZW50TGVuZ3RoYCwgb3IgYFRhZ2dpbmdgIG11c3QgYmUgcHJvdmlkZWQgYXMgaGVhZGVycyB3aGVuIHNlbmRpbmcgYVxuICAgKiAgIHJlcXVlc3QuIElmIHlvdSBhcmUgdXNpbmcgcHJlLXNpZ25lZCBVUkxzIHRvIHVwbG9hZCBmcm9tIGEgYnJvd3NlciBhbmRcbiAgICogICBuZWVkIHRvIHVzZSB0aGVzZSBmaWVsZHMsIHNlZSB7Y3JlYXRlUHJlc2lnbmVkUG9zdH0uXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBvcGVyYXRpb24uIFNlZSB0aGUgZ2l2ZW5cbiAgICogICBvcGVyYXRpb24gZm9yIHRoZSBleHBlY3RlZCBvcGVyYXRpb24gcGFyYW1ldGVycy4gSW4gYWRkaXRpb24sIHlvdSBjYW5cbiAgICogICBhbHNvIHBhc3MgdGhlIFwiRXhwaXJlc1wiIHBhcmFtZXRlciB0byBpbmZvcm0gUzMgaG93IGxvbmcgdGhlIFVSTCBzaG91bGRcbiAgICogICB3b3JrIGZvci5cbiAgICogQG9wdGlvbiBwYXJhbXMgRXhwaXJlcyBbSW50ZWdlcl0gKDkwMCkgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGV4cGlyZVxuICAgKiAgIHRoZSBwcmUtc2lnbmVkIFVSTCBvcGVyYXRpb24gaW4uIERlZmF1bHRzIHRvIDE1IG1pbnV0ZXMuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBbRnVuY3Rpb25dIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAgIHBhc3MgdGhlIFVSTCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciAoYWZ0ZXIgdGhlIGVycm9yIHBhcmFtZXRlcikgdG9cbiAgICogICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gW1N0cmluZ10gaWYgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLCByZXR1cm5zIHRoZVxuICAgKiAgIHNpZ25lZCBVUkwuXG4gICAqIEByZXR1cm4gW251bGxdIG5vdGhpbmcgaXMgcmV0dXJuZWQgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBnZXRPYmplY3Qgb3BlcmF0aW9uIChzeW5jaHJvbm91c2x5KVxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J307XG4gICAqICAgdmFyIHVybCA9IHMzLmdldFNpZ25lZFVybCgnZ2V0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqIEBleGFtcGxlIFByZS1zaWduaW5nIGEgcHV0T2JqZWN0IChhc3luY2hyb25vdXNseSlcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9O1xuICAgKiAgIHMzLmdldFNpZ25lZFVybCgncHV0T2JqZWN0JywgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3Qgb3BlcmF0aW9uIHdpdGggYSBzcGVjaWZpYyBwYXlsb2FkXG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiAnYm9keSd9O1xuICAgKiAgIHZhciB1cmwgPSBzMy5nZXRTaWduZWRVcmwoJ3B1dE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiBAZXhhbXBsZSBQYXNzaW5nIGluIGEgMS1taW51dGUgZXhwaXJ5IHRpbWUgZm9yIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEV4cGlyZXM6IDYwfTtcbiAgICogICB2YXIgdXJsID0gczMuZ2V0U2lnbmVkVXJsKCdnZXRPYmplY3QnLCBwYXJhbXMpO1xuICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTsgLy8gZXhwaXJlcyBpbiA2MCBzZWNvbmRzXG4gICAqL1xuICBnZXRTaWduZWRVcmw6IGZ1bmN0aW9uIGdldFNpZ25lZFVybChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyB8fCB7fSk7XG4gICAgdmFyIGV4cGlyZXMgPSBwYXJhbXMuRXhwaXJlcyB8fCA5MDA7XG4gICAgZGVsZXRlIHBhcmFtcy5FeHBpcmVzOyAvLyB3ZSBjYW4ndCB2YWxpZGF0ZSB0aGlzXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgQVdTLnV0aWwuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdldCBhIHByZS1zaWduZWQgUE9TVCBwb2xpY3kgdG8gc3VwcG9ydCB1cGxvYWRpbmcgdG8gUzMgZGlyZWN0bHkgZnJvbSBhblxuICAgKiBIVE1MIGZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF1cbiAgICogQG9wdGlvbiBwYXJhbXMgQnVja2V0IFtTdHJpbmddICAgICBUaGUgYnVja2V0IHRvIHdoaWNoIHRoZSBwb3N0IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkXG4gICAqIEBvcHRpb24gcGFyYW1zIEV4cGlyZXMgW0ludGVnZXJdICAgKDM2MDApIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmb3Igd2hpY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcHJlc2lnbmVkIHBvbGljeSBzaG91bGQgYmUgdmFsaWQuXG4gICAqIEBvcHRpb24gcGFyYW1zIENvbmRpdGlvbnMgW0FycmF5XSAgQW4gYXJyYXkgb2YgY29uZGl0aW9ucyB0aGF0IG11c3QgYmUgbWV0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBwcmVzaWduZWQgcG9saWN5IHRvIGFsbG93IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC4gVGhpcyBjYW4gaW5jbHVkZSByZXF1aXJlZCB0YWdzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhY2NlcHRlZCByYW5nZSBmb3IgY29udGVudCBsZW5ndGhzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV0Yy5cbiAgICogQHNlZSBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL3NpZ3Y0LUhUVFBQT1NUQ29uc3RydWN0UG9saWN5Lmh0bWxcbiAgICogQG9wdGlvbiBwYXJhbXMgRmllbGRzIFttYXBdICAgICAgICBGaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgZm9ybS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIHBhc3NlZCBpbiBhcyBmaWVsZHMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCBhcyBleGFjdCBtYXRjaCBjb25kaXRpb25zLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXVxuICAgKlxuICAgKiBAbm90ZSBBbGwgZmllbGRzIHBhc3NlZCBpbiB3aGVuIGNyZWF0aW5nIHByZXNpZ25lZCBwb3N0IGRhdGEgd2lsbCBiZSBzaWduZWRcbiAgICogICBhcyBleGFjdCBtYXRjaCBjb25kaXRpb25zLiBBbnkgZmllbGRzIHRoYXQgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgYnkgUzNcbiAgICogICBtdXN0IGJlIGFkZGVkIHRvIHRoZSBmaWVsZHMgaGFzaCBhZnRlciBzaWduaW5nLCBhbmQgYW4gYXBwcm9wcmlhdGVcbiAgICogICBjb25kaXRpb24gZm9yIHN1Y2ggZmllbGRzIG11c3QgYmUgZXhwbGljaXRseSBhZGRlZCB0byB0aGUgQ29uZGl0aW9uc1xuICAgKiAgIGFycmF5IHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGJlZm9yZSBzaWduaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZSBQcmVzaWdpbmcgcG9zdCBkYXRhIHdpdGggYSBrbm93biBrZXlcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JyxcbiAgICogICAgIEZpZWxkczoge1xuICAgKiAgICAgICBrZXk6ICdrZXknXG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogICBzMy5jcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSB7XG4gICAqICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXNpZ25pbmcgcG9zdCBkYXRhIGVuY291bnRlcmVkIGFuIGVycm9yJywgZXJyKTtcbiAgICogICAgIH0gZWxzZSB7XG4gICAqICAgICAgIGNvbnNvbGUubG9nKCdUaGUgcG9zdCBkYXRhIGlzJywgZGF0YSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIFByZXNpZ25pbmcgcG9zdCBkYXRhIHdpdGggYW4gaW50ZXJwb2xhdGVkIGtleVxuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLFxuICAgKiAgICAgQ29uZGl0aW9uczogW1xuICAgKiAgICAgICBbJ3N0YXJ0cy13aXRoJywgJyRrZXknLCAncGF0aC90by91cGxvYWRzLyddXG4gICAqICAgICBdXG4gICAqICAgfTtcbiAgICogICBzMy5jcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSB7XG4gICAqICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXNpZ25pbmcgcG9zdCBkYXRhIGVuY291bnRlcmVkIGFuIGVycm9yJywgZXJyKTtcbiAgICogICAgIH0gZWxzZSB7XG4gICAqICAgICAgIGRhdGEuRmllbGRzLmtleSA9ICdwYXRoL3RvL3VwbG9hZHMvJHtmaWxlbmFtZX0nO1xuICAgKiAgICAgICBjb25zb2xlLmxvZygnVGhlIHBvc3QgZGF0YSBpcycsIGRhdGEpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAbm90ZSBZb3UgbXVzdCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSBzdGF0aWMgb3IgcHJldmlvdXNseSByZXNvbHZlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGlmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLFxuICAgKiAgIG90aGVyd2lzZSBpdCBtYXkgbm90IHByb3Blcmx5IHNpZ24gdGhlIHJlcXVlc3QuIElmIHlvdSBjYW5ub3QgZ3VhcmFudGVlXG4gICAqICAgdGhpcyAoeW91IGFyZSB1c2luZyBhbiBhc3luY2hyb25vdXMgY3JlZGVudGlhbCBwcm92aWRlciwgaS5lLiwgRUMyXG4gICAqICAgSUFNIHJvbGVzKSwgeW91IHNob3VsZCBhbHdheXMgY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGFuIGFzeW5jaHJvbm91c1xuICAgKiAgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIFttYXBdICBJZiBjYWxsZWQgc3luY2hyb25vdXNseSAod2l0aCBubyBjYWxsYmFjayksIHJldHVybnMgYSBoYXNoXG4gICAqICAgICAgICAgICAgICAgIHdpdGggdGhlIHVybCB0byBzZXQgYXMgdGhlIGZvcm0gYWN0aW9uIGFuZCBhIGhhc2ggb2YgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgIHRvIGluY2x1ZGUgaW4gdGhlIGZvcm0uXG4gICAqIEByZXR1cm4gW251bGxdIE5vdGhpbmcgaXMgcmV0dXJuZWQgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIChlcnIsIGRhdGEpXG4gICAqICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBwb2xpY3kgc2lnbmVyXG4gICAqICBAcGFyYW0gZGF0YSBbbWFwXSBUaGUgZGF0YSBuZWNlc3NhcnkgdG8gY29uc3RydWN0IGFuIEhUTUwgZm9ybVxuICAgKiAgQHBhcmFtIGRhdGEudXJsIFtTdHJpbmddIFRoZSBVUkwgdG8gdXNlIGFzIHRoZSBhY3Rpb24gb2YgdGhlIGZvcm1cbiAgICogIEBwYXJhbSBkYXRhLmZpZWxkcyBbbWFwXSBBIGhhc2ggb2YgZmllbGRzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtIGZvciB0aGUgdXBsb2FkIHRvIHN1Y2NlZWQuIFRoaXMgaGFzaCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSB0aGUgc2lnbmVkIFBPU1QgcG9saWN5LCB5b3VyIGFjY2VzcyBrZXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBJRCBhbmQgc2VjdXJpdHkgdG9rZW4gKGlmIHByZXNlbnQpLCBldGMuIFRoZXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIHNhZmVseSBpbmNsdWRlZCBhcyBpbnB1dCBlbGVtZW50cyBvZiB0eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hpZGRlbi4nXG4gICAqL1xuICBjcmVhdGVQcmVzaWduZWRQb3N0OiBmdW5jdGlvbiBjcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcGFyYW1zID0gQVdTLnV0aWwuY29weShwYXJhbXMgfHwge30pO1xuICAgIHZhciBib3VuZFBhcmFtcyA9IHRoaXMuY29uZmlnLnBhcmFtcyB8fCB7fTtcbiAgICB2YXIgYnVja2V0ID0gcGFyYW1zLkJ1Y2tldCB8fCBib3VuZFBhcmFtcy5CdWNrZXQsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgZW5kcG9pbnQgPSBBV1MudXRpbC5jb3B5KHRoaXMuZW5kcG9pbnQpO1xuICAgIGlmICghY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgIGVuZHBvaW50LnBhdGhuYW1lID0gJy8nICsgYnVja2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmFsaXplUG9zdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogQVdTLnV0aWwudXJsRm9ybWF0KGVuZHBvaW50KSxcbiAgICAgICAgZmllbGRzOiBzZWxmLnByZXBhcmVQb3N0RmllbGRzKFxuICAgICAgICAgIGNvbmZpZy5jcmVkZW50aWFscyxcbiAgICAgICAgICBjb25maWcucmVnaW9uLFxuICAgICAgICAgIGJ1Y2tldCxcbiAgICAgICAgICBwYXJhbXMuRmllbGRzLFxuICAgICAgICAgIHBhcmFtcy5Db25kaXRpb25zLFxuICAgICAgICAgIHBhcmFtcy5FeHBpcmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbmFsaXplUG9zdCgpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluYWxpemVQb3N0KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVQb3N0RmllbGRzOiBmdW5jdGlvbiBwcmVwYXJlUG9zdEZpZWxkcyhcbiAgICBjcmVkZW50aWFscyxcbiAgICByZWdpb24sXG4gICAgYnVja2V0LFxuICAgIGZpZWxkcyxcbiAgICBjb25kaXRpb25zLFxuICAgIGV4cGlyZXNJblNlY29uZHNcbiAgKSB7XG4gICAgdmFyIG5vdyA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuICAgIGlmICghY3JlZGVudGlhbHMgfHwgIXJlZ2lvbiB8fCAhYnVja2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgYSBQT1NUIG9iamVjdCBwb2xpY3kgd2l0aG91dCBhIGJ1Y2tldCwnXG4gICAgICAgICsgJyByZWdpb24sIGFuZCBjcmVkZW50aWFscycpO1xuICAgIH1cbiAgICBmaWVsZHMgPSBBV1MudXRpbC5jb3B5KGZpZWxkcyB8fCB7fSk7XG4gICAgY29uZGl0aW9ucyA9IChjb25kaXRpb25zIHx8IFtdKS5zbGljZSgwKTtcbiAgICBleHBpcmVzSW5TZWNvbmRzID0gZXhwaXJlc0luU2Vjb25kcyB8fCAzNjAwO1xuXG4gICAgdmFyIHNpZ25pbmdEYXRlID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKG5vdykucmVwbGFjZSgvWzpcXC1dfFxcLlxcZHszfS9nLCAnJyk7XG4gICAgdmFyIHNob3J0RGF0ZSA9IHNpZ25pbmdEYXRlLnN1YnN0cigwLCA4KTtcbiAgICB2YXIgc2NvcGUgPSB2NENyZWRlbnRpYWxzLmNyZWF0ZVNjb3BlKHNob3J0RGF0ZSwgcmVnaW9uLCAnczMnKTtcbiAgICB2YXIgY3JlZGVudGlhbCA9IGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJy8nICsgc2NvcGU7XG5cbiAgICBmaWVsZHNbJ2J1Y2tldCddID0gYnVja2V0O1xuICAgIGZpZWxkc1snWC1BbXotQWxnb3JpdGhtJ10gPSAnQVdTNC1ITUFDLVNIQTI1Nic7XG4gICAgZmllbGRzWydYLUFtei1DcmVkZW50aWFsJ10gPSBjcmVkZW50aWFsO1xuICAgIGZpZWxkc1snWC1BbXotRGF0ZSddID0gc2lnbmluZ0RhdGU7XG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgZmllbGRzWydYLUFtei1TZWN1cml0eS1Ub2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cbiAgICBmb3IgKHZhciBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgIGlmIChmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB7fTtcbiAgICAgICAgY29uZGl0aW9uW2ZpZWxkXSA9IGZpZWxkc1tmaWVsZF07XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpZWxkcy5Qb2xpY3kgPSB0aGlzLnByZXBhcmVQb3N0UG9saWN5KFxuICAgICAgbmV3IERhdGUobm93LnZhbHVlT2YoKSArIGV4cGlyZXNJblNlY29uZHMgKiAxMDAwKSxcbiAgICAgIGNvbmRpdGlvbnNcbiAgICApO1xuICAgIGZpZWxkc1snWC1BbXotU2lnbmF0dXJlJ10gPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhcbiAgICAgIHY0Q3JlZGVudGlhbHMuZ2V0U2lnbmluZ0tleShjcmVkZW50aWFscywgc2hvcnREYXRlLCByZWdpb24sICdzMycsIHRydWUpLFxuICAgICAgZmllbGRzLlBvbGljeSxcbiAgICAgICdoZXgnXG4gICAgKTtcblxuICAgIHJldHVybiBmaWVsZHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlcGFyZVBvc3RQb2xpY3k6IGZ1bmN0aW9uIHByZXBhcmVQb3N0UG9saWN5KGV4cGlyYXRpb24sIGNvbmRpdGlvbnMpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuYmFzZTY0LmVuY29kZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICBleHBpcmF0aW9uOiBBV1MudXRpbC5kYXRlLmlzbzg2MDEoZXhwaXJhdGlvbiksXG4gICAgICBjb25kaXRpb25zOiBjb25kaXRpb25zXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVTaWduZWRVcmw6IGZ1bmN0aW9uIHByZXBhcmVTaWduZWRVcmwocmVxdWVzdCkge1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgcmVxdWVzdC5zZXJ2aWNlLm5vUHJlc2lnbmVkQ29udGVudExlbmd0aCk7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCByZXF1ZXN0LnNlcnZpY2UuYWRkQ29udGVudFR5cGUpO1xuICAgIGlmICghcmVxdWVzdC5wYXJhbXMuQm9keSkge1xuICAgICAgLy8gbm8gQ29udGVudC1NRDUvU0hBLTI1NiBpZiBib2R5IGlzIG5vdCBwcm92aWRlZFxuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCByZXF1ZXN0LnNlcnZpY2UuY29tcHV0ZUNvbnRlbnRNZDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdhZnRlckJ1aWxkJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuQ09NUFVURV9TSEEyNTYpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSByZXF1ZXN0XG4gICAqL1xuICBkaXNhYmxlQm9keVNpZ25pbmc6IGZ1bmN0aW9uIGRpc2FibGVCb2R5U2lnbmluZyhyZXF1ZXN0KSB7XG4gICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnM7XG4gICAgLy8gQWRkIHRoZSBoZWFkZXIgdG8gYW55dGhpbmcgdGhhdCBpc24ndCBhIHByZXNpZ25lZCB1cmwsIHVubGVzcyB0aGF0IHByZXNpZ25lZCB1cmwgaGFkIGEgYm9keSBkZWZpbmVkXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgJ3ByZXNpZ25lZC1leHBpcmVzJykpIHtcbiAgICAgIGhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gPSAnVU5TSUdORUQtUEFZTE9BRCc7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG5vUHJlc2lnbmVkQ29udGVudExlbmd0aDogZnVuY3Rpb24gbm9QcmVzaWduZWRDb250ZW50TGVuZ3RoKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5wYXJhbXMuQ29udGVudExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge2NvZGU6ICdVbmV4cGVjdGVkUGFyYW1ldGVyJyxcbiAgICAgICAgbWVzc2FnZTogJ0NvbnRlbnRMZW5ndGggaXMgbm90IHN1cHBvcnRlZCBpbiBwcmUtc2lnbmVkIFVSTHMuJ30pO1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVCdWNrZXQ6IGZ1bmN0aW9uIGNyZWF0ZUJ1Y2tldChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgLy8gV2hlbiBjcmVhdGluZyBhIGJ1Y2tldCAqb3V0c2lkZSogdGhlIGNsYXNzaWMgcmVnaW9uLCB0aGUgbG9jYXRpb25cbiAgICAvLyBjb25zdHJhaW50IG11c3QgYmUgc2V0IGZvciB0aGUgYnVja2V0IGFuZCBpdCBtdXN0IG1hdGNoIHRoZSBlbmRwb2ludC5cbiAgICAvLyBUaGlzIGNodW5rIG9mIGNvZGUgd2lsbCBzZXQgdGhlIGxvY2F0aW9uIGNvbnN0cmFpbnQgcGFyYW0gYmFzZWRcbiAgICAvLyBvbiB0aGUgcmVnaW9uICh3aGVuIHBvc3NpYmxlKSwgYnV0IGl0IHdpbGwgbm90IG92ZXJyaWRlIGEgcGFzc2VkLWluXG4gICAgLy8gbG9jYXRpb24gY29uc3RyYWludC5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyB8fCAhcGFyYW1zKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cbiAgICB2YXIgaG9zdG5hbWUgPSB0aGlzLmVuZHBvaW50Lmhvc3RuYW1lO1xuICAgIGlmIChob3N0bmFtZSAhPT0gdGhpcy5hcGkuZ2xvYmFsRW5kcG9pbnQgJiYgIXBhcmFtcy5DcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICBwYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbiA9IHsgTG9jYXRpb25Db25zdHJhaW50OiB0aGlzLmNvbmZpZy5yZWdpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ2NyZWF0ZUJ1Y2tldCcsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2VlIEFXUy5TMy5NYW5hZ2VkVXBsb2FkXG4gICAqIEBvdmVybG9hZCB1cGxvYWQocGFyYW1zID0ge30sIFtvcHRpb25zXSwgW2NhbGxiYWNrXSlcbiAgICogICBVcGxvYWRzIGFuIGFyYml0cmFyaWx5IHNpemVkIGJ1ZmZlciwgYmxvYiwgb3Igc3RyZWFtLCB1c2luZyBpbnRlbGxpZ2VudFxuICAgKiAgIGNvbmN1cnJlbnQgaGFuZGxpbmcgb2YgcGFydHMgaWYgdGhlIHBheWxvYWQgaXMgbGFyZ2UgZW5vdWdoLiBZb3UgY2FuXG4gICAqICAgY29uZmlndXJlIHRoZSBjb25jdXJyZW50IHF1ZXVlIHNpemUgYnkgc2V0dGluZyBgb3B0aW9uc2AuIE5vdGUgdGhhdCB0aGlzXG4gICAqICAgaXMgdGhlIG9ubHkgb3BlcmF0aW9uIGZvciB3aGljaCB0aGUgU0RLIGNhbiByZXRyeSByZXF1ZXN0cyB3aXRoIHN0cmVhbVxuICAgKiAgIGJvZGllcy5cbiAgICpcbiAgICogICBAcGFyYW0gKHNlZSBBV1MuUzMucHV0T2JqZWN0KVxuICAgKiAgIEBvcHRpb24gKHNlZSBBV1MuUzMuTWFuYWdlZFVwbG9hZC5jb25zdHJ1Y3RvcilcbiAgICogICBAcmV0dXJuIFtBV1MuUzMuTWFuYWdlZFVwbG9hZF0gdGhlIG1hbmFnZWQgdXBsb2FkIG9iamVjdCB0aGF0IGNhbiBjYWxsXG4gICAqICAgICBgc2VuZCgpYCBvciB0cmFjayBwcm9ncmVzcy5cbiAgICogICBAZXhhbXBsZSBVcGxvYWRpbmcgYSBzdHJlYW0gb2JqZWN0XG4gICAqICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX07XG4gICAqICAgICBzMy51cGxvYWQocGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICogICAgICAgY29uc29sZS5sb2coZXJyLCBkYXRhKTtcbiAgICogICAgIH0pO1xuICAgKiAgIEBleGFtcGxlIFVwbG9hZGluZyBhIHN0cmVhbSB3aXRoIGNvbmN1cnJlbmN5IG9mIDEgYW5kIHBhcnRTaXplIG9mIDEwbWJcbiAgICogICAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfTtcbiAgICogICAgIHZhciBvcHRpb25zID0ge3BhcnRTaXplOiAxMCAqIDEwMjQgKiAxMDI0LCBxdWV1ZVNpemU6IDF9O1xuICAgKiAgICAgczMudXBsb2FkKHBhcmFtcywgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGNvbnNvbGUubG9nKGVyciwgZGF0YSk7XG4gICAqICAgICB9KTtcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb3IgbnVsbCBpZiBubyBlcnJvciBvY2N1cnJlZC5cbiAgICogICBAcGFyYW0gZGF0YSBbbWFwXSBUaGUgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBzdWNjZXNzZnVsIHVwbG9hZDpcbiAgICogICBAcGFyYW0gZGF0YS5Mb2NhdGlvbiBbU3RyaW5nXSB0aGUgVVJMIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICBAcGFyYW0gZGF0YS5FVGFnIFtTdHJpbmddIHRoZSBFVGFnIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICBAcGFyYW0gZGF0YS5CdWNrZXQgW1N0cmluZ10gIHRoZSBidWNrZXQgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogICBAcGFyYW0gZGF0YS5LZXkgW1N0cmluZ10gdGhlIGtleSB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKi9cbiAgdXBsb2FkOiBmdW5jdGlvbiB1cGxvYWQocGFyYW1zLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zID0gQVdTLnV0aWwubWVyZ2Uob3B0aW9ucyB8fCB7fSwge3NlcnZpY2U6IHRoaXMsIHBhcmFtczogcGFyYW1zfSk7XG5cbiAgICB2YXIgdXBsb2FkZXIgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgdXBsb2FkZXIuc2VuZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHVwbG9hZGVyO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL3MzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGJ5dGVMZW5ndGggPSBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aDtcbnZhciBCdWZmZXIgPSBBV1MudXRpbC5CdWZmZXI7XG5cbi8qKlxuICogVGhlIG1hbmFnZWQgdXBsb2FkZXIgYWxsb3dzIGZvciBlYXN5IGFuZCBlZmZpY2llbnQgdXBsb2FkaW5nIG9mIGJ1ZmZlcnMsXG4gKiBibG9icywgb3Igc3RyZWFtcywgdXNpbmcgYSBjb25maWd1cmFibGUgYW1vdW50IG9mIGNvbmN1cnJlbmN5IHRvIHBlcmZvcm1cbiAqIG11bHRpcGFydCB1cGxvYWRzIHdoZXJlIHBvc3NpYmxlLiBUaGlzIGFic3RyYWN0aW9uIGFsc28gZW5hYmxlcyB1cGxvYWRpbmdcbiAqIHN0cmVhbXMgb2YgdW5rbm93biBzaXplIGR1ZSB0byB0aGUgdXNlIG9mIG11bHRpcGFydCB1cGxvYWRzLlxuICpcbiAqIFRvIGNvbnN0cnVjdCBhIG1hbmFnZWQgdXBsb2FkIG9iamVjdCwgc2VlIHRoZSB7Y29uc3RydWN0b3J9IGZ1bmN0aW9uLlxuICpcbiAqICMjIFRyYWNraW5nIHVwbG9hZCBwcm9ncmVzc1xuICpcbiAqIFRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QgY2FuIGFsc28gdHJhY2sgcHJvZ3Jlc3MgYnkgYXR0YWNoaW5nIGFuXG4gKiAnaHR0cFVwbG9hZFByb2dyZXNzJyBsaXN0ZW5lciB0byB0aGUgdXBsb2FkIG1hbmFnZXIuIFRoaXMgZXZlbnQgaXMgc2ltaWxhclxuICogdG8ge0FXUy5SZXF1ZXN0fmh0dHBVcGxvYWRQcm9ncmVzc30gYnV0IGdyb3VwcyBhbGwgY29uY3VycmVudCB1cGxvYWQgcHJvZ3Jlc3NcbiAqIGludG8gYSBzaW5nbGUgZXZlbnQuIFNlZSB7QVdTLlMzLk1hbmFnZWRVcGxvYWR+aHR0cFVwbG9hZFByb2dyZXNzfSBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24uXG4gKlxuICogIyMgSGFuZGxpbmcgTXVsdGlwYXJ0IENsZWFudXBcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGNsYXNzIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBhbnkgbXVsdGlwYXJ0IHVwbG9hZHNcbiAqIHdoZW4gYW4gaW5kaXZpZHVhbCBwYXJ0IHVwbG9hZCBmYWlscy4gVGhpcyBiZWhhdmlvciBjYW4gYmUgZGlzYWJsZWQgaW4gb3JkZXJcbiAqIHRvIG1hbnVhbGx5IGhhbmRsZSBmYWlsdXJlcyBieSBzZXR0aW5nIHRoZSBgbGVhdmVQYXJ0c09uRXJyb3JgIGNvbmZpZ3VyYXRpb25cbiAqIG9wdGlvbiB0byBgdHJ1ZWAgd2hlbiBpbml0aWFsaXppbmcgdGhlIHVwbG9hZCBvYmplY3QuXG4gKlxuICogQCFldmVudCBodHRwVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSB1cGxvYWRlciBoYXMgdXBsb2FkZWQgbW9yZSBkYXRhLlxuICogICBAbm90ZSBUaGUgYHRvdGFsYCBwcm9wZXJ0eSBtYXkgbm90IGJlIHNldCBpZiB0aGUgc3RyZWFtIGJlaW5nIHVwbG9hZGVkIGhhc1xuICogICAgIG5vdCB5ZXQgZmluaXNoZWQgY2h1bmtpbmcuIEluIHRoaXMgY2FzZSB0aGUgYHRvdGFsYCB3aWxsIGJlIHVuZGVmaW5lZFxuICogICAgIHVudGlsIHRoZSB0b3RhbCBzdHJlYW0gc2l6ZSBpcyBrbm93bi5cbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKiAgIEBwYXJhbSBwcm9ncmVzcyBbbWFwXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYGxvYWRlZGAgYW5kIGB0b3RhbGAgYnl0ZXNcbiAqICAgICBvZiB0aGUgcmVxdWVzdCBhbmQgdGhlIGBrZXlgIG9mIHRoZSBTMyBvYmplY3QuIE5vdGUgdGhhdCBgdG90YWxgIG1heSBiZSB1bmRlZmluZWQgdW50aWwgdGhlIHBheWxvYWRcbiAqICAgICBzaXplIGlzIGtub3duLlxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKi9cbkFXUy5TMy5NYW5hZ2VkVXBsb2FkID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0IHdpdGggYSBzZXQgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAbm90ZSBBIFwiQm9keVwiIHBhcmFtZXRlciBpcyByZXF1aXJlZCB0byBiZSBzZXQgcHJpb3IgdG8gY2FsbGluZyB7c2VuZH0uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJhbXMgW21hcF0gYSBtYXAgb2YgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB1cGxvYWRcbiAgICogICByZXF1ZXN0cy4gVGhlIFwiQm9keVwiIHBhcmFtZXRlciBpcyByZXF1aXJlZCB0byBiZSBzcGVjaWZpZWQgZWl0aGVyIG9uXG4gICAqICAgdGhlIHNlcnZpY2Ugb3IgaW4gdGhlIHBhcmFtcyBvcHRpb24uXG4gICAqIEBub3RlIENvbnRlbnRNRDUgc2hvdWxkIG5vdCBiZSBwcm92aWRlZCB3aGVuIHVzaW5nIHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QuXG4gICAqICAgSW5zdGVhZCwgc2V0dGluZyBcImNvbXB1dGVDaGVja3N1bXNcIiB0byB0cnVlIHdpbGwgZW5hYmxlIGF1dG9tYXRpYyBDb250ZW50TUQ1IGdlbmVyYXRpb25cbiAgICogICBieSB0aGUgbWFuYWdlZCB1cGxvYWQgb2JqZWN0LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcXVldWVTaXplIFtOdW1iZXJdICg0KSB0aGUgc2l6ZSBvZiB0aGUgY29uY3VycmVudCBxdWV1ZVxuICAgKiAgIG1hbmFnZXIgdG8gdXBsb2FkIHBhcnRzIGluIHBhcmFsbGVsLiBTZXQgdG8gMSBmb3Igc3luY2hyb25vdXMgdXBsb2FkaW5nXG4gICAqICAgb2YgcGFydHMuIE5vdGUgdGhhdCB0aGUgdXBsb2FkZXIgd2lsbCBidWZmZXIgYXQgbW9zdCBxdWV1ZVNpemUgKiBwYXJ0U2l6ZVxuICAgKiAgIGJ5dGVzIGludG8gbWVtb3J5IGF0IGFueSBnaXZlbiB0aW1lLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFydFNpemUgW051bWJlcl0gKDVtYikgdGhlIHNpemUgaW4gYnl0ZXMgZm9yIGVhY2hcbiAgICogICBpbmRpdmlkdWFsIHBhcnQgdG8gYmUgdXBsb2FkZWQuIEFkanVzdCB0aGUgcGFydCBzaXplIHRvIGVuc3VyZSB0aGUgbnVtYmVyXG4gICAqICAgb2YgcGFydHMgZG9lcyBub3QgZXhjZWVkIHttYXhUb3RhbFBhcnRzfS4gU2VlIHttaW5QYXJ0U2l6ZX0gZm9yIHRoZVxuICAgKiAgIG1pbmltdW0gYWxsb3dlZCBwYXJ0IHNpemUuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBsZWF2ZVBhcnRzT25FcnJvciBbQm9vbGVhbl0gKGZhbHNlKSB3aGV0aGVyIHRvIGFib3J0IHRoZVxuICAgKiAgIG11bHRpcGFydCB1cGxvYWQgaWYgYW4gZXJyb3Igb2NjdXJzLiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBoYW5kbGVcbiAgICogICBmYWlsdXJlcyBtYW51YWxseS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNlcnZpY2UgW0FXUy5TM10gYW4gb3B0aW9uYWwgUzMgc2VydmljZSBvYmplY3QgdG8gdXNlIGZvclxuICAgKiAgIHJlcXVlc3RzLiBUaGlzIG9iamVjdCBtaWdodCBoYXZlIGJvdW5kIHBhcmFtZXRlcnMgdXNlZCBieSB0aGUgdXBsb2FkZXIuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0YWdzIFtBcnJheTxtYXA+XSBUaGUgdGFncyB0byBhcHBseSB0byB0aGUgdXBsb2FkZWQgb2JqZWN0LlxuICAgKiAgIEVhY2ggdGFnIHNob3VsZCBoYXZlIGEgYEtleWAgYW5kIGBWYWx1ZWAga2V5cy5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBkZWZhdWx0IHVwbG9hZGVyIGZvciBhIHN0cmVhbSBvYmplY3RcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcmFtczoge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX1cbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYW4gdXBsb2FkZXIgd2l0aCBjb25jdXJyZW5jeSBvZiAxIGFuZCBwYXJ0U2l6ZSBvZiAxMG1iXG4gICAqICAgdmFyIHVwbG9hZCA9IG5ldyBBV1MuUzMuTWFuYWdlZFVwbG9hZCh7XG4gICAqICAgICBwYXJ0U2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgcXVldWVTaXplOiAxLFxuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfVxuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhbiB1cGxvYWRlciB3aXRoIHRhZ3NcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcmFtczoge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX0sXG4gICAqICAgICB0YWdzOiBbe0tleTogJ3RhZzEnLCBWYWx1ZTogJ3ZhbHVlMSd9LCB7S2V5OiAndGFnMicsIFZhbHVlOiAndmFsdWUyJ31dXG4gICAqICAgfSk7XG4gICAqIEBzZWUgc2VuZFxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIE1hbmFnZWRVcGxvYWQob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwoc2VsZik7XG4gICAgc2VsZi5ib2R5ID0gbnVsbDtcbiAgICBzZWxmLnNsaWNlRm4gPSBudWxsO1xuICAgIHNlbGYuY2FsbGJhY2sgPSBudWxsO1xuICAgIHNlbGYucGFydHMgPSB7fTtcbiAgICBzZWxmLmNvbXBsZXRlSW5mbyA9IFtdO1xuICAgIHNlbGYuZmlsbFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYm9keSBwYXlsb2FkICcgKyB0eXBlb2Ygc2VsZi5ib2R5KSk7XG4gICAgfTtcblxuICAgIHNlbGYuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbmZpZ3VyZTogZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnBhcnRTaXplID0gdGhpcy5taW5QYXJ0U2l6ZTtcblxuICAgIGlmIChvcHRpb25zLnF1ZXVlU2l6ZSkgdGhpcy5xdWV1ZVNpemUgPSBvcHRpb25zLnF1ZXVlU2l6ZTtcbiAgICBpZiAob3B0aW9ucy5wYXJ0U2l6ZSkgdGhpcy5wYXJ0U2l6ZSA9IG9wdGlvbnMucGFydFNpemU7XG4gICAgaWYgKG9wdGlvbnMubGVhdmVQYXJ0c09uRXJyb3IpIHRoaXMubGVhdmVQYXJ0c09uRXJyb3IgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLnRhZ3MpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnRhZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFncyBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheTsgJyArXG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMudGFncyArICcgcHJvdmlkZWQuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFydFNpemUgPCB0aGlzLm1pblBhcnRTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluUGFydFNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuc2VydmljZSA9IG9wdGlvbnMuc2VydmljZTtcbiAgICB0aGlzLmJpbmRTZXJ2aWNlT2JqZWN0KG9wdGlvbnMucGFyYW1zKTtcbiAgICB0aGlzLnZhbGlkYXRlQm9keSgpO1xuICAgIHRoaXMuYWRqdXN0VG90YWxCeXRlcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxlYXZlUGFydHNPbkVycm9yOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBxdWV1ZVNpemU6IDQsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydFNpemU6IG51bGwsXG5cbiAgLyoqXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJuIFtOdW1iZXJdIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBmb3IgYW4gaW5kaXZpZHVhbCBwYXJ0XG4gICAqICAgdXBsb2FkLlxuICAgKi9cbiAgbWluUGFydFNpemU6IDEwMjQgKiAxMDI0ICogNSxcblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm4gW051bWJlcl0gdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIgb2YgcGFydHMgaW4gYSBtdWx0aXBhcnQgdXBsb2FkLlxuICAgKi9cbiAgbWF4VG90YWxQYXJ0czogMTAwMDAsXG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgbWFuYWdlZCB1cGxvYWQgZm9yIHRoZSBwYXlsb2FkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvciBudWxsIGlmIG5vIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEBwYXJhbSBkYXRhIFttYXBdIFRoZSByZXNwb25zZSBkYXRhIGZyb20gdGhlIHN1Y2Nlc3NmdWwgdXBsb2FkOlxuICAgKiAgICAgKiBgTG9jYXRpb25gIChTdHJpbmcpIHRoZSBVUkwgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgICAgKiBgRVRhZ2AgKFN0cmluZykgdGhlIEVUYWcgb2YgdGhlIHVwbG9hZGVkIG9iamVjdFxuICAgKiAgICAgKiBgQnVja2V0YCAoU3RyaW5nKSB0aGUgYnVja2V0IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgICAqIGBLZXlgIChTdHJpbmcpIHRoZSBrZXkgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogQGV4YW1wbGUgU2VuZGluZyBhIG1hbmFnZWQgdXBsb2FkIG9iamVjdFxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfTtcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtwYXJhbXM6IHBhcmFtc30pO1xuICAgKiAgIHVwbG9hZC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgY29uc29sZS5sb2coZXJyLCBkYXRhKTtcbiAgICogICB9KTtcbiAgICovXG4gIHNlbmQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZmFpbGVkID0gZmFsc2U7XG4gICAgc2VsZi5jYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbiAgICB2YXIgcnVuRmlsbCA9IHRydWU7XG4gICAgaWYgKHNlbGYuc2xpY2VGbikge1xuICAgICAgc2VsZi5maWxsUXVldWUgPSBzZWxmLmZpbGxCdWZmZXI7XG4gICAgfSBlbHNlIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgdmFyIFN0cmVhbSA9IEFXUy51dGlsLnN0cmVhbS5TdHJlYW07XG4gICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgIHJ1bkZpbGwgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5maWxsUXVldWUgPSBzZWxmLmZpbGxTdHJlYW07XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgc2VsZi5ib2R5LlxuICAgICAgICAgIG9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBzZWxmLmNsZWFudXAoZXJyKTsgfSkuXG4gICAgICAgICAgb24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7IHNlbGYuZmlsbFF1ZXVlKCk7IH0pLlxuICAgICAgICAgIG9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5udW1QYXJ0cyA9IHNlbGYudG90YWxQYXJ0TnVtYmVycztcbiAgICAgICAgICAgIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHNlbGYudG90YWxQYXJ0TnVtYmVycyA+PSAxICYmIHNlbGYuZG9uZVBhcnRzID09PSBzZWxmLm51bVBhcnRzKSB7XG4gICAgICAgICAgICAgIHNlbGYuZmluaXNoTXVsdGlQYXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJ1bkZpbGwpIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBwcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGRhdGEpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgICAgIGBMb2NhdGlvbmAgKFN0cmluZykgdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAgIGBFVGFnYCAoU3RyaW5nKSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAgIGBCdWNrZXRgIChTdHJpbmcpIHRoZSBidWNrZXQgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogICAgICAgYEtleWAgKFN0cmluZykgdGhlIGtleSB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBhbiBlcnJvciBvciBudWxsIGlmIG5vIGVycm9yIG9jY3VycmVkLlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB1cGxvYWQgcmVxdWVzdC5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGFuIHVwbG9hZCByZXF1ZXN0IHVzaW5nIHByb21pc2VzLlxuICAgKiAgICAgdmFyIHVwbG9hZCA9IHMzLnVwbG9hZCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfSk7XG4gICAqICAgICB2YXIgcHJvbWlzZSA9IHVwbG9hZC5wcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIG1hbmFnZWQgdXBsb2FkLCBpbmNsdWRpbmcgYWxsIGNvbmN1cnJlbnQgdXBsb2FkIHJlcXVlc3RzLlxuICAgKiBAbm90ZSBCeSBkZWZhdWx0LCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBjbGVhbnVwIGEgbXVsdGlwYXJ0IHVwbG9hZFxuICAgKiAgIGlmIG9uZSB3YXMgY3JlYXRlZC4gVG8gbGVhdmUgdGhlIG11bHRpcGFydCB1cGxvYWQgYXJvdW5kIGFmdGVyIGFib3J0aW5nXG4gICAqICAgYSByZXF1ZXN0LCBjb25maWd1cmUgYGxlYXZlUGFydHNPbkVycm9yYCB0byBgdHJ1ZWAgaW4gdGhlIHtjb25zdHJ1Y3Rvcn0uXG4gICAqIEBub3RlIENhbGxpbmcge2Fib3J0fSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCB3aWxsIG5vdCBhYm9ydCBhbnkgcmVxdWVzdHNcbiAgICogICB0aGF0IGFyZSBhbHJlYWR5IGluIGZsaWdodC4gSWYgYSBtdWx0aXBhcnQgdXBsb2FkIHdhcyBjcmVhdGVkLCBhbnkgcGFydHNcbiAgICogICBub3QgeWV0IHVwbG9hZGVkIHdpbGwgbm90IGJlIHNlbnQsIGFuZCB0aGUgbXVsdGlwYXJ0IHVwbG9hZCB3aWxsIGJlIGNsZWFuZWQgdXAuXG4gICAqIEBleGFtcGxlIEFib3J0aW5nIGFuIHVwbG9hZFxuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLFxuICAgKiAgICAgQm9keTogbmV3IEJ1ZmZlcigxMDI0ICogMTAyNCAqIDI1KSAvLyAyNU1CIHBheWxvYWRcbiAgICogICB9O1xuICAgKiAgIHZhciB1cGxvYWQgPSBzMy51cGxvYWQocGFyYW1zKTtcbiAgICogICB1cGxvYWQuc2VuZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yOlwiLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICAgKiAgICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyBhYm9ydCByZXF1ZXN0IGluIDEgc2Vjb25kXG4gICAqICAgc2V0VGltZW91dCh1cGxvYWQuYWJvcnQuYmluZCh1cGxvYWQpLCAxMDAwKTtcbiAgICovXG4gIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFudXAoQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQgYnkgdXNlcicpLCB7XG4gICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVCb2R5OiBmdW5jdGlvbiB2YWxpZGF0ZUJvZHkoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuYm9keSA9IHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLkJvZHk7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxmLmJvZHkgPSBuZXcgQVdTLnV0aWwuQnVmZmVyKHNlbGYuYm9keSk7XG4gICAgfSBlbHNlIGlmICghc2VsZi5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtcy5Cb2R5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIHNlbGYuc2xpY2VGbiA9IEFXUy51dGlsLmFycmF5U2xpY2VGbihzZWxmLmJvZHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGJpbmRTZXJ2aWNlT2JqZWN0OiBmdW5jdGlvbiBiaW5kU2VydmljZU9iamVjdChwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGJpbmQgcGFyYW1ldGVycyB0byBuZXcgc2VydmljZSBvYmplY3RcbiAgICBpZiAoIXNlbGYuc2VydmljZSkge1xuICAgICAgc2VsZi5zZXJ2aWNlID0gbmV3IEFXUy5TMyh7cGFyYW1zOiBwYXJhbXN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlcnZpY2UgPSBzZWxmLnNlcnZpY2U7XG4gICAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwuY29weShzZXJ2aWNlLmNvbmZpZyk7XG4gICAgICBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9IHNlcnZpY2UuZ2V0U2lnbmF0dXJlVmVyc2lvbigpO1xuICAgICAgc2VsZi5zZXJ2aWNlID0gbmV3IHNlcnZpY2UuY29uc3RydWN0b3IuX19zdXBlcl9fKGNvbmZpZyk7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcyA9XG4gICAgICAgIEFXUy51dGlsLm1lcmdlKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGp1c3RUb3RhbEJ5dGVzOiBmdW5jdGlvbiBhZGp1c3RUb3RhbEJ5dGVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkgeyAvLyB0cnkgdG8gZ2V0IHRvdGFsQnl0ZXNcbiAgICAgIHNlbGYudG90YWxCeXRlcyA9IGJ5dGVMZW5ndGgoc2VsZi5ib2R5KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIC8vIHRyeSB0byBhZGp1c3QgcGFydFNpemUgaWYgd2Uga25vdyBwYXlsb2FkIGxlbmd0aFxuICAgIGlmIChzZWxmLnRvdGFsQnl0ZXMpIHtcbiAgICAgIHZhciBuZXdQYXJ0U2l6ZSA9IE1hdGguY2VpbChzZWxmLnRvdGFsQnl0ZXMgLyBzZWxmLm1heFRvdGFsUGFydHMpO1xuICAgICAgaWYgKG5ld1BhcnRTaXplID4gc2VsZi5wYXJ0U2l6ZSkgc2VsZi5wYXJ0U2l6ZSA9IG5ld1BhcnRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRvdGFsQnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzRG9uZUNodW5raW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0UG9zOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsQ2h1bmtlZEJ5dGVzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsVXBsb2FkZWRCeXRlczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b3RhbEJ5dGVzOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbnVtUGFydHM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG90YWxQYXJ0TnVtYmVyczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhY3RpdmVQYXJ0czogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkb25lUGFydHM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydHM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVJbmZvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZhaWxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlwYXJ0UmVxOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRCdWZmZXJzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRCdWZmZXJMZW5ndGg6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZmlsbEJ1ZmZlcjogZnVuY3Rpb24gZmlsbEJ1ZmZlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJvZHlMZW4gPSBieXRlTGVuZ3RoKHNlbGYuYm9keSk7XG5cbiAgICBpZiAoYm9keUxlbiA9PT0gMCkge1xuICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IHRydWU7XG4gICAgICBzZWxmLm51bVBhcnRzID0gMTtcbiAgICAgIHNlbGYubmV4dENodW5rKHNlbGYuYm9keSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKHNlbGYuYWN0aXZlUGFydHMgPCBzZWxmLnF1ZXVlU2l6ZSAmJiBzZWxmLnBhcnRQb3MgPCBib2R5TGVuKSB7XG4gICAgICB2YXIgZW5kUG9zID0gTWF0aC5taW4oc2VsZi5wYXJ0UG9zICsgc2VsZi5wYXJ0U2l6ZSwgYm9keUxlbik7XG4gICAgICB2YXIgYnVmID0gc2VsZi5zbGljZUZuLmNhbGwoc2VsZi5ib2R5LCBzZWxmLnBhcnRQb3MsIGVuZFBvcyk7XG4gICAgICBzZWxmLnBhcnRQb3MgKz0gc2VsZi5wYXJ0U2l6ZTtcblxuICAgICAgaWYgKGJ5dGVMZW5ndGgoYnVmKSA8IHNlbGYucGFydFNpemUgfHwgc2VsZi5wYXJ0UG9zID09PSBib2R5TGVuKSB7XG4gICAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLm51bVBhcnRzID0gc2VsZi50b3RhbFBhcnROdW1iZXJzICsgMTtcbiAgICAgIH1cbiAgICAgIHNlbGYubmV4dENodW5rKGJ1Zik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbGxTdHJlYW06IGZ1bmN0aW9uIGZpbGxTdHJlYW0oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmFjdGl2ZVBhcnRzID49IHNlbGYucXVldWVTaXplKSByZXR1cm47XG5cbiAgICB2YXIgYnVmID0gc2VsZi5ib2R5LnJlYWQoc2VsZi5wYXJ0U2l6ZSAtIHNlbGYucGFydEJ1ZmZlckxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgc2VsZi5ib2R5LnJlYWQoKTtcbiAgICBpZiAoYnVmKSB7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJzLnB1c2goYnVmKTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgc2VsZi50b3RhbENodW5rZWRCeXRlcyArPSBidWYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnBhcnRCdWZmZXJMZW5ndGggPj0gc2VsZi5wYXJ0U2l6ZSkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBzaW5nbGUgYnVmZmVyIHdlIGF2b2lkIGNvcHlmdWxsIGNvbmNhdFxuICAgICAgdmFyIHBidWYgPSBzZWxmLnBhcnRCdWZmZXJzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlcnNbMF0gOiBCdWZmZXIuY29uY2F0KHNlbGYucGFydEJ1ZmZlcnMpO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVycyA9IFtdO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoID0gMDtcblxuICAgICAgLy8gaWYgd2UgaGF2ZSBtb3JlIHRoYW4gcGFydFNpemUsIHB1c2ggdGhlIHJlc3QgYmFjayBvbiB0aGUgcXVldWVcbiAgICAgIGlmIChwYnVmLmxlbmd0aCA+IHNlbGYucGFydFNpemUpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBwYnVmLnNsaWNlKHNlbGYucGFydFNpemUpO1xuICAgICAgICBzZWxmLnBhcnRCdWZmZXJzLnB1c2gocmVzdCk7XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCArPSByZXN0Lmxlbmd0aDtcbiAgICAgICAgcGJ1ZiA9IHBidWYuc2xpY2UoMCwgc2VsZi5wYXJ0U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYubmV4dENodW5rKHBidWYpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmICFzZWxmLmlzRG9uZVNlbmRpbmcpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgc2luZ2xlIGJ1ZmZlciB3ZSBhdm9pZCBjb3B5ZnVsbCBjb25jYXRcbiAgICAgIHBidWYgPSBzZWxmLnBhcnRCdWZmZXJzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgc2VsZi5wYXJ0QnVmZmVyc1swXSA6IEJ1ZmZlci5jb25jYXQoc2VsZi5wYXJ0QnVmZmVycyk7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJzID0gW107XG4gICAgICBzZWxmLnBhcnRCdWZmZXJMZW5ndGggPSAwO1xuICAgICAgc2VsZi50b3RhbEJ5dGVzID0gc2VsZi50b3RhbENodW5rZWRCeXRlcztcbiAgICAgIHNlbGYuaXNEb25lU2VuZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChzZWxmLm51bVBhcnRzID09PSAwIHx8IHBidWYubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLm51bVBhcnRzKys7XG4gICAgICAgIHNlbGYubmV4dENodW5rKHBidWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuYm9keS5yZWFkKDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG5leHRDaHVuazogZnVuY3Rpb24gbmV4dENodW5rKGNodW5rKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmZhaWxlZCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcGFydE51bWJlciA9ICsrc2VsZi50b3RhbFBhcnROdW1iZXJzO1xuICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHBhcnROdW1iZXIgPT09IDEpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7Qm9keTogY2h1bmt9O1xuICAgICAgaWYgKHRoaXMudGFncykge1xuICAgICAgICBwYXJhbXMuVGFnZ2luZyA9IHRoaXMuZ2V0VGFnZ2luZ0hlYWRlcigpO1xuICAgICAgfVxuICAgICAgdmFyIHJlcSA9IHNlbGYuc2VydmljZS5wdXRPYmplY3QocGFyYW1zKTtcbiAgICAgIHJlcS5fbWFuYWdlZFVwbG9hZCA9IHNlbGY7XG4gICAgICByZXEub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIHNlbGYucHJvZ3Jlc3MpLnNlbmQoc2VsZi5maW5pc2hTaW5nbGVQYXJ0KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuQ29udGVudE1ENSkge1xuICAgICAgdmFyIGVyciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignVGhlIENvbnRlbnQtTUQ1IHlvdSBzcGVjaWZpZWQgaXMgaW52YWxpZCBmb3IgbXVsdGktcGFydCB1cGxvYWRzLicpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkRGlnZXN0JywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuY2xlYW51cChlcnIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdICYmIHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdLkVUYWcgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBBbHJlYWR5IHVwbG9hZGVkIHRoaXMgcGFydC5cbiAgICB9XG5cbiAgICBzZWxmLmFjdGl2ZVBhcnRzKys7XG4gICAgaWYgKCFzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5VcGxvYWRJZCkge1xuXG4gICAgICBpZiAoIXNlbGYubXVsdGlwYXJ0UmVxKSB7IC8vIGNyZWF0ZSBtdWx0aXBhcnRcbiAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEgPSBzZWxmLnNlcnZpY2UuY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKCk7XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLm9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlVwbG9hZElkID0gcmVzcC5kYXRhLlVwbG9hZElkO1xuICAgICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucXVldWVDaHVua3MoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgICAgICBzZWxmLm11bHRpcGFydFJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucXVldWVDaHVua3MoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG11bHRpcGFydCBpcyBjcmVhdGVkLCBqdXN0IHNlbmRcbiAgICAgIHNlbGYudXBsb2FkUGFydChjaHVuaywgcGFydE51bWJlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFRhZ2dpbmdIZWFkZXI6IGZ1bmN0aW9uIGdldFRhZ2dpbmdIZWFkZXIoKSB7XG4gICAgdmFyIGt2UGFpclN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAga3ZQYWlyU3RyaW5ncy5wdXNoKEFXUy51dGlsLnVyaUVzY2FwZSh0aGlzLnRhZ3NbaV0uS2V5KSArICc9JyArXG4gICAgICAgIEFXUy51dGlsLnVyaUVzY2FwZSh0aGlzLnRhZ3NbaV0uVmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga3ZQYWlyU3RyaW5ncy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXBsb2FkUGFydDogZnVuY3Rpb24gdXBsb2FkUGFydChjaHVuaywgcGFydE51bWJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwYXJ0UGFyYW1zID0ge1xuICAgICAgQm9keTogY2h1bmssXG4gICAgICBDb250ZW50TGVuZ3RoOiBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aChjaHVuayksXG4gICAgICBQYXJ0TnVtYmVyOiBwYXJ0TnVtYmVyXG4gICAgfTtcblxuICAgIHZhciBwYXJ0SW5mbyA9IHtFVGFnOiBudWxsLCBQYXJ0TnVtYmVyOiBwYXJ0TnVtYmVyfTtcbiAgICBzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXSA9IHBhcnRJbmZvO1xuXG4gICAgdmFyIHJlcSA9IHNlbGYuc2VydmljZS51cGxvYWRQYXJ0KHBhcnRQYXJhbXMpO1xuICAgIHNlbGYucGFydHNbcGFydE51bWJlcl0gPSByZXE7XG4gICAgcmVxLl9sYXN0VXBsb2FkZWRCeXRlcyA9IDA7XG4gICAgcmVxLl9tYW5hZ2VkVXBsb2FkID0gc2VsZjtcbiAgICByZXEub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIHNlbGYucHJvZ3Jlc3MpO1xuICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgZGVsZXRlIHNlbGYucGFydHNbcGFydFBhcmFtcy5QYXJ0TnVtYmVyXTtcbiAgICAgIHNlbGYuYWN0aXZlUGFydHMtLTtcblxuICAgICAgaWYgKCFlcnIgJiYgKCFkYXRhIHx8ICFkYXRhLkVUYWcpKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ05vIGFjY2VzcyB0byBFVGFnIHByb3BlcnR5IG9uIHJlc3BvbnNlLic7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gJyBDaGVjayBDT1JTIGNvbmZpZ3VyYXRpb24gdG8gZXhwb3NlIEVUYWcgaGVhZGVyLic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnRVRhZ01pc3NpbmcnLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuY2xlYW51cChlcnIpO1xuXG4gICAgICBwYXJ0SW5mby5FVGFnID0gZGF0YS5FVGFnO1xuICAgICAgc2VsZi5kb25lUGFydHMrKztcbiAgICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHNlbGYuZG9uZVBhcnRzID09PSBzZWxmLm51bVBhcnRzKSB7XG4gICAgICAgIHNlbGYuZmluaXNoTXVsdGlQYXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmZpbGxRdWV1ZS5jYWxsKHNlbGYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHF1ZXVlQ2h1bmtzOiBmdW5jdGlvbiBxdWV1ZUNodW5rcyhjaHVuaywgcGFydE51bWJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm11bHRpcGFydFJlcS5vbignc3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi51cGxvYWRQYXJ0KGNodW5rLCBwYXJ0TnVtYmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKGVycikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mYWlsZWQpIHJldHVybjtcblxuICAgIC8vIGNsZWFuIHVwIHN0cmVhbVxuICAgIGlmICh0eXBlb2Ygc2VsZi5ib2R5LnJlbW92ZUFsbExpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2Ygc2VsZi5ib2R5LnJlc3VtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZi5ib2R5LnJlbW92ZUFsbExpc3RlbmVycygncmVhZGFibGUnKTtcbiAgICAgIHNlbGYuYm9keS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICAgICAgc2VsZi5ib2R5LnJlc3VtZSgpO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXAgbXVsdGlwYXJ0UmVxIGxpc3RlbmVyc1xuICAgIGlmIChzZWxmLm11bHRpcGFydFJlcSkge1xuICAgICAgc2VsZi5tdWx0aXBhcnRSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKCdzdWNjZXNzJyk7XG4gICAgICBzZWxmLm11bHRpcGFydFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgICBzZWxmLm11bHRpcGFydFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2NvbXBsZXRlJyk7XG4gICAgICBkZWxldGUgc2VsZi5tdWx0aXBhcnRSZXE7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlVwbG9hZElkICYmICFzZWxmLmxlYXZlUGFydHNPbkVycm9yKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuYWJvcnRNdWx0aXBhcnRVcGxvYWQoKS5zZW5kKCk7XG4gICAgfSBlbHNlIGlmIChzZWxmLmxlYXZlUGFydHNPbkVycm9yKSB7XG4gICAgICBzZWxmLmlzRG9uZUNodW5raW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgQVdTLnV0aWwuZWFjaChzZWxmLnBhcnRzLCBmdW5jdGlvbihwYXJ0TnVtYmVyLCBwYXJ0KSB7XG4gICAgICBwYXJ0LnJlbW92ZUFsbExpc3RlbmVycygnY29tcGxldGUnKTtcbiAgICAgIHBhcnQuYWJvcnQoKTtcbiAgICB9KTtcblxuICAgIHNlbGYuYWN0aXZlUGFydHMgPSAwO1xuICAgIHNlbGYucGFydFBvcyA9IDA7XG4gICAgc2VsZi5udW1QYXJ0cyA9IDA7XG4gICAgc2VsZi50b3RhbFBhcnROdW1iZXJzID0gMDtcbiAgICBzZWxmLnBhcnRzID0ge307XG4gICAgc2VsZi5mYWlsZWQgPSB0cnVlO1xuICAgIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmaW5pc2hNdWx0aVBhcnQ6IGZ1bmN0aW9uIGZpbmlzaE11bHRpUGFydCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbXBsZXRlUGFyYW1zID0geyBNdWx0aXBhcnRVcGxvYWQ6IHsgUGFydHM6IHNlbGYuY29tcGxldGVJbmZvLnNsaWNlKDEpIH0gfTtcbiAgICBzZWxmLnNlcnZpY2UuY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoY29tcGxldGVQYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5jbGVhbnVwKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhLkxvY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhLkxvY2F0aW9uID0gZGF0YS5Mb2NhdGlvbi5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZi50YWdzKSkge1xuICAgICAgICBzZWxmLnNlcnZpY2UucHV0T2JqZWN0VGFnZ2luZyhcbiAgICAgICAgICB7VGFnZ2luZzoge1RhZ1NldDogc2VsZi50YWdzfX0sXG4gICAgICAgICAgZnVuY3Rpb24oZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2soZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbmlzaFNpbmdsZVBhcnQ6IGZ1bmN0aW9uIGZpbmlzaFNpbmdsZVBhcnQoZXJyLCBkYXRhKSB7XG4gICAgdmFyIHVwbG9hZCA9IHRoaXMucmVxdWVzdC5fbWFuYWdlZFVwbG9hZDtcbiAgICB2YXIgaHR0cFJlcSA9IHRoaXMucmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICB2YXIgZW5kcG9pbnQgPSBodHRwUmVxLmVuZHBvaW50O1xuICAgIGlmIChlcnIpIHJldHVybiB1cGxvYWQuY2FsbGJhY2soZXJyKTtcbiAgICBkYXRhLkxvY2F0aW9uID1cbiAgICAgIFtlbmRwb2ludC5wcm90b2NvbCwgJy8vJywgZW5kcG9pbnQuaG9zdCwgaHR0cFJlcS5wYXRoXS5qb2luKCcnKTtcbiAgICBkYXRhLmtleSA9IHRoaXMucmVxdWVzdC5wYXJhbXMuS2V5OyAvLyB3aWxsIHN0YXkgdW5kb2N1bWVudGVkXG4gICAgZGF0YS5LZXkgPSB0aGlzLnJlcXVlc3QucGFyYW1zLktleTtcbiAgICBkYXRhLkJ1Y2tldCA9IHRoaXMucmVxdWVzdC5wYXJhbXMuQnVja2V0O1xuICAgIHVwbG9hZC5jYWxsYmFjayhlcnIsIGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhpbmZvKSB7XG4gICAgdmFyIHVwbG9hZCA9IHRoaXMuX21hbmFnZWRVcGxvYWQ7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uID09PSAncHV0T2JqZWN0Jykge1xuICAgICAgaW5mby5wYXJ0ID0gMTtcbiAgICAgIGluZm8ua2V5ID0gdGhpcy5wYXJhbXMuS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGxvYWQudG90YWxVcGxvYWRlZEJ5dGVzICs9IGluZm8ubG9hZGVkIC0gdGhpcy5fbGFzdFVwbG9hZGVkQnl0ZXM7XG4gICAgICB0aGlzLl9sYXN0VXBsb2FkZWRCeXRlcyA9IGluZm8ubG9hZGVkO1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAgbG9hZGVkOiB1cGxvYWQudG90YWxVcGxvYWRlZEJ5dGVzLFxuICAgICAgICB0b3RhbDogdXBsb2FkLnRvdGFsQnl0ZXMsXG4gICAgICAgIHBhcnQ6IHRoaXMucGFyYW1zLlBhcnROdW1iZXIsXG4gICAgICAgIGtleTogdGhpcy5wYXJhbXMuS2V5XG4gICAgICB9O1xuICAgIH1cbiAgICB1cGxvYWQuZW1pdCgnaHR0cFVwbG9hZFByb2dyZXNzJywgW2luZm9dKTtcbiAgfVxufSk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5TMy5NYW5hZ2VkVXBsb2FkLCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQuYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLnByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ3NlbmQnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUzMuTWFuYWdlZFVwbG9hZC5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBV1MuUzMuTWFuYWdlZFVwbG9hZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3MzL21hbmFnZWRfdXBsb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInZlcnNpb25cIjpcIjIuMFwiLFwibWV0YWRhdGFcIjp7XCJhcGlWZXJzaW9uXCI6XCIyMDA2LTAzLTAxXCIsXCJjaGVja3N1bUZvcm1hdFwiOlwibWQ1XCIsXCJlbmRwb2ludFByZWZpeFwiOlwiczNcIixcImdsb2JhbEVuZHBvaW50XCI6XCJzMy5hbWF6b25hd3MuY29tXCIsXCJwcm90b2NvbFwiOlwicmVzdC14bWxcIixcInNlcnZpY2VBYmJyZXZpYXRpb25cIjpcIkFtYXpvbiBTM1wiLFwic2VydmljZUZ1bGxOYW1lXCI6XCJBbWF6b24gU2ltcGxlIFN0b3JhZ2UgU2VydmljZVwiLFwic2lnbmF0dXJlVmVyc2lvblwiOlwiczNcIixcInRpbWVzdGFtcEZvcm1hdFwiOlwicmZjODIyXCIsXCJ1aWRcIjpcInMzLTIwMDYtMDMtMDFcIn0sXCJvcGVyYXRpb25zXCI6e1wiQWJvcnRNdWx0aXBhcnRVcGxvYWRcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fS97S2V5K31cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiLFwiVXBsb2FkSWRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIlVwbG9hZElkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInVwbG9hZElkXCJ9LFwiUmVxdWVzdFBheWVyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJSZXF1ZXN0Q2hhcmdlZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJ9fX19LFwiQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRcIjp7XCJodHRwXCI6e1wicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiS2V5XCIsXCJVcGxvYWRJZFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiTXVsdGlwYXJ0VXBsb2FkXCI6e1wibG9jYXRpb25OYW1lXCI6XCJDb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJQYXJ0c1wiOntcImxvY2F0aW9uTmFtZVwiOlwiUGFydFwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiRVRhZ1wiOnt9LFwiUGFydE51bWJlclwiOntcInR5cGVcIjpcImludGVnZXJcIn19fSxcImZsYXR0ZW5lZFwiOnRydWV9fX0sXCJVcGxvYWRJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ1cGxvYWRJZFwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifX0sXCJwYXlsb2FkXCI6XCJNdWx0aXBhcnRVcGxvYWRcIn0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJMb2NhdGlvblwiOnt9LFwiQnVja2V0XCI6e30sXCJLZXlcIjp7fSxcIkV4cGlyYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWV4cGlyYXRpb25cIn0sXCJFVGFnXCI6e30sXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotdmVyc2lvbi1pZFwifSxcIlNTRUtNU0tleUlkXCI6e1wic2hhcGVcIjpcIlNqXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIn0sXCJSZXF1ZXN0Q2hhcmdlZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJ9fX19LFwiQ29weU9iamVjdFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiQ29weVNvdXJjZVwiLFwiS2V5XCJdLFwibWVtYmVyc1wiOntcIkFDTFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotYWNsXCJ9LFwiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJDYWNoZUNvbnRyb2xcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNhY2hlLUNvbnRyb2xcIn0sXCJDb250ZW50RGlzcG9zaXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRGlzcG9zaXRpb25cIn0sXCJDb250ZW50RW5jb2RpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRW5jb2RpbmdcIn0sXCJDb250ZW50TGFuZ3VhZ2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTGFuZ3VhZ2VcIn0sXCJDb250ZW50VHlwZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1UeXBlXCJ9LFwiQ29weVNvdXJjZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2VcIn0sXCJDb3B5U291cmNlSWZNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2UtaWYtbWF0Y2hcIn0sXCJDb3B5U291cmNlSWZNb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiQ29weVNvdXJjZUlmTm9uZU1hdGNoXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1ub25lLW1hdGNoXCJ9LFwiQ29weVNvdXJjZUlmVW5tb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi11bm1vZGlmaWVkLXNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJFeHBpcmVzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJFeHBpcmVzXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJHcmFudEZ1bGxDb250cm9sXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIn0sXCJHcmFudFJlYWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXJlYWRcIn0sXCJHcmFudFJlYWRBQ1BcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXJlYWQtYWNwXCJ9LFwiR3JhbnRXcml0ZUFDUFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJ9LFwiS2V5XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJLZXlcIn0sXCJNZXRhZGF0YVwiOntcInNoYXBlXCI6XCJTMTFcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJzXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LW1ldGEtXCJ9LFwiTWV0YWRhdGFEaXJlY3RpdmVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LW1ldGFkYXRhLWRpcmVjdGl2ZVwifSxcIlRhZ2dpbmdEaXJlY3RpdmVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXRhZ2dpbmctZGlyZWN0aXZlXCJ9LFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIn0sXCJTdG9yYWdlQ2xhc3NcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXN0b3JhZ2UtY2xhc3NcIn0sXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwifSxcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIlNTRUN1c3RvbWVyS2V5XCI6e1wic2hhcGVcIjpcIlMxOVwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwifSxcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIn0sXCJTU0VLTVNLZXlJZFwiOntcInNoYXBlXCI6XCJTalwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJ9LFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIkNvcHlTb3VyY2VTU0VDdXN0b21lcktleVwiOntcInNoYXBlXCI6XCJTMWNcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIn0sXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifSxcIlRhZ2dpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXRhZ2dpbmdcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkNvcHlPYmplY3RSZXN1bHRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJFVGFnXCI6e30sXCJMYXN0TW9kaWZpZWRcIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn19fSxcIkV4cGlyYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWV4cGlyYXRpb25cIn0sXCJDb3B5U291cmNlVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS12ZXJzaW9uLWlkXCJ9LFwiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei12ZXJzaW9uLWlkXCJ9LFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiU1NFS01TS2V5SWRcIjp7XCJzaGFwZVwiOlwiU2pcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwifSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn19LFwicGF5bG9hZFwiOlwiQ29weU9iamVjdFJlc3VsdFwifSxcImFsaWFzXCI6XCJQdXRPYmplY3RDb3B5XCJ9LFwiQ3JlYXRlQnVja2V0XCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH1cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQUNMXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1hY2xcIn0sXCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9LFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTG9jYXRpb25Db25zdHJhaW50XCI6e319fSxcIkdyYW50RnVsbENvbnRyb2xcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LWZ1bGwtY29udHJvbFwifSxcIkdyYW50UmVhZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtcmVhZFwifSxcIkdyYW50UmVhZEFDUFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIn0sXCJHcmFudFdyaXRlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC13cml0ZVwifSxcIkdyYW50V3JpdGVBQ1BcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXdyaXRlLWFjcFwifX0sXCJwYXlsb2FkXCI6XCJDcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uXCJ9LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTG9jYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkxvY2F0aW9uXCJ9fX0sXCJhbGlhc1wiOlwiUHV0QnVja2V0XCJ9LFwiQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkXCI6e1wiaHR0cFwiOntcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fS97S2V5K30/dXBsb2Fkc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiS2V5XCJdLFwibWVtYmVyc1wiOntcIkFDTFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotYWNsXCJ9LFwiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJDYWNoZUNvbnRyb2xcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNhY2hlLUNvbnRyb2xcIn0sXCJDb250ZW50RGlzcG9zaXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRGlzcG9zaXRpb25cIn0sXCJDb250ZW50RW5jb2RpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRW5jb2RpbmdcIn0sXCJDb250ZW50TGFuZ3VhZ2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTGFuZ3VhZ2VcIn0sXCJDb250ZW50VHlwZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1UeXBlXCJ9LFwiRXhwaXJlc1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiRXhwaXJlc1wiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiR3JhbnRGdWxsQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJ9LFwiR3JhbnRSZWFkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkXCJ9LFwiR3JhbnRSZWFkQUNQXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkLWFjcFwifSxcIkdyYW50V3JpdGVBQ1BcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXdyaXRlLWFjcFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiTWV0YWRhdGFcIjp7XCJzaGFwZVwiOlwiUzExXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyc1wiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1tZXRhLVwifSxcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiU3RvcmFnZUNsYXNzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJ9LFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleVwiOntcInNoYXBlXCI6XCJTMTlcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiU1NFS01TS2V5SWRcIjp7XCJzaGFwZVwiOlwiU2pcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifSxcIlRhZ2dpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXRhZ2dpbmdcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkFib3J0RGF0ZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotYWJvcnQtZGF0ZVwiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiQWJvcnRSdWxlSWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWFib3J0LXJ1bGUtaWRcIn0sXCJCdWNrZXRcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOnt9LFwiVXBsb2FkSWRcIjp7fSxcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJ9LFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwifSxcIlNTRUtNU0tleUlkXCI6e1wic2hhcGVcIjpcIlNqXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIn0sXCJSZXF1ZXN0Q2hhcmdlZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJ9fX0sXCJhbGlhc1wiOlwiSW5pdGlhdGVNdWx0aXBhcnRVcGxvYWRcIn0sXCJEZWxldGVCdWNrZXRcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifX19fSxcIkRlbGV0ZUJ1Y2tldEFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9hbmFseXRpY3NcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIklkXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiaWRcIn19fX0sXCJEZWxldGVCdWNrZXRDb3JzXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiREVMRVRFXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/Y29yc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifX19fSxcIkRlbGV0ZUJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9pbnZlbnRvcnlcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIklkXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiaWRcIn19fX0sXCJEZWxldGVCdWNrZXRMaWZlY3ljbGVcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9saWZlY3ljbGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fX0sXCJEZWxldGVCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkRFTEVURVwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P21ldHJpY3NcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIklkXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiaWRcIn19fX0sXCJEZWxldGVCdWNrZXRQb2xpY3lcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJERUxFVEVcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9wb2xpY3lcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fX0sXCJEZWxldGVCdWNrZXRSZXBsaWNhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkRFTEVURVwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX19LFwiRGVsZXRlQnVja2V0VGFnZ2luZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkRFTEVURVwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3RhZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fX0sXCJEZWxldGVCdWNrZXRXZWJzaXRlXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiREVMRVRFXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/d2Vic2l0ZVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifX19fSxcIkRlbGV0ZU9iamVjdFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkRFTEVURVwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiS2V5XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiS2V5XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJLZXlcIn0sXCJNRkFcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LW1mYVwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ2ZXJzaW9uSWRcIn0sXCJSZXF1ZXN0UGF5ZXJcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtcGF5ZXJcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkRlbGV0ZU1hcmtlclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZGVsZXRlLW1hcmtlclwiLFwidHlwZVwiOlwiYm9vbGVhblwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotdmVyc2lvbi1pZFwifSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn19fX0sXCJEZWxldGVPYmplY3RUYWdnaW5nXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiREVMRVRFXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInZlcnNpb25JZFwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei12ZXJzaW9uLWlkXCJ9fX19LFwiRGVsZXRlT2JqZWN0c1wiOntcImh0dHBcIjp7XCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/ZGVsZXRlXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJEZWxldGVcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJEZWxldGVcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkRlbGV0ZVwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiT2JqZWN0c1wiXSxcIm1lbWJlcnNcIjp7XCJPYmplY3RzXCI6e1wibG9jYXRpb25OYW1lXCI6XCJPYmplY3RcIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJLZXlcIl0sXCJtZW1iZXJzXCI6e1wiS2V5XCI6e30sXCJWZXJzaW9uSWRcIjp7fX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJRdWlldFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn19fSxcIk1GQVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotbWZhXCJ9LFwiUmVxdWVzdFBheWVyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJ9fSxcInBheWxvYWRcIjpcIkRlbGV0ZVwifSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkRlbGV0ZWRcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJLZXlcIjp7fSxcIlZlcnNpb25JZFwiOnt9LFwiRGVsZXRlTWFya2VyXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcIkRlbGV0ZU1hcmtlclZlcnNpb25JZFwiOnt9fX0sXCJmbGF0dGVuZWRcIjp0cnVlfSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn0sXCJFcnJvcnNcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkVycm9yXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJLZXlcIjp7fSxcIlZlcnNpb25JZFwiOnt9LFwiQ29kZVwiOnt9LFwiTWVzc2FnZVwiOnt9fX0sXCJmbGF0dGVuZWRcIjp0cnVlfX19LFwiYWxpYXNcIjpcIkRlbGV0ZU11bHRpcGxlT2JqZWN0c1wifSxcIkdldEJ1Y2tldEFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/YWNjZWxlcmF0ZVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiU3RhdHVzXCI6e319fX0sXCJHZXRCdWNrZXRBY2xcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9hY2xcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIk93bmVyXCI6e1wic2hhcGVcIjpcIlMydVwifSxcIkdyYW50c1wiOntcInNoYXBlXCI6XCJTMnhcIixcImxvY2F0aW9uTmFtZVwiOlwiQWNjZXNzQ29udHJvbExpc3RcIn19fX0sXCJHZXRCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/YW5hbHl0aWNzXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJJZFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImlkXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6e1wic2hhcGVcIjpcIlMzNlwifX0sXCJwYXlsb2FkXCI6XCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCJ9fSxcIkdldEJ1Y2tldENvcnNcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9jb3JzXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJDT1JTUnVsZXNcIjp7XCJzaGFwZVwiOlwiUzNtXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNPUlNSdWxlXCJ9fX19LFwiR2V0QnVja2V0SW52ZW50b3J5Q29uZmlndXJhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2ludmVudG9yeVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiSWRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJpZFwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiOntcInNoYXBlXCI6XCJTM3pcIn19LFwicGF5bG9hZFwiOlwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwifX0sXCJHZXRCdWNrZXRMaWZlY3ljbGVcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9saWZlY3ljbGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlJ1bGVzXCI6e1wic2hhcGVcIjpcIlM0Y1wiLFwibG9jYXRpb25OYW1lXCI6XCJSdWxlXCJ9fX0sXCJkZXByZWNhdGVkXCI6dHJ1ZX0sXCJHZXRCdWNrZXRMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/bGlmZWN5Y2xlXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJSdWxlc1wiOntcInNoYXBlXCI6XCJTNHJcIixcImxvY2F0aW9uTmFtZVwiOlwiUnVsZVwifX19fSxcIkdldEJ1Y2tldExvY2F0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/bG9jYXRpb25cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkxvY2F0aW9uQ29uc3RyYWludFwiOnt9fX19LFwiR2V0QnVja2V0TG9nZ2luZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2xvZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkxvZ2dpbmdFbmFibGVkXCI6e1wic2hhcGVcIjpcIlM1MVwifX19fSxcIkdldEJ1Y2tldE1ldHJpY3NDb25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/bWV0cmljc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiSWRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJpZFwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTWV0cmljc0NvbmZpZ3VyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzU5XCJ9fSxcInBheWxvYWRcIjpcIk1ldHJpY3NDb25maWd1cmF0aW9uXCJ9fSxcIkdldEJ1Y2tldE5vdGlmaWNhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwifSxcImlucHV0XCI6e1wic2hhcGVcIjpcIlM1Y1wifSxcIm91dHB1dFwiOntcInNoYXBlXCI6XCJTNWRcIn0sXCJkZXByZWNhdGVkXCI6dHJ1ZX0sXCJHZXRCdWNrZXROb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/bm90aWZpY2F0aW9uXCJ9LFwiaW5wdXRcIjp7XCJzaGFwZVwiOlwiUzVjXCJ9LFwib3V0cHV0XCI6e1wic2hhcGVcIjpcIlM1b1wifX0sXCJHZXRCdWNrZXRQb2xpY3lcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9wb2xpY3lcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlBvbGljeVwiOnt9fSxcInBheWxvYWRcIjpcIlBvbGljeVwifX0sXCJHZXRCdWNrZXRSZXBsaWNhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzY3XCJ9fSxcInBheWxvYWRcIjpcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwifX0sXCJHZXRCdWNrZXRSZXF1ZXN0UGF5bWVudFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3JlcXVlc3RQYXltZW50XCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJQYXllclwiOnt9fX19LFwiR2V0QnVja2V0VGFnZ2luZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3RhZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJUYWdTZXRcIl0sXCJtZW1iZXJzXCI6e1wiVGFnU2V0XCI6e1wic2hhcGVcIjpcIlMzY1wifX19fSxcIkdldEJ1Y2tldFZlcnNpb25pbmdcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT92ZXJzaW9uaW5nXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJTdGF0dXNcIjp7fSxcIk1GQURlbGV0ZVwiOntcImxvY2F0aW9uTmFtZVwiOlwiTWZhRGVsZXRlXCJ9fX19LFwiR2V0QnVja2V0V2Vic2l0ZVwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3dlYnNpdGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlJlZGlyZWN0QWxsUmVxdWVzdHNUb1wiOntcInNoYXBlXCI6XCJTNm9cIn0sXCJJbmRleERvY3VtZW50XCI6e1wic2hhcGVcIjpcIlM2clwifSxcIkVycm9yRG9jdW1lbnRcIjp7XCJzaGFwZVwiOlwiUzZ0XCJ9LFwiUm91dGluZ1J1bGVzXCI6e1wic2hhcGVcIjpcIlM2dVwifX19fSxcIkdldE9iamVjdFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiS2V5XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWZNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiSWYtTWF0Y2hcIn0sXCJJZk1vZGlmaWVkU2luY2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIklmLU1vZGlmaWVkLVNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJJZk5vbmVNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiSWYtTm9uZS1NYXRjaFwifSxcIklmVW5tb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIlJhbmdlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJSYW5nZVwifSxcIlJlc3BvbnNlQ2FjaGVDb250cm9sXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInJlc3BvbnNlLWNhY2hlLWNvbnRyb2xcIn0sXCJSZXNwb25zZUNvbnRlbnREaXNwb3NpdGlvblwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uXCJ9LFwiUmVzcG9uc2VDb250ZW50RW5jb2RpbmdcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwicmVzcG9uc2UtY29udGVudC1lbmNvZGluZ1wifSxcIlJlc3BvbnNlQ29udGVudExhbmd1YWdlXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInJlc3BvbnNlLWNvbnRlbnQtbGFuZ3VhZ2VcIn0sXCJSZXNwb25zZUNvbnRlbnRUeXBlXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInJlc3BvbnNlLWNvbnRlbnQtdHlwZVwifSxcIlJlc3BvbnNlRXhwaXJlc1wiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJyZXNwb25zZS1leHBpcmVzXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJWZXJzaW9uSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwidmVyc2lvbklkXCJ9LFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJ9LFwiU1NFQ3VzdG9tZXJLZXlcIjp7XCJzaGFwZVwiOlwiUzE5XCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJ9LFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifSxcIlBhcnROdW1iZXJcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwicGFydE51bWJlclwiLFwidHlwZVwiOlwiaW50ZWdlclwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiQm9keVwiOntcInN0cmVhbWluZ1wiOnRydWUsXCJ0eXBlXCI6XCJibG9iXCJ9LFwiRGVsZXRlTWFya2VyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiQWNjZXB0UmFuZ2VzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJhY2NlcHQtcmFuZ2VzXCJ9LFwiRXhwaXJhdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZXhwaXJhdGlvblwifSxcIlJlc3RvcmVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlc3RvcmVcIn0sXCJMYXN0TW9kaWZpZWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkxhc3QtTW9kaWZpZWRcIixcInR5cGVcIjpcInRpbWVzdGFtcFwifSxcIkNvbnRlbnRMZW5ndGhcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTGVuZ3RoXCIsXCJ0eXBlXCI6XCJsb25nXCJ9LFwiRVRhZ1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiRVRhZ1wifSxcIk1pc3NpbmdNZXRhXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1taXNzaW5nLW1ldGFcIixcInR5cGVcIjpcImludGVnZXJcIn0sXCJWZXJzaW9uSWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXZlcnNpb24taWRcIn0sXCJDYWNoZUNvbnRyb2xcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNhY2hlLUNvbnRyb2xcIn0sXCJDb250ZW50RGlzcG9zaXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRGlzcG9zaXRpb25cIn0sXCJDb250ZW50RW5jb2RpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtRW5jb2RpbmdcIn0sXCJDb250ZW50TGFuZ3VhZ2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTGFuZ3VhZ2VcIn0sXCJDb250ZW50UmFuZ2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtUmFuZ2VcIn0sXCJDb250ZW50VHlwZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1UeXBlXCJ9LFwiRXhwaXJlc1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiRXhwaXJlc1wiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIn0sXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwifSxcIk1ldGFkYXRhXCI6e1wic2hhcGVcIjpcIlMxMVwiLFwibG9jYXRpb25cIjpcImhlYWRlcnNcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotbWV0YS1cIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiU1NFS01TS2V5SWRcIjp7XCJzaGFwZVwiOlwiU2pcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwifSxcIlN0b3JhZ2VDbGFzc1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc3RvcmFnZS1jbGFzc1wifSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn0sXCJSZXBsaWNhdGlvblN0YXR1c1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVwbGljYXRpb24tc3RhdHVzXCJ9LFwiUGFydHNDb3VudFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotbXAtcGFydHMtY291bnRcIixcInR5cGVcIjpcImludGVnZXJcIn0sXCJUYWdDb3VudFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotdGFnZ2luZy1jb3VudFwiLFwidHlwZVwiOlwiaW50ZWdlclwifX0sXCJwYXlsb2FkXCI6XCJCb2R5XCJ9fSxcIkdldE9iamVjdEFjbFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfT9hY2xcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInZlcnNpb25JZFwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiT3duZXJcIjp7XCJzaGFwZVwiOlwiUzJ1XCJ9LFwiR3JhbnRzXCI6e1wic2hhcGVcIjpcIlMyeFwiLFwibG9jYXRpb25OYW1lXCI6XCJBY2Nlc3NDb250cm9sTGlzdFwifSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn19fX0sXCJHZXRPYmplY3RUYWdnaW5nXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInZlcnNpb25JZFwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlRhZ1NldFwiXSxcIm1lbWJlcnNcIjp7XCJWZXJzaW9uSWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXZlcnNpb24taWRcIn0sXCJUYWdTZXRcIjp7XCJzaGFwZVwiOlwiUzNjXCJ9fX19LFwiR2V0T2JqZWN0VG9ycmVudFwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfT90b3JyZW50XCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJLZXlcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiQm9keVwiOntcInN0cmVhbWluZ1wiOnRydWUsXCJ0eXBlXCI6XCJibG9iXCJ9LFwiUmVxdWVzdENoYXJnZWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwifX0sXCJwYXlsb2FkXCI6XCJCb2R5XCJ9fSxcIkhlYWRCdWNrZXRcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJIRUFEXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH1cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn19fX0sXCJIZWFkT2JqZWN0XCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiSEVBRFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiS2V5XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWZNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiSWYtTWF0Y2hcIn0sXCJJZk1vZGlmaWVkU2luY2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIklmLU1vZGlmaWVkLVNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJJZk5vbmVNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiSWYtTm9uZS1NYXRjaFwifSxcIklmVW5tb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIlJhbmdlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJSYW5nZVwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ2ZXJzaW9uSWRcIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleVwiOntcInNoYXBlXCI6XCJTMTlcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiUmVxdWVzdFBheWVyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJ9LFwiUGFydE51bWJlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJwYXJ0TnVtYmVyXCIsXCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJEZWxldGVNYXJrZXJcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWRlbGV0ZS1tYXJrZXJcIixcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJBY2NlcHRSYW5nZXNcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcImFjY2VwdC1yYW5nZXNcIn0sXCJFeHBpcmF0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1leHBpcmF0aW9uXCJ9LFwiUmVzdG9yZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVzdG9yZVwifSxcIkxhc3RNb2RpZmllZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiTGFzdC1Nb2RpZmllZFwiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiQ29udGVudExlbmd0aFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1MZW5ndGhcIixcInR5cGVcIjpcImxvbmdcIn0sXCJFVGFnXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJFVGFnXCJ9LFwiTWlzc2luZ01ldGFcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LW1pc3NpbmctbWV0YVwiLFwidHlwZVwiOlwiaW50ZWdlclwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotdmVyc2lvbi1pZFwifSxcIkNhY2hlQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ2FjaGUtQ29udHJvbFwifSxcIkNvbnRlbnREaXNwb3NpdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1EaXNwb3NpdGlvblwifSxcIkNvbnRlbnRFbmNvZGluZ1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1FbmNvZGluZ1wifSxcIkNvbnRlbnRMYW5ndWFnZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1MYW5ndWFnZVwifSxcIkNvbnRlbnRUeXBlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJDb250ZW50LVR5cGVcIn0sXCJFeHBpcmVzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJFeHBpcmVzXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwifSxcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiTWV0YWRhdGFcIjp7XCJzaGFwZVwiOlwiUzExXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyc1wiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1tZXRhLVwifSxcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIn0sXCJTU0VLTVNLZXlJZFwiOntcInNoYXBlXCI6XCJTalwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJ9LFwiU3RvcmFnZUNsYXNzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJ9LFwiUmVxdWVzdENoYXJnZWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwifSxcIlJlcGxpY2F0aW9uU3RhdHVzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIn0sXCJQYXJ0c0NvdW50XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1tcC1wYXJ0cy1jb3VudFwiLFwidHlwZVwiOlwiaW50ZWdlclwifX19fSxcIkxpc3RCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uc1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2FuYWx5dGljc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRpbnVhdGlvblRva2VuXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImNvbnRpbnVhdGlvbi10b2tlblwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSXNUcnVuY2F0ZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiQ29udGludWF0aW9uVG9rZW5cIjp7fSxcIk5leHRDb250aW51YXRpb25Ub2tlblwiOnt9LFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvbkxpc3RcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInNoYXBlXCI6XCJTMzZcIn0sXCJmbGF0dGVuZWRcIjp0cnVlfX19fSxcIkxpc3RCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uc1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2ludmVudG9yeVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRpbnVhdGlvblRva2VuXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImNvbnRpbnVhdGlvbi10b2tlblwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiQ29udGludWF0aW9uVG9rZW5cIjp7fSxcIkludmVudG9yeUNvbmZpZ3VyYXRpb25MaXN0XCI6e1wibG9jYXRpb25OYW1lXCI6XCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJzaGFwZVwiOlwiUzN6XCJ9LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJJc1RydW5jYXRlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjp7fX19fSxcIkxpc3RCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvbnNcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9tZXRyaWNzXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29udGludWF0aW9uVG9rZW5cIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiY29udGludWF0aW9uLXRva2VuXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJc1RydW5jYXRlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJDb250aW51YXRpb25Ub2tlblwiOnt9LFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCI6e30sXCJNZXRyaWNzQ29uZmlndXJhdGlvbkxpc3RcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIk1ldHJpY3NDb25maWd1cmF0aW9uXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJzaGFwZVwiOlwiUzU5XCJ9LFwiZmxhdHRlbmVkXCI6dHJ1ZX19fX0sXCJMaXN0QnVja2V0c1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwifSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkJ1Y2tldHNcIjp7XCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwiLFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTmFtZVwiOnt9LFwiQ3JlYXRpb25EYXRlXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9fX19LFwiT3duZXJcIjp7XCJzaGFwZVwiOlwiUzJ1XCJ9fX0sXCJhbGlhc1wiOlwiR2V0U2VydmljZVwifSxcIkxpc3RNdWx0aXBhcnRVcGxvYWRzXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiR0VUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/dXBsb2Fkc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkRlbGltaXRlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJkZWxpbWl0ZXJcIn0sXCJFbmNvZGluZ1R5cGVcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiZW5jb2RpbmctdHlwZVwifSxcIktleU1hcmtlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJrZXktbWFya2VyXCJ9LFwiTWF4VXBsb2Fkc1wiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJtYXgtdXBsb2Fkc1wiLFwidHlwZVwiOlwiaW50ZWdlclwifSxcIlByZWZpeFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJwcmVmaXhcIn0sXCJVcGxvYWRJZE1hcmtlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ1cGxvYWQtaWQtbWFya2VyXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7fSxcIktleU1hcmtlclwiOnt9LFwiVXBsb2FkSWRNYXJrZXJcIjp7fSxcIk5leHRLZXlNYXJrZXJcIjp7fSxcIlByZWZpeFwiOnt9LFwiRGVsaW1pdGVyXCI6e30sXCJOZXh0VXBsb2FkSWRNYXJrZXJcIjp7fSxcIk1heFVwbG9hZHNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiSXNUcnVuY2F0ZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiVXBsb2Fkc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiVXBsb2FkXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJVcGxvYWRJZFwiOnt9LFwiS2V5XCI6e30sXCJJbml0aWF0ZWRcIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJTdG9yYWdlQ2xhc3NcIjp7fSxcIk93bmVyXCI6e1wic2hhcGVcIjpcIlMydVwifSxcIkluaXRpYXRvclwiOntcInNoYXBlXCI6XCJTOHFcIn19fSxcImZsYXR0ZW5lZFwiOnRydWV9LFwiQ29tbW9uUHJlZml4ZXNcIjp7XCJzaGFwZVwiOlwiUzhyXCJ9LFwiRW5jb2RpbmdUeXBlXCI6e319fX0sXCJMaXN0T2JqZWN0VmVyc2lvbnNcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT92ZXJzaW9uc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkRlbGltaXRlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJkZWxpbWl0ZXJcIn0sXCJFbmNvZGluZ1R5cGVcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiZW5jb2RpbmctdHlwZVwifSxcIktleU1hcmtlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJrZXktbWFya2VyXCJ9LFwiTWF4S2V5c1wiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJtYXgta2V5c1wiLFwidHlwZVwiOlwiaW50ZWdlclwifSxcIlByZWZpeFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJwcmVmaXhcIn0sXCJWZXJzaW9uSWRNYXJrZXJcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwidmVyc2lvbi1pZC1tYXJrZXJcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklzVHJ1bmNhdGVkXCI6e1widHlwZVwiOlwiYm9vbGVhblwifSxcIktleU1hcmtlclwiOnt9LFwiVmVyc2lvbklkTWFya2VyXCI6e30sXCJOZXh0S2V5TWFya2VyXCI6e30sXCJOZXh0VmVyc2lvbklkTWFya2VyXCI6e30sXCJWZXJzaW9uc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiVmVyc2lvblwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiRVRhZ1wiOnt9LFwiU2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJTdG9yYWdlQ2xhc3NcIjp7fSxcIktleVwiOnt9LFwiVmVyc2lvbklkXCI6e30sXCJJc0xhdGVzdFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJMYXN0TW9kaWZpZWRcIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJPd25lclwiOntcInNoYXBlXCI6XCJTMnVcIn19fSxcImZsYXR0ZW5lZFwiOnRydWV9LFwiRGVsZXRlTWFya2Vyc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiRGVsZXRlTWFya2VyXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJPd25lclwiOntcInNoYXBlXCI6XCJTMnVcIn0sXCJLZXlcIjp7fSxcIlZlcnNpb25JZFwiOnt9LFwiSXNMYXRlc3RcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiTGFzdE1vZGlmaWVkXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9fX0sXCJmbGF0dGVuZWRcIjp0cnVlfSxcIk5hbWVcIjp7fSxcIlByZWZpeFwiOnt9LFwiRGVsaW1pdGVyXCI6e30sXCJNYXhLZXlzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIkNvbW1vblByZWZpeGVzXCI6e1wic2hhcGVcIjpcIlM4clwifSxcIkVuY29kaW5nVHlwZVwiOnt9fX0sXCJhbGlhc1wiOlwiR2V0QnVja2V0T2JqZWN0VmVyc2lvbnNcIn0sXCJMaXN0T2JqZWN0c1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9XCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiRGVsaW1pdGVyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImRlbGltaXRlclwifSxcIkVuY29kaW5nVHlwZVwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJlbmNvZGluZy10eXBlXCJ9LFwiTWFya2VyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcIm1hcmtlclwifSxcIk1heEtleXNcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwibWF4LWtleXNcIixcInR5cGVcIjpcImludGVnZXJcIn0sXCJQcmVmaXhcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwicHJlZml4XCJ9LFwiUmVxdWVzdFBheWVyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJJc1RydW5jYXRlZFwiOntcInR5cGVcIjpcImJvb2xlYW5cIn0sXCJNYXJrZXJcIjp7fSxcIk5leHRNYXJrZXJcIjp7fSxcIkNvbnRlbnRzXCI6e1wic2hhcGVcIjpcIlM5OVwifSxcIk5hbWVcIjp7fSxcIlByZWZpeFwiOnt9LFwiRGVsaW1pdGVyXCI6e30sXCJNYXhLZXlzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIkNvbW1vblByZWZpeGVzXCI6e1wic2hhcGVcIjpcIlM4clwifSxcIkVuY29kaW5nVHlwZVwiOnt9fX0sXCJhbGlhc1wiOlwiR2V0QnVja2V0XCJ9LFwiTGlzdE9iamVjdHNWMlwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIkdFVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2xpc3QtdHlwZT0yXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiRGVsaW1pdGVyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImRlbGltaXRlclwifSxcIkVuY29kaW5nVHlwZVwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJlbmNvZGluZy10eXBlXCJ9LFwiTWF4S2V5c1wiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJtYXgta2V5c1wiLFwidHlwZVwiOlwiaW50ZWdlclwifSxcIlByZWZpeFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJwcmVmaXhcIn0sXCJDb250aW51YXRpb25Ub2tlblwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJjb250aW51YXRpb24tdG9rZW5cIn0sXCJGZXRjaE93bmVyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImZldGNoLW93bmVyXCIsXCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiU3RhcnRBZnRlclwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJzdGFydC1hZnRlclwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifX19LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSXNUcnVuY2F0ZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiQ29udGVudHNcIjp7XCJzaGFwZVwiOlwiUzk5XCJ9LFwiTmFtZVwiOnt9LFwiUHJlZml4XCI6e30sXCJEZWxpbWl0ZXJcIjp7fSxcIk1heEtleXNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiQ29tbW9uUHJlZml4ZXNcIjp7XCJzaGFwZVwiOlwiUzhyXCJ9LFwiRW5jb2RpbmdUeXBlXCI6e30sXCJLZXlDb3VudFwiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJDb250aW51YXRpb25Ub2tlblwiOnt9LFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCI6e30sXCJTdGFydEFmdGVyXCI6e319fX0sXCJMaXN0UGFydHNcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJHRVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fS97S2V5K31cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiLFwiVXBsb2FkSWRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIk1heFBhcnRzXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcIm1heC1wYXJ0c1wiLFwidHlwZVwiOlwiaW50ZWdlclwifSxcIlBhcnROdW1iZXJNYXJrZXJcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwicGFydC1udW1iZXItbWFya2VyXCIsXCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiVXBsb2FkSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwidXBsb2FkSWRcIn0sXCJSZXF1ZXN0UGF5ZXJcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtcGF5ZXJcIn19fSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkFib3J0RGF0ZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotYWJvcnQtZGF0ZVwiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiQWJvcnRSdWxlSWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWFib3J0LXJ1bGUtaWRcIn0sXCJCdWNrZXRcIjp7fSxcIktleVwiOnt9LFwiVXBsb2FkSWRcIjp7fSxcIlBhcnROdW1iZXJNYXJrZXJcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiTmV4dFBhcnROdW1iZXJNYXJrZXJcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiTWF4UGFydHNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiSXNUcnVuY2F0ZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiUGFydHNcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIlBhcnRcIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlBhcnROdW1iZXJcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiTGFzdE1vZGlmaWVkXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiRVRhZ1wiOnt9LFwiU2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn19fSxcImZsYXR0ZW5lZFwiOnRydWV9LFwiSW5pdGlhdG9yXCI6e1wic2hhcGVcIjpcIlM4cVwifSxcIk93bmVyXCI6e1wic2hhcGVcIjpcIlMydVwifSxcIlN0b3JhZ2VDbGFzc1wiOnt9LFwiUmVxdWVzdENoYXJnZWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwifX19fSxcIlB1dEJ1Y2tldEFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/YWNjZWxlcmF0ZVwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwiOntcImxvY2F0aW9uTmFtZVwiOlwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9LFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiU3RhdHVzXCI6e319fX0sXCJwYXlsb2FkXCI6XCJBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwifX0sXCJQdXRCdWNrZXRBY2xcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9hY2xcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQUNMXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1hY2xcIn0sXCJBY2Nlc3NDb250cm9sUG9saWN5XCI6e1wic2hhcGVcIjpcIlM5clwiLFwibG9jYXRpb25OYW1lXCI6XCJBY2Nlc3NDb250cm9sUG9saWN5XCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX0sXCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiR3JhbnRGdWxsQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJ9LFwiR3JhbnRSZWFkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkXCJ9LFwiR3JhbnRSZWFkQUNQXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkLWFjcFwifSxcIkdyYW50V3JpdGVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXdyaXRlXCJ9LFwiR3JhbnRXcml0ZUFDUFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJ9fSxcInBheWxvYWRcIjpcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIn19LFwiUHV0QnVja2V0QW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2FuYWx5dGljc1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiSWRcIixcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJpZFwifSxcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzM2XCIsXCJsb2NhdGlvbk5hbWVcIjpcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9fX0sXCJwYXlsb2FkXCI6XCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCJ9fSxcIlB1dEJ1Y2tldENvcnNcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9jb3JzXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJDT1JTQ29uZmlndXJhdGlvblwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNPUlNDb25maWd1cmF0aW9uXCI6e1wibG9jYXRpb25OYW1lXCI6XCJDT1JTQ29uZmlndXJhdGlvblwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQ09SU1J1bGVzXCJdLFwibWVtYmVyc1wiOntcIkNPUlNSdWxlc1wiOntcInNoYXBlXCI6XCJTM21cIixcImxvY2F0aW9uTmFtZVwiOlwiQ09SU1J1bGVcIn19fSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9fSxcInBheWxvYWRcIjpcIkNPUlNDb25maWd1cmF0aW9uXCJ9fSxcIlB1dEJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9pbnZlbnRvcnlcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIklkXCIsXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwiaWRcIn0sXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6e1wic2hhcGVcIjpcIlMzelwiLFwibG9jYXRpb25OYW1lXCI6XCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX19LFwicGF5bG9hZFwiOlwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwifX0sXCJQdXRCdWNrZXRMaWZlY3ljbGVcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9saWZlY3ljbGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJDb250ZW50TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJDb250ZW50LU1ENVwifSxcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9LFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlJ1bGVzXCJdLFwibWVtYmVyc1wiOntcIlJ1bGVzXCI6e1wic2hhcGVcIjpcIlM0Y1wiLFwibG9jYXRpb25OYW1lXCI6XCJSdWxlXCJ9fX19LFwicGF5bG9hZFwiOlwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwifSxcImRlcHJlY2F0ZWRcIjp0cnVlfSxcIlB1dEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9saWZlY3ljbGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6e1wibG9jYXRpb25OYW1lXCI6XCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifSxcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJSdWxlc1wiXSxcIm1lbWJlcnNcIjp7XCJSdWxlc1wiOntcInNoYXBlXCI6XCJTNHJcIixcImxvY2F0aW9uTmFtZVwiOlwiUnVsZVwifX19fSxcInBheWxvYWRcIjpcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIn19LFwiUHV0QnVja2V0TG9nZ2luZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P2xvZ2dpbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCI6e1wibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRMb2dnaW5nU3RhdHVzXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifSxcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkxvZ2dpbmdFbmFibGVkXCI6e1wic2hhcGVcIjpcIlM1MVwifX19LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn19LFwicGF5bG9hZFwiOlwiQnVja2V0TG9nZ2luZ1N0YXR1c1wifX0sXCJQdXRCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvblwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P21ldHJpY3NcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIklkXCIsXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcImlkXCJ9LFwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzU5XCIsXCJsb2NhdGlvbk5hbWVcIjpcIk1ldHJpY3NDb25maWd1cmF0aW9uXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX19LFwicGF5bG9hZFwiOlwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIn19LFwiUHV0QnVja2V0Tm90aWZpY2F0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/bm90aWZpY2F0aW9uXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn0sXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6e1wic2hhcGVcIjpcIlM1ZFwiLFwibG9jYXRpb25OYW1lXCI6XCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX19LFwicGF5bG9hZFwiOlwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwifSxcImRlcHJlY2F0ZWRcIjp0cnVlfSxcIlB1dEJ1Y2tldE5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9ub3RpZmljYXRpb25cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6e1wic2hhcGVcIjpcIlM1b1wiLFwibG9jYXRpb25OYW1lXCI6XCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX19LFwicGF5bG9hZFwiOlwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwifX0sXCJQdXRCdWNrZXRQb2xpY3lcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9wb2xpY3lcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIlBvbGljeVwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiUG9saWN5XCI6e319LFwicGF5bG9hZFwiOlwiUG9saWN5XCJ9fSxcIlB1dEJ1Y2tldFJlcGxpY2F0aW9uXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/cmVwbGljYXRpb25cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCI6e1wic2hhcGVcIjpcIlM2N1wiLFwibG9jYXRpb25OYW1lXCI6XCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9fX0sXCJwYXlsb2FkXCI6XCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIn19LFwiUHV0QnVja2V0UmVxdWVzdFBheW1lbnRcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fT9yZXF1ZXN0UGF5bWVudFwifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn0sXCJSZXF1ZXN0UGF5bWVudENvbmZpZ3VyYXRpb25cIjp7XCJsb2NhdGlvbk5hbWVcIjpcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiUGF5ZXJcIl0sXCJtZW1iZXJzXCI6e1wiUGF5ZXJcIjp7fX19fSxcInBheWxvYWRcIjpcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwifX0sXCJQdXRCdWNrZXRUYWdnaW5nXCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0/dGFnZ2luZ1wifSxcImlucHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiLFwiVGFnZ2luZ1wiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiVGFnZ2luZ1wiOntcInNoYXBlXCI6XCJTYWJcIixcImxvY2F0aW9uTmFtZVwiOlwiVGFnZ2luZ1wiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn19fSxcInBheWxvYWRcIjpcIlRhZ2dpbmdcIn19LFwiUHV0QnVja2V0VmVyc2lvbmluZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3ZlcnNpb25pbmdcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIlZlcnNpb25pbmdDb25maWd1cmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn0sXCJNRkFcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LW1mYVwifSxcIlZlcnNpb25pbmdDb25maWd1cmF0aW9uXCI6e1wibG9jYXRpb25OYW1lXCI6XCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJNRkFEZWxldGVcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIk1mYURlbGV0ZVwifSxcIlN0YXR1c1wiOnt9fX19LFwicGF5bG9hZFwiOlwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIn19LFwiUHV0QnVja2V0V2Vic2l0ZVwiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9P3dlYnNpdGVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIldlYnNpdGVDb25maWd1cmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn0sXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiOntcImxvY2F0aW9uTmFtZVwiOlwiV2Vic2l0ZUNvbmZpZ3VyYXRpb25cIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9LFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiRXJyb3JEb2N1bWVudFwiOntcInNoYXBlXCI6XCJTNnRcIn0sXCJJbmRleERvY3VtZW50XCI6e1wic2hhcGVcIjpcIlM2clwifSxcIlJlZGlyZWN0QWxsUmVxdWVzdHNUb1wiOntcInNoYXBlXCI6XCJTNm9cIn0sXCJSb3V0aW5nUnVsZXNcIjp7XCJzaGFwZVwiOlwiUzZ1XCJ9fX19LFwicGF5bG9hZFwiOlwiV2Vic2l0ZUNvbmZpZ3VyYXRpb25cIn19LFwiUHV0T2JqZWN0XCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0ve0tleSt9XCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJLZXlcIl0sXCJtZW1iZXJzXCI6e1wiQUNMXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1hY2xcIn0sXCJCb2R5XCI6e1wic3RyZWFtaW5nXCI6dHJ1ZSxcInR5cGVcIjpcImJsb2JcIn0sXCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNhY2hlQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ2FjaGUtQ29udHJvbFwifSxcIkNvbnRlbnREaXNwb3NpdGlvblwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1EaXNwb3NpdGlvblwifSxcIkNvbnRlbnRFbmNvZGluZ1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1FbmNvZGluZ1wifSxcIkNvbnRlbnRMYW5ndWFnZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1MYW5ndWFnZVwifSxcIkNvbnRlbnRMZW5ndGhcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTGVuZ3RoXCIsXCJ0eXBlXCI6XCJsb25nXCJ9LFwiQ29udGVudE1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1NRDVcIn0sXCJDb250ZW50VHlwZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiQ29udGVudC1UeXBlXCJ9LFwiRXhwaXJlc1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiRXhwaXJlc1wiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiR3JhbnRGdWxsQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJ9LFwiR3JhbnRSZWFkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkXCJ9LFwiR3JhbnRSZWFkQUNQXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkLWFjcFwifSxcIkdyYW50V3JpdGVBQ1BcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXdyaXRlLWFjcFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiTWV0YWRhdGFcIjp7XCJzaGFwZVwiOlwiUzExXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyc1wiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1tZXRhLVwifSxcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiU3RvcmFnZUNsYXNzXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJ9LFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleVwiOntcInNoYXBlXCI6XCJTMTlcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiU1NFS01TS2V5SWRcIjp7XCJzaGFwZVwiOlwiU2pcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwifSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifSxcIlRhZ2dpbmdcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXRhZ2dpbmdcIn19LFwicGF5bG9hZFwiOlwiQm9keVwifSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkV4cGlyYXRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWV4cGlyYXRpb25cIn0sXCJFVGFnXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJFVGFnXCJ9LFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIn0sXCJWZXJzaW9uSWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXZlcnNpb24taWRcIn0sXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIn0sXCJTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiU1NFS01TS2V5SWRcIjp7XCJzaGFwZVwiOlwiU2pcIixcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwifSxcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn19fX0sXCJQdXRPYmplY3RBY2xcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fS97S2V5K30/YWNsXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJLZXlcIl0sXCJtZW1iZXJzXCI6e1wiQUNMXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1hY2xcIn0sXCJBY2Nlc3NDb250cm9sUG9saWN5XCI6e1wic2hhcGVcIjpcIlM5clwiLFwibG9jYXRpb25OYW1lXCI6XCJBY2Nlc3NDb250cm9sUG9saWN5XCIsXCJ4bWxOYW1lc3BhY2VcIjp7XCJ1cmlcIjpcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wifX0sXCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiR3JhbnRGdWxsQ29udHJvbFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJ9LFwiR3JhbnRSZWFkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkXCJ9LFwiR3JhbnRSZWFkQUNQXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1ncmFudC1yZWFkLWFjcFwifSxcIkdyYW50V3JpdGVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWdyYW50LXdyaXRlXCJ9LFwiR3JhbnRXcml0ZUFDUFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJ9LFwiS2V5XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJLZXlcIn0sXCJSZXF1ZXN0UGF5ZXJcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtcGF5ZXJcIn0sXCJWZXJzaW9uSWRcIjp7XCJsb2NhdGlvblwiOlwicXVlcnlzdHJpbmdcIixcImxvY2F0aW9uTmFtZVwiOlwidmVyc2lvbklkXCJ9fSxcInBheWxvYWRcIjpcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIn0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJSZXF1ZXN0Q2hhcmdlZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJ9fX19LFwiUHV0T2JqZWN0VGFnZ2luZ1wiOntcImh0dHBcIjp7XCJtZXRob2RcIjpcIlBVVFwiLFwicmVxdWVzdFVyaVwiOlwiL3tCdWNrZXR9L3tLZXkrfT90YWdnaW5nXCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJLZXlcIixcIlRhZ2dpbmdcIl0sXCJtZW1iZXJzXCI6e1wiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJLZXlcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIktleVwifSxcIlZlcnNpb25JZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ2ZXJzaW9uSWRcIn0sXCJDb250ZW50TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJDb250ZW50LU1ENVwifSxcIlRhZ2dpbmdcIjp7XCJzaGFwZVwiOlwiU2FiXCIsXCJsb2NhdGlvbk5hbWVcIjpcIlRhZ2dpbmdcIixcInhtbE5hbWVzcGFjZVwiOntcInVyaVwiOlwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJ9fX0sXCJwYXlsb2FkXCI6XCJUYWdnaW5nXCJ9LFwib3V0cHV0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei12ZXJzaW9uLWlkXCJ9fX19LFwiUmVzdG9yZU9iamVjdFwiOntcImh0dHBcIjp7XCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0ve0tleSt9P3Jlc3RvcmVcIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifSxcIktleVwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiS2V5XCJ9LFwiVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInZlcnNpb25JZFwifSxcIlJlc3RvcmVSZXF1ZXN0XCI6e1wibG9jYXRpb25OYW1lXCI6XCJSZXN0b3JlUmVxdWVzdFwiLFwieG1sTmFtZXNwYWNlXCI6e1widXJpXCI6XCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIn0sXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiRGF5c1wiXSxcIm1lbWJlcnNcIjp7XCJEYXlzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIkdsYWNpZXJKb2JQYXJhbWV0ZXJzXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlRpZXJcIl0sXCJtZW1iZXJzXCI6e1wiVGllclwiOnt9fX19fSxcIlJlcXVlc3RQYXllclwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1wYXllclwifX0sXCJwYXlsb2FkXCI6XCJSZXN0b3JlUmVxdWVzdFwifSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlJlcXVlc3RDaGFyZ2VkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIn19fSxcImFsaWFzXCI6XCJQb3N0T2JqZWN0UmVzdG9yZVwifSxcIlVwbG9hZFBhcnRcIjp7XCJodHRwXCI6e1wibWV0aG9kXCI6XCJQVVRcIixcInJlcXVlc3RVcmlcIjpcIi97QnVja2V0fS97S2V5K31cIn0sXCJpbnB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIktleVwiLFwiUGFydE51bWJlclwiLFwiVXBsb2FkSWRcIl0sXCJtZW1iZXJzXCI6e1wiQm9keVwiOntcInN0cmVhbWluZ1wiOnRydWUsXCJ0eXBlXCI6XCJibG9iXCJ9LFwiQnVja2V0XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJCdWNrZXRcIn0sXCJDb250ZW50TGVuZ3RoXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJDb250ZW50LUxlbmd0aFwiLFwidHlwZVwiOlwibG9uZ1wifSxcIkNvbnRlbnRNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkNvbnRlbnQtTUQ1XCJ9LFwiS2V5XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJLZXlcIn0sXCJQYXJ0TnVtYmVyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInBhcnROdW1iZXJcIixcInR5cGVcIjpcImludGVnZXJcIn0sXCJVcGxvYWRJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ1cGxvYWRJZFwifSxcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIlNTRUN1c3RvbWVyS2V5XCI6e1wic2hhcGVcIjpcIlMxOVwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwifSxcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIn0sXCJSZXF1ZXN0UGF5ZXJcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtcGF5ZXJcIn19LFwicGF5bG9hZFwiOlwiQm9keVwifSxcIm91dHB1dFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiRVRhZ1wiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwiRVRhZ1wifSxcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIn0sXCJTU0VLTVNLZXlJZFwiOntcInNoYXBlXCI6XCJTalwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJ9LFwiUmVxdWVzdENoYXJnZWRcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwifX19fSxcIlVwbG9hZFBhcnRDb3B5XCI6e1wiaHR0cFwiOntcIm1ldGhvZFwiOlwiUFVUXCIsXCJyZXF1ZXN0VXJpXCI6XCIve0J1Y2tldH0ve0tleSt9XCJ9LFwiaW5wdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCIsXCJDb3B5U291cmNlXCIsXCJLZXlcIixcIlBhcnROdW1iZXJcIixcIlVwbG9hZElkXCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOntcImxvY2F0aW9uXCI6XCJ1cmlcIixcImxvY2F0aW9uTmFtZVwiOlwiQnVja2V0XCJ9LFwiQ29weVNvdXJjZVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2VcIn0sXCJDb3B5U291cmNlSWZNYXRjaFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2UtaWYtbWF0Y2hcIn0sXCJDb3B5U291cmNlSWZNb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFwidHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiQ29weVNvdXJjZUlmTm9uZU1hdGNoXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1ub25lLW1hdGNoXCJ9LFwiQ29weVNvdXJjZUlmVW5tb2RpZmllZFNpbmNlXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1pZi11bm1vZGlmaWVkLXNpbmNlXCIsXCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn0sXCJDb3B5U291cmNlUmFuZ2VcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWNvcHktc291cmNlLXJhbmdlXCJ9LFwiS2V5XCI6e1wibG9jYXRpb25cIjpcInVyaVwiLFwibG9jYXRpb25OYW1lXCI6XCJLZXlcIn0sXCJQYXJ0TnVtYmVyXCI6e1wibG9jYXRpb25cIjpcInF1ZXJ5c3RyaW5nXCIsXCJsb2NhdGlvbk5hbWVcIjpcInBhcnROdW1iZXJcIixcInR5cGVcIjpcImludGVnZXJcIn0sXCJVcGxvYWRJZFwiOntcImxvY2F0aW9uXCI6XCJxdWVyeXN0cmluZ1wiLFwibG9jYXRpb25OYW1lXCI6XCJ1cGxvYWRJZFwifSxcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwifSxcIlNTRUN1c3RvbWVyS2V5XCI6e1wic2hhcGVcIjpcIlMxOVwiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwifSxcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIn0sXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJ9LFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5XCI6e1wic2hhcGVcIjpcIlMxY1wiLFwibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwifSxcIkNvcHlTb3VyY2VTU0VDdXN0b21lcktleU1ENVwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJ9LFwiUmVxdWVzdFBheWVyXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJ9fX0sXCJvdXRwdXRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJDb3B5U291cmNlVmVyc2lvbklkXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1jb3B5LXNvdXJjZS12ZXJzaW9uLWlkXCJ9LFwiQ29weVBhcnRSZXN1bHRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJFVGFnXCI6e30sXCJMYXN0TW9kaWZpZWRcIjp7XCJ0eXBlXCI6XCJ0aW1lc3RhbXBcIn19fSxcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6e1wibG9jYXRpb25cIjpcImhlYWRlclwiLFwibG9jYXRpb25OYW1lXCI6XCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJ9LFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJ9LFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjp7XCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwifSxcIlNTRUtNU0tleUlkXCI6e1wic2hhcGVcIjpcIlNqXCIsXCJsb2NhdGlvblwiOlwiaGVhZGVyXCIsXCJsb2NhdGlvbk5hbWVcIjpcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIn0sXCJSZXF1ZXN0Q2hhcmdlZFwiOntcImxvY2F0aW9uXCI6XCJoZWFkZXJcIixcImxvY2F0aW9uTmFtZVwiOlwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJ9fSxcInBheWxvYWRcIjpcIkNvcHlQYXJ0UmVzdWx0XCJ9fX0sXCJzaGFwZXNcIjp7XCJTalwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwic2Vuc2l0aXZlXCI6dHJ1ZX0sXCJTMTFcIjp7XCJ0eXBlXCI6XCJtYXBcIixcImtleVwiOnt9LFwidmFsdWVcIjp7fX0sXCJTMTlcIjp7XCJ0eXBlXCI6XCJibG9iXCIsXCJzZW5zaXRpdmVcIjp0cnVlfSxcIlMxY1wiOntcInR5cGVcIjpcImJsb2JcIixcInNlbnNpdGl2ZVwiOnRydWV9LFwiUzJ1XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiRGlzcGxheU5hbWVcIjp7fSxcIklEXCI6e319fSxcIlMyeFwiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcImxvY2F0aW9uTmFtZVwiOlwiR3JhbnRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkdyYW50ZWVcIjp7XCJzaGFwZVwiOlwiUzJ6XCJ9LFwiUGVybWlzc2lvblwiOnt9fX19LFwiUzJ6XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlR5cGVcIl0sXCJtZW1iZXJzXCI6e1wiRGlzcGxheU5hbWVcIjp7fSxcIkVtYWlsQWRkcmVzc1wiOnt9LFwiSURcIjp7fSxcIlR5cGVcIjp7XCJsb2NhdGlvbk5hbWVcIjpcInhzaTp0eXBlXCIsXCJ4bWxBdHRyaWJ1dGVcIjp0cnVlfSxcIlVSSVwiOnt9fSxcInhtbE5hbWVzcGFjZVwiOntcInByZWZpeFwiOlwieHNpXCIsXCJ1cmlcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXCJ9fSxcIlMzNlwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZFwiLFwiU3RvcmFnZUNsYXNzQW5hbHlzaXNcIl0sXCJtZW1iZXJzXCI6e1wiSWRcIjp7fSxcIkZpbHRlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlByZWZpeFwiOnt9LFwiVGFnXCI6e1wic2hhcGVcIjpcIlMzOVwifSxcIkFuZFwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlByZWZpeFwiOnt9LFwiVGFnc1wiOntcInNoYXBlXCI6XCJTM2NcIixcImZsYXR0ZW5lZFwiOnRydWUsXCJsb2NhdGlvbk5hbWVcIjpcIlRhZ1wifX19fX0sXCJTdG9yYWdlQ2xhc3NBbmFseXNpc1wiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkRhdGFFeHBvcnRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiT3V0cHV0U2NoZW1hVmVyc2lvblwiLFwiRGVzdGluYXRpb25cIl0sXCJtZW1iZXJzXCI6e1wiT3V0cHV0U2NoZW1hVmVyc2lvblwiOnt9LFwiRGVzdGluYXRpb25cIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiUzNCdWNrZXREZXN0aW5hdGlvblwiXSxcIm1lbWJlcnNcIjp7XCJTM0J1Y2tldERlc3RpbmF0aW9uXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkZvcm1hdFwiLFwiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkZvcm1hdFwiOnt9LFwiQnVja2V0QWNjb3VudElkXCI6e30sXCJCdWNrZXRcIjp7fSxcIlByZWZpeFwiOnt9fX19fX19fX19fSxcIlMzOVwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJLZXlcIixcIlZhbHVlXCJdLFwibWVtYmVyc1wiOntcIktleVwiOnt9LFwiVmFsdWVcIjp7fX19LFwiUzNjXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1wic2hhcGVcIjpcIlMzOVwiLFwibG9jYXRpb25OYW1lXCI6XCJUYWdcIn19LFwiUzNtXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkFsbG93ZWRNZXRob2RzXCIsXCJBbGxvd2VkT3JpZ2luc1wiXSxcIm1lbWJlcnNcIjp7XCJBbGxvd2VkSGVhZGVyc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiQWxsb3dlZEhlYWRlclwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e30sXCJmbGF0dGVuZWRcIjp0cnVlfSxcIkFsbG93ZWRNZXRob2RzXCI6e1wibG9jYXRpb25OYW1lXCI6XCJBbGxvd2VkTWV0aG9kXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7fSxcImZsYXR0ZW5lZFwiOnRydWV9LFwiQWxsb3dlZE9yaWdpbnNcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIkFsbG93ZWRPcmlnaW5cIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOnt9LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJFeHBvc2VIZWFkZXJzXCI6e1wibG9jYXRpb25OYW1lXCI6XCJFeHBvc2VIZWFkZXJcIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOnt9LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJNYXhBZ2VTZWNvbmRzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJTM3pcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiRGVzdGluYXRpb25cIixcIklzRW5hYmxlZFwiLFwiSWRcIixcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIixcIlNjaGVkdWxlXCJdLFwibWVtYmVyc1wiOntcIkRlc3RpbmF0aW9uXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlMzQnVja2V0RGVzdGluYXRpb25cIl0sXCJtZW1iZXJzXCI6e1wiUzNCdWNrZXREZXN0aW5hdGlvblwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJCdWNrZXRcIixcIkZvcm1hdFwiXSxcIm1lbWJlcnNcIjp7XCJBY2NvdW50SWRcIjp7fSxcIkJ1Y2tldFwiOnt9LFwiRm9ybWF0XCI6e30sXCJQcmVmaXhcIjp7fX19fX0sXCJJc0VuYWJsZWRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCJ9LFwiRmlsdGVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlByZWZpeFwiXSxcIm1lbWJlcnNcIjp7XCJQcmVmaXhcIjp7fX19LFwiSWRcIjp7fSxcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIjp7fSxcIk9wdGlvbmFsRmllbGRzXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1wibG9jYXRpb25OYW1lXCI6XCJGaWVsZFwifX0sXCJTY2hlZHVsZVwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJGcmVxdWVuY3lcIl0sXCJtZW1iZXJzXCI6e1wiRnJlcXVlbmN5XCI6e319fX19LFwiUzRjXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlByZWZpeFwiLFwiU3RhdHVzXCJdLFwibWVtYmVyc1wiOntcIkV4cGlyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzRlXCJ9LFwiSURcIjp7fSxcIlByZWZpeFwiOnt9LFwiU3RhdHVzXCI6e30sXCJUcmFuc2l0aW9uXCI6e1wic2hhcGVcIjpcIlM0alwifSxcIk5vbmN1cnJlbnRWZXJzaW9uVHJhbnNpdGlvblwiOntcInNoYXBlXCI6XCJTNGxcIn0sXCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzRtXCJ9LFwiQWJvcnRJbmNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCI6e1wic2hhcGVcIjpcIlM0blwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJTNGVcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJEYXRlXCI6e1wic2hhcGVcIjpcIlM0ZlwifSxcIkRheXNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9LFwiRXhwaXJlZE9iamVjdERlbGV0ZU1hcmtlclwiOntcInR5cGVcIjpcImJvb2xlYW5cIn19fSxcIlM0ZlwiOntcInR5cGVcIjpcInRpbWVzdGFtcFwiLFwidGltZXN0YW1wRm9ybWF0XCI6XCJpc284NjAxXCJ9LFwiUzRqXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiRGF0ZVwiOntcInNoYXBlXCI6XCJTNGZcIn0sXCJEYXlzXCI6e1widHlwZVwiOlwiaW50ZWdlclwifSxcIlN0b3JhZ2VDbGFzc1wiOnt9fX0sXCJTNGxcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJOb25jdXJyZW50RGF5c1wiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJTdG9yYWdlQ2xhc3NcIjp7fX19LFwiUzRtXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTm9uY3VycmVudERheXNcIjp7XCJ0eXBlXCI6XCJpbnRlZ2VyXCJ9fX0sXCJTNG5cIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJEYXlzQWZ0ZXJJbml0aWF0aW9uXCI6e1widHlwZVwiOlwiaW50ZWdlclwifX19LFwiUzRyXCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlN0YXR1c1wiXSxcIm1lbWJlcnNcIjp7XCJFeHBpcmF0aW9uXCI6e1wic2hhcGVcIjpcIlM0ZVwifSxcIklEXCI6e30sXCJQcmVmaXhcIjp7XCJkZXByZWNhdGVkXCI6dHJ1ZX0sXCJGaWx0ZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJQcmVmaXhcIjp7fSxcIlRhZ1wiOntcInNoYXBlXCI6XCJTMzlcIn0sXCJBbmRcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJQcmVmaXhcIjp7fSxcIlRhZ3NcIjp7XCJzaGFwZVwiOlwiUzNjXCIsXCJmbGF0dGVuZWRcIjp0cnVlLFwibG9jYXRpb25OYW1lXCI6XCJUYWdcIn19fX19LFwiU3RhdHVzXCI6e30sXCJUcmFuc2l0aW9uc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiVHJhbnNpdGlvblwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1wic2hhcGVcIjpcIlM0alwifSxcImZsYXR0ZW5lZFwiOnRydWV9LFwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJzaGFwZVwiOlwiUzRsXCJ9LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb25cIjp7XCJzaGFwZVwiOlwiUzRtXCJ9LFwiQWJvcnRJbmNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCI6e1wic2hhcGVcIjpcIlM0blwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJTNTFcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJUYXJnZXRCdWNrZXRcIjp7fSxcIlRhcmdldEdyYW50c1wiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcImxvY2F0aW9uTmFtZVwiOlwiR3JhbnRcIixcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkdyYW50ZWVcIjp7XCJzaGFwZVwiOlwiUzJ6XCJ9LFwiUGVybWlzc2lvblwiOnt9fX19LFwiVGFyZ2V0UHJlZml4XCI6e319fSxcIlM1OVwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJJZFwiXSxcIm1lbWJlcnNcIjp7XCJJZFwiOnt9LFwiRmlsdGVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiUHJlZml4XCI6e30sXCJUYWdcIjp7XCJzaGFwZVwiOlwiUzM5XCJ9LFwiQW5kXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiUHJlZml4XCI6e30sXCJUYWdzXCI6e1wic2hhcGVcIjpcIlMzY1wiLFwiZmxhdHRlbmVkXCI6dHJ1ZSxcImxvY2F0aW9uTmFtZVwiOlwiVGFnXCJ9fX19fX19LFwiUzVjXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkJ1Y2tldFwiXSxcIm1lbWJlcnNcIjp7XCJCdWNrZXRcIjp7XCJsb2NhdGlvblwiOlwidXJpXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkJ1Y2tldFwifX19LFwiUzVkXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiVG9waWNDb25maWd1cmF0aW9uXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSWRcIjp7fSxcIkV2ZW50c1wiOntcInNoYXBlXCI6XCJTNWdcIixcImxvY2F0aW9uTmFtZVwiOlwiRXZlbnRcIn0sXCJFdmVudFwiOntcImRlcHJlY2F0ZWRcIjp0cnVlfSxcIlRvcGljXCI6e319fSxcIlF1ZXVlQ29uZmlndXJhdGlvblwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkXCI6e30sXCJFdmVudFwiOntcImRlcHJlY2F0ZWRcIjp0cnVlfSxcIkV2ZW50c1wiOntcInNoYXBlXCI6XCJTNWdcIixcImxvY2F0aW9uTmFtZVwiOlwiRXZlbnRcIn0sXCJRdWV1ZVwiOnt9fX0sXCJDbG91ZEZ1bmN0aW9uQ29uZmlndXJhdGlvblwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIklkXCI6e30sXCJFdmVudFwiOntcImRlcHJlY2F0ZWRcIjp0cnVlfSxcIkV2ZW50c1wiOntcInNoYXBlXCI6XCJTNWdcIixcImxvY2F0aW9uTmFtZVwiOlwiRXZlbnRcIn0sXCJDbG91ZEZ1bmN0aW9uXCI6e30sXCJJbnZvY2F0aW9uUm9sZVwiOnt9fX19fSxcIlM1Z1wiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOnt9LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJTNW9cIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJUb3BpY0NvbmZpZ3VyYXRpb25zXCI6e1wibG9jYXRpb25OYW1lXCI6XCJUb3BpY0NvbmZpZ3VyYXRpb25cIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJUb3BpY0FyblwiLFwiRXZlbnRzXCJdLFwibWVtYmVyc1wiOntcIklkXCI6e30sXCJUb3BpY0FyblwiOntcImxvY2F0aW9uTmFtZVwiOlwiVG9waWNcIn0sXCJFdmVudHNcIjp7XCJzaGFwZVwiOlwiUzVnXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkV2ZW50XCJ9LFwiRmlsdGVyXCI6e1wic2hhcGVcIjpcIlM1clwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJRdWV1ZUNvbmZpZ3VyYXRpb25zXCI6e1wibG9jYXRpb25OYW1lXCI6XCJRdWV1ZUNvbmZpZ3VyYXRpb25cIixcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJRdWV1ZUFyblwiLFwiRXZlbnRzXCJdLFwibWVtYmVyc1wiOntcIklkXCI6e30sXCJRdWV1ZUFyblwiOntcImxvY2F0aW9uTmFtZVwiOlwiUXVldWVcIn0sXCJFdmVudHNcIjp7XCJzaGFwZVwiOlwiUzVnXCIsXCJsb2NhdGlvbk5hbWVcIjpcIkV2ZW50XCJ9LFwiRmlsdGVyXCI6e1wic2hhcGVcIjpcIlM1clwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJMYW1iZGFGdW5jdGlvbkNvbmZpZ3VyYXRpb25zXCI6e1wibG9jYXRpb25OYW1lXCI6XCJDbG91ZEZ1bmN0aW9uQ29uZmlndXJhdGlvblwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIkxhbWJkYUZ1bmN0aW9uQXJuXCIsXCJFdmVudHNcIl0sXCJtZW1iZXJzXCI6e1wiSWRcIjp7fSxcIkxhbWJkYUZ1bmN0aW9uQXJuXCI6e1wibG9jYXRpb25OYW1lXCI6XCJDbG91ZEZ1bmN0aW9uXCJ9LFwiRXZlbnRzXCI6e1wic2hhcGVcIjpcIlM1Z1wiLFwibG9jYXRpb25OYW1lXCI6XCJFdmVudFwifSxcIkZpbHRlclwiOntcInNoYXBlXCI6XCJTNXJcIn19fSxcImZsYXR0ZW5lZFwiOnRydWV9fX0sXCJTNXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJLZXlcIjp7XCJsb2NhdGlvbk5hbWVcIjpcIlMzS2V5XCIsXCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJGaWx0ZXJSdWxlc1wiOntcImxvY2F0aW9uTmFtZVwiOlwiRmlsdGVyUnVsZVwiLFwidHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiTmFtZVwiOnt9LFwiVmFsdWVcIjp7fX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX19fX19LFwiUzY3XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlJvbGVcIixcIlJ1bGVzXCJdLFwibWVtYmVyc1wiOntcIlJvbGVcIjp7fSxcIlJ1bGVzXCI6e1wibG9jYXRpb25OYW1lXCI6XCJSdWxlXCIsXCJ0eXBlXCI6XCJsaXN0XCIsXCJtZW1iZXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiUHJlZml4XCIsXCJTdGF0dXNcIixcIkRlc3RpbmF0aW9uXCJdLFwibWVtYmVyc1wiOntcIklEXCI6e30sXCJQcmVmaXhcIjp7fSxcIlN0YXR1c1wiOnt9LFwiRGVzdGluYXRpb25cIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiQnVja2V0XCJdLFwibWVtYmVyc1wiOntcIkJ1Y2tldFwiOnt9LFwiU3RvcmFnZUNsYXNzXCI6e319fX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX19fSxcIlM2b1wiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwicmVxdWlyZWRcIjpbXCJIb3N0TmFtZVwiXSxcIm1lbWJlcnNcIjp7XCJIb3N0TmFtZVwiOnt9LFwiUHJvdG9jb2xcIjp7fX19LFwiUzZyXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlN1ZmZpeFwiXSxcIm1lbWJlcnNcIjp7XCJTdWZmaXhcIjp7fX19LFwiUzZ0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIktleVwiXSxcIm1lbWJlcnNcIjp7XCJLZXlcIjp7fX19LFwiUzZ1XCI6e1widHlwZVwiOlwibGlzdFwiLFwibWVtYmVyXCI6e1wibG9jYXRpb25OYW1lXCI6XCJSb3V0aW5nUnVsZVwiLFwidHlwZVwiOlwic3RydWN0dXJlXCIsXCJyZXF1aXJlZFwiOltcIlJlZGlyZWN0XCJdLFwibWVtYmVyc1wiOntcIkNvbmRpdGlvblwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIkh0dHBFcnJvckNvZGVSZXR1cm5lZEVxdWFsc1wiOnt9LFwiS2V5UHJlZml4RXF1YWxzXCI6e319fSxcIlJlZGlyZWN0XCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSG9zdE5hbWVcIjp7fSxcIkh0dHBSZWRpcmVjdENvZGVcIjp7fSxcIlByb3RvY29sXCI6e30sXCJSZXBsYWNlS2V5UHJlZml4V2l0aFwiOnt9LFwiUmVwbGFjZUtleVdpdGhcIjp7fX19fX19LFwiUzhxXCI6e1widHlwZVwiOlwic3RydWN0dXJlXCIsXCJtZW1iZXJzXCI6e1wiSURcIjp7fSxcIkRpc3BsYXlOYW1lXCI6e319fSxcIlM4clwiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIlByZWZpeFwiOnt9fX0sXCJmbGF0dGVuZWRcIjp0cnVlfSxcIlM5OVwiOntcInR5cGVcIjpcImxpc3RcIixcIm1lbWJlclwiOntcInR5cGVcIjpcInN0cnVjdHVyZVwiLFwibWVtYmVyc1wiOntcIktleVwiOnt9LFwiTGFzdE1vZGlmaWVkXCI6e1widHlwZVwiOlwidGltZXN0YW1wXCJ9LFwiRVRhZ1wiOnt9LFwiU2l6ZVwiOntcInR5cGVcIjpcImludGVnZXJcIn0sXCJTdG9yYWdlQ2xhc3NcIjp7fSxcIk93bmVyXCI6e1wic2hhcGVcIjpcIlMydVwifX19LFwiZmxhdHRlbmVkXCI6dHJ1ZX0sXCJTOXJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcIm1lbWJlcnNcIjp7XCJHcmFudHNcIjp7XCJzaGFwZVwiOlwiUzJ4XCIsXCJsb2NhdGlvbk5hbWVcIjpcIkFjY2Vzc0NvbnRyb2xMaXN0XCJ9LFwiT3duZXJcIjp7XCJzaGFwZVwiOlwiUzJ1XCJ9fX0sXCJTYWJcIjp7XCJ0eXBlXCI6XCJzdHJ1Y3R1cmVcIixcInJlcXVpcmVkXCI6W1wiVGFnU2V0XCJdLFwibWVtYmVyc1wiOntcIlRhZ1NldFwiOntcInNoYXBlXCI6XCJTM2NcIn19fX19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEubWluLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1wicGFnaW5hdGlvblwiOntcIkxpc3RCdWNrZXRzXCI6e1wicmVzdWx0X2tleVwiOlwiQnVja2V0c1wifSxcIkxpc3RNdWx0aXBhcnRVcGxvYWRzXCI6e1wiaW5wdXRfdG9rZW5cIjpbXCJLZXlNYXJrZXJcIixcIlVwbG9hZElkTWFya2VyXCJdLFwibGltaXRfa2V5XCI6XCJNYXhVcGxvYWRzXCIsXCJtb3JlX3Jlc3VsdHNcIjpcIklzVHJ1bmNhdGVkXCIsXCJvdXRwdXRfdG9rZW5cIjpbXCJOZXh0S2V5TWFya2VyXCIsXCJOZXh0VXBsb2FkSWRNYXJrZXJcIl0sXCJyZXN1bHRfa2V5XCI6W1wiVXBsb2Fkc1wiLFwiQ29tbW9uUHJlZml4ZXNcIl19LFwiTGlzdE9iamVjdFZlcnNpb25zXCI6e1wiaW5wdXRfdG9rZW5cIjpbXCJLZXlNYXJrZXJcIixcIlZlcnNpb25JZE1hcmtlclwiXSxcImxpbWl0X2tleVwiOlwiTWF4S2V5c1wiLFwibW9yZV9yZXN1bHRzXCI6XCJJc1RydW5jYXRlZFwiLFwib3V0cHV0X3Rva2VuXCI6W1wiTmV4dEtleU1hcmtlclwiLFwiTmV4dFZlcnNpb25JZE1hcmtlclwiXSxcInJlc3VsdF9rZXlcIjpbXCJWZXJzaW9uc1wiLFwiRGVsZXRlTWFya2Vyc1wiLFwiQ29tbW9uUHJlZml4ZXNcIl19LFwiTGlzdE9iamVjdHNcIjp7XCJpbnB1dF90b2tlblwiOlwiTWFya2VyXCIsXCJsaW1pdF9rZXlcIjpcIk1heEtleXNcIixcIm1vcmVfcmVzdWx0c1wiOlwiSXNUcnVuY2F0ZWRcIixcIm91dHB1dF90b2tlblwiOlwiTmV4dE1hcmtlciB8fCBDb250ZW50c1stMV0uS2V5XCIsXCJyZXN1bHRfa2V5XCI6W1wiQ29udGVudHNcIixcIkNvbW1vblByZWZpeGVzXCJdfSxcIkxpc3RPYmplY3RzVjJcIjp7XCJpbnB1dF90b2tlblwiOlwiQ29udGludWF0aW9uVG9rZW5cIixcImxpbWl0X2tleVwiOlwiTWF4S2V5c1wiLFwib3V0cHV0X3Rva2VuXCI6XCJOZXh0Q29udGludWF0aW9uVG9rZW5cIixcInJlc3VsdF9rZXlcIjpbXCJDb250ZW50c1wiLFwiQ29tbW9uUHJlZml4ZXNcIl19LFwiTGlzdFBhcnRzXCI6e1wiaW5wdXRfdG9rZW5cIjpcIlBhcnROdW1iZXJNYXJrZXJcIixcImxpbWl0X2tleVwiOlwiTWF4UGFydHNcIixcIm1vcmVfcmVzdWx0c1wiOlwiSXNUcnVuY2F0ZWRcIixcIm91dHB1dF90b2tlblwiOlwiTmV4dFBhcnROdW1iZXJNYXJrZXJcIixcInJlc3VsdF9rZXlcIjpcIlBhcnRzXCJ9fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5wYWdpbmF0b3JzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0ge1widmVyc2lvblwiOjIsXCJ3YWl0ZXJzXCI6e1wiQnVja2V0RXhpc3RzXCI6e1wiZGVsYXlcIjo1LFwib3BlcmF0aW9uXCI6XCJIZWFkQnVja2V0XCIsXCJtYXhBdHRlbXB0c1wiOjIwLFwiYWNjZXB0b3JzXCI6W3tcImV4cGVjdGVkXCI6MjAwLFwibWF0Y2hlclwiOlwic3RhdHVzXCIsXCJzdGF0ZVwiOlwic3VjY2Vzc1wifSx7XCJleHBlY3RlZFwiOjMwMSxcIm1hdGNoZXJcIjpcInN0YXR1c1wiLFwic3RhdGVcIjpcInN1Y2Nlc3NcIn0se1wiZXhwZWN0ZWRcIjo0MDMsXCJtYXRjaGVyXCI6XCJzdGF0dXNcIixcInN0YXRlXCI6XCJzdWNjZXNzXCJ9LHtcImV4cGVjdGVkXCI6NDA0LFwibWF0Y2hlclwiOlwic3RhdHVzXCIsXCJzdGF0ZVwiOlwicmV0cnlcIn1dfSxcIkJ1Y2tldE5vdEV4aXN0c1wiOntcImRlbGF5XCI6NSxcIm9wZXJhdGlvblwiOlwiSGVhZEJ1Y2tldFwiLFwibWF4QXR0ZW1wdHNcIjoyMCxcImFjY2VwdG9yc1wiOlt7XCJleHBlY3RlZFwiOjQwNCxcIm1hdGNoZXJcIjpcInN0YXR1c1wiLFwic3RhdGVcIjpcInN1Y2Nlc3NcIn1dfSxcIk9iamVjdEV4aXN0c1wiOntcImRlbGF5XCI6NSxcIm9wZXJhdGlvblwiOlwiSGVhZE9iamVjdFwiLFwibWF4QXR0ZW1wdHNcIjoyMCxcImFjY2VwdG9yc1wiOlt7XCJleHBlY3RlZFwiOjIwMCxcIm1hdGNoZXJcIjpcInN0YXR1c1wiLFwic3RhdGVcIjpcInN1Y2Nlc3NcIn0se1wiZXhwZWN0ZWRcIjo0MDQsXCJtYXRjaGVyXCI6XCJzdGF0dXNcIixcInN0YXRlXCI6XCJyZXRyeVwifV19LFwiT2JqZWN0Tm90RXhpc3RzXCI6e1wiZGVsYXlcIjo1LFwib3BlcmF0aW9uXCI6XCJIZWFkT2JqZWN0XCIsXCJtYXhBdHRlbXB0c1wiOjIwLFwiYWNjZXB0b3JzXCI6W3tcImV4cGVjdGVkXCI6NDA0LFwibWF0Y2hlclwiOlwic3RhdHVzXCIsXCJzdGF0ZVwiOlwic3VjY2Vzc1wifV19fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS53YWl0ZXJzMi5qc29uXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9